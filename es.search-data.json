{"/comienza/":{"data":{"":"","ayuda-y-soporte-técnico#Ayuda y soporte técnico":" Escríbenos a hello@omegaup.com Soporte técnico Pregunta a la comunidad ","explora#Explora":" Plataforma omegaUp Organización sin fines de lucro ","pasos-a-seguir#Pasos a seguir":" Revisa nuestro código de conducta. Crea tu cuenta en omegaUp.com/login. Completa tu perfil en mi perfil: Puedes acceder desde el menú desplegable en la sección superior derecha donde aparece tu nombre de usuario.\nCambia tu contraseña desde el manú de la sección izquierda con botones azules. Configura tus preferencias y selecciona tu lenguaje de programación. Si tienes más de una cuenta puedes agruparlas en administrar identidades. Navega y descubre la plataforma omegaUp. Revisa e incrementa tus insignias. Escoge tu perfil: Estudiante\n¿Cómo resolver problemas? [parte 0] ¿Cómo resolver problemas? [parte 1] ¿Cómo resolver problemas? [parte 2] Busca tus problemas Participa para ser Coder del Mes reglas del coder del mes Docente\nCrea tus cursos con tareas y exámenes. Agregar asistentes a curso. Crear cuentas de usuarios para evento administrador de identidades. Revisa automáticamente los códigos en envíos de cursos. Analiza las diferencias en salidas para envíos de problemas educativos. Continúa programando. Resuelve más problemas Aprende de la solución al problema. Inspírate con nuestras historias de éxito. ","quieres-ayudarnos#¿Quieres ayudarnos?":" Abre un issue. "},"title":"Comienza"},"/novedades/":{"data":{"":"Descubre nuestra información actualizada relevante.","coder-del-mes#Coder del mes":"Otorgado a personas que han sido nombradas Coder del Mes.\nLiga de programación Bienvenido a los diferentes concursos de programación.\nGoogle Summer of Code Verano de programación de Google con omegaUp.\nCoder del mes Otorgado a personas que han sido nombradas Coder del Mes.","google-summer-of-code#Google Summer of Code":"Verano de programación de Google con omegaUp.","liga-de-programación#Liga de programación":"Bienvenido a los diferentes concursos de programación."},"title":"Novedades"},"/posts/162/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 10 **Autor: **Alain Acevedo Mejía\nConsidero este problema como un buen ejemplo para quienes desean comenzar a trabajar con problemas de programación dinámica. Se nos pide calcular la cantidad de pulseras diferentes que se pueden construir bajo ciertas condiciones. Podemos comenzar preguntándonos, ¿qué sucede si la primera cuenta es negra? La siguiente podrá ser sólo blanca. Y si comenzamos con una blanca, la siguiente puede ser negra o blanca. Podemos entonces en una matriz de 2xn colocar en cada columna cuántas secuencias distintas hay que en la posición i-ésima terminen en negro y cuántas en blanco de tal modo que no haya dos cuentas negras consecutivas. Simplemente, para obtener los números de la siguiente posición, observamos que el número de las que terminan en blanco es la suma de ambos números de la posición anterior y de las que terminan en negro es el número de secuencias que terminan en blanco de la posición anterior.\nResta solo un detalle más a considerar. Requerimos que la secuencia no inicie y termine en negro, pues los extremos quedarán adyacentes al cerrar la pulsera. Una forma de resolver esto es la siguiente: Contamos, con el método descrito, cuántas secuencias distintas hay que inicien con blanco y que no tengan dos cuentas negras consecutivas. El número que nos pide el problema será entonces la cantidad de pulseras que empiezan con blanco y cumplen con que no haya dos negras consecutivas (independientemente de con qué color terminen) más el número de pulseras que inicien con negro y terminen con blanco (y claro, cumplan con que no haya dos negras consecutivas). ¿Cuántas hay de estas últimas? La misma cantidad que de pulseras que inician con blanco y terminan con negro, pues su simétrica inicia con negro, termina con blanco y claramente sigue cumpliendo el que no posea dos cuentas negras consecutivas. Así que es posible resolver el problema con un código muy breve, como se muestra abajo.\nSolo resta mencionar que hay que tener cuidado de aplicar el módulo correctamente. Se pueden evitar errores definiendo el valor del mismo para no tener que escribir el número varias veces.\nEl siguiente código resuelve el problema:"},"title":"Solución a \"Pulseras\""},"/posts/38-nuevos-problemas-de-karel-disponibles-gracias-a-la-oieg/":{"data":{"":"La Olimpiada de Informática del Estado de Guanajuato (OIEG), liderada este año por José Refugio López (Kuko), han hecho públicos 38 problemas de Karel para que la comunidad en general pueda practicar previo a la Olimpiada Mexicana de Informática 2014. Pueden resolver los nuevos problemas en los siguientes concursos:\nNivel introductorio:\nORIG2013 Karel PreEstatal Ejercicios 1 Nivel básico\nORIG 2013 Examen PreEstatal Karel Nivel intermedio\nORIG 2013 Concurso Estatal Mañana ORIG 2013 Concurso Estatal Tarde OIEG 2013 Examen Reclasificación Karel OIEG 2013 Preselección Práctica 01 OIEG 2013 Preselección Práctica 02 OIEG 2013 Preselección Examen 01 "},"title":"38 nuevos problemas de Karel disponibles gracias a la OIEG!"},"/posts/445/":{"data":{"":" Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 14 Autor: Miguel Covarrubias Fuente: Codeforces Este problema es una ligera modificación del Let’s Play Osu! que apareció en la ronda 146 en Codeforces. La solución explicada la pueden encontrar en el editorial.\nPara $latex N \\le 10$ se pueden checar todas las $latex 2^N$ configuraciones de pistas. Para $latex N \\le 1000$ funciona una dinámica $latex O(N^2)$, donde los estados son (posición, altura/profundidad que se lleva hasta el momento).\nLes dejo la implementación de DiegoRoque como un muy buen ejemplo de una solución a este problema."},"title":"Solución a \"Pista\""},"/posts/68-nuevos-problemas-de-teddy-online-judge/":{"data":{"":"Ya pueden encontrar en OmegaUp 68 nuevos problemas migrados desde Teddy Online Judge. Todos estos problemas tienen el tag teddy asi que son fáciles de identificar.\nAunque estos problemas tienen mucho tiempo en Teddy y han tenido mas de 15k ejecuciones en ese juez, han sido migrados de manera automática ya que Teddy usa HTML y OmegaUp usa un markup modificado, entre otros cambios interesantes. Eso quiere decir que puede haber erroes. Si encuentras uno de ellos no dudes en enviar una clarificacion.\nPara celebrar, he creado el concurso Problemas de Teddy Online Judge con los 10 problemas mas significativos, es decir, los mas resueltos en aquel juez."},"title":"68 nuevos problemas de Teddy Online Judge"},"/posts/administracion-de-identidades/":{"data":{"actualizar-información-básica#Actualizar información básica":"","cambiar-password#Cambiar Password":"","crear-identidades#Crear Identidades":"","cómo-funciona-la-administración-de-identidades#¿Cómo funciona la Administración de Identidades?":"","ingresar-a-omegaup-por-medio-de-una-identidad#Ingresar a omegaUp por medio de una identidad":"","qué-es-una-identidad#¿Qué es una Identidad?":"","ventajas#Ventajas":"","vincular-identidad-con-usuario#Vincular identidad con usuario":"Hemos liberado una nueva funcionalidad en omegaUp para que puedas administrar identidades dentro de un grupo. Si has sido organizador de un concurso o curso, seguramente has requerido de la ayuda de algún miembro de omegaUp para dar de alta las cuentas de los usuarios que participarán en el evento que organizaste con este script. Con esta nueva funcionalidad serás capaz de realizar todas las acciones por tu cuenta.\n¿Qué es una Identidad?Una identidad en omegaUp es una cuenta con los privilegios suficientes para ingresar a un curso o concurso para el cual haya sido creada. Anteriormente, para que un usuario pudiera ingresar al curso o concurso, era necesario hacer los cambios necesarios en el código descrito en el párrafo anterior.\nVentajas Las ventajas que se tienen con esta nueva funcionalidad se describen a continuación:\nProfesor / organizador Rapidez: Al poder crear sus identidades, el organizador puede disponer de ellas en el momento que las da de alta. Ya no es necesario esperar a que se haga el despliegue con los usuarios que se pretenden agregar. Control: Estas cuentas de identidades ahora las podrá visualizar en el mismo lugar donde están las cuentas de los usuarios que se agregan al curso. Seguridad: Es muy importante señalar que una vez que la identidad se asocia a un concursante, esta ya no puede ser utilizada por nadie más. Ya no será necesario reutilizar cuentas. Alumno / participante Privacidad: Siempre y cuando las identidades se den de alta con nombres genéricos, los datos de los usuarios no serán expuestos en ninguna parte de la plataforma. Control: El usuario podrá agregar a su cuenta tantas identidades le sean asignadas, lo cual tiene una gran ventaja, ya que todos los problemas que resuelva con cualquiera de sus identidades serán tomados en cuenta para su rankeo. ¿Cómo funciona la Administración de Identidades?Crear Identidades En la animación anterior se muestra cómo crear un grupo con identidades, este proceso se describe paso a paso a continuación:\n1. Ingresa a la sección de Mis Grupos. Una vez que ingresas a omegaUp, y en el menú superior busca la opción Concursos \u003e Mis grupos:\n2. Crear el grupo Si ya creaste el grupo pasa al punto 3, de lo contrario presiona el botón de Crear grupo:\nLlena los datos de nombre y descripción del Grupo, el alias se genera automáticamente de acuerdo al nombre del grupo. Una vez que has llenado los datos, presiona el botón de Crear grupo:\n3. Selecciona el grupo Busca tu grupo en el listado, al encontrarlo da clic sobre el para que te mande al detalle:\n4. Crear las identidades Si cuentas con los permisos suficientes, en esta pantalla encontrarás una pestaña de Crear identidades, al dar clic en ella te aparecerá lo siguiente:\nVas a ver un botón que dice seleccionar el archivo, da clic para que puedas cargar un archivo en formato CSV.\nNota: Esta característica aún está en etapa de experimentación, así que si requieres subir un archivo con identidades, es necesario que envíes un correo a engineering@omegaup.com con tu nombre de usuario y el motivo para el que utilizarás la funcionalidad.\n5. Llena el archivo Si ya tienes el archivo CSV con las identidades a crear, pasa al punto 6, de lo contrario aquí te indicamos cómo generarlo.\nAquí puedes descargar la plantilla para que puedas registrar a todos los usuarios desde algún programa de Hoja de cálculo. Cuando guardes los cambios cerciórate de que el archivo lo guardas en el formato correcto (CSV). Este es el ejemplo de un archivo para subir.\nLas consideraciones que debes tener al crear el archivo son las siguientes:\nTodos los campos son obligatorios y deben seguir con las siguientes reglas:\nusername: Mismas reglas que cuando se da de alta un usuario desde la página de registro. name: Mismas reglas que cuando se da de alta un usuario desde la página de registro. country_id: Debes ingresar el código del país o la región según iso3166-2, ejemplo: Si los concursantes son de México, entonces debes escribir el código MX. state_id: Mismo caso que el campo anterior, debes buscar el código del estado/provincia/distrito al que pertenezca según iso3166-2, este código está compuesto por [país o región-estado o provincia o distrito]. Sólo escribe los dígitos que están después del caracter -. Ejemplo: Si los concursantes son de Guanajuato, México, debes escribir GUA. gender: Si tienes identificados a los concursantes, puedes indicar una de las siguientes opciones: [male, female, other, decline]. Recuerda que si escribes cualquier cosa distinta a las 4 opciones listadas, te aparecerá un error al querer subir el archivo. school: Si ya tienes registrada la escuela en la plataforma, escribe el nombre tal cual está dada de alta, de lo contrario, se va a generar un nuevo registro de escuela. Guarda el archivo en formato CSV como se mencionó anteriormente.\n6. Sube el archivo Elige el archivo con las identidades que deseas dar de alta y da clic en abrir:\nTodas las identidades te deben de aparecer en formato de tabla como se muestra en la siguiente imagen:\nUna vez que las puedas visualizar, revisa que los datos son correctos. En caso de que tengas información incorrecta, vuelve a modificar tu archivo de identidades, guárdalo y regresa al punto 4.\nSi los datos son los correctos, da clic en el botón de Crear identidades. Listo, ahora ya cuentas con identidades ligadas a un grupo.\nComo puedes notar, en la tabla de arriba se visualizan las contraseñas asignadas a cada identidad, es recomendable que las guardes en algún lugar seguro para posteriormente compartirlas con los participantes de tu concurso o curso (lo puedes hacer presionando el botón que aparece justo debajo del botón de Crear Identidades) ya que si te sales de esta pantalla, no las podrás volver a consultar.\nNota: Las contraseñas se hashean y se almacenan en la base de datos: quiere decir que ya no se puede revertir para visualizar la contraseña.\nPara tener un mejor control sobre las identidades que creaste, estas cuentan con un identificador en el username: [nombre-del-grupo:username], de esta forma siempre tendremos una asociación directa entre identidades y grupo.\nEn caso de que no hayas guardado las contraseñas, no te preocupes, las puedes regenerar volviendo a subir el .csv. Alternativamente si sólo quieres restablecer la contraseña de un sólo alumno, puedes hacer eso desde la pestaña de miembros, tal como se muestra en la siguiente animación:\nCambiar Password También puedes editar información de las identidades, recuerda que solamente el creador de las identidades puede realizar esta acción. La forma de hacerlo se muestra en la siguiente animación:\nActualizar información básica Ya que le compartiste las identidades a los respectivos participantes, ellos pueden ingresar a la plataforma de la misma forma que cualquier otro usuario, la diferencia que van a notar es que estas cuentas no podrán editar sus datos, en la siguiente animación se muestra:\nIngresar a omegaUp por medio de una identidadUn caso que pudiera ser muy común es que un usuario tenga que agregar varias identidades.\nSupongamos el siguiente ejemplo: El alumno Juan Pérez utiliza frecuentemente la plataforma de omegaUp, porque en ella puede practicar con problemas de programación. En la escuela que asiste, su maestra decidió crear un curso en la plataforma y dio de alta las identidades con las que quiere que ingresen sus alumnos. Además, por su buen desempeño, Juan es invitado a un concurso estatal de programación, donde el organizador ya ha creado las identidades con las que ingresarán los participantes de dicho concurso.\nEn este caso Juan ya cuenta con su usuario de la plataforma, y aparte le han compartido dos cuentas con identidades adicionales. Si quiere que todos los problemas que resuelva tanto en su escuela, como en el concurso sean contabilizados para su posición en la tabla de mejores coders, lo que debe hacer es lo que se muestra en la siguiente animación:\nVincular identidad con usuarioEl usuario debe ingresar a omegaUp con su cuenta que comúnmente utiliza.\nDespués debe dirigirse a Mi perfil en el menú superior derecho, y después da clic en Editar Perfil tal como se muestra en la siguiente imagen:\nUna vez que dentro de la pantalla de Editar Perfil, si se desplaza un poco, debajo de Editar tu perfil se puede encontrar la sección de Administrar Identidades. Sólo es cuestión de que agregue el username y la contraseña de la identidad para que esta se asocie a la cuenta.\nAtentamente, El equipo de omegaUp"},"title":"Administración de Identidades"},"/posts/analisis-de-diferencias-en-salidas-para-envios-de-problemas-educativos/":{"data":{"":"","#":"Hemos liberado una nueva funcionalidad que será muy útil para los usuarios que comienzan a utilizar la plataforma, ya que contarán con una herramienta más para apoyarlos en su aprendizaje. Esta funcionalidad les permitirá ver un análisis de las diferencias entre las salidas que dan sus programas y las salidas oficiales para los envíos de problemas educativos.\n¿En qué consiste el análisis de las diferencias? Para todos los problemas educativos que accedan vía cursos, los usuarios podrán comparar el resultado que obtuvo la salida de la solución que acaban de enviar, contra el resultado que se espera de acuerdo a los casos que subió el creador del problema.\nVentajas El uso de esta herramienta traerá beneficios, tanto para profesores como para estudiantes, los cuales se describen a continuación:\nProfesor Tiempo: Al permitir a los estudiantes ser más autodidactas, el profesor tendrá más tiempo para revisar temas de mayor relevancia o donde los estudiantes presentan más problemas. Alumno Problemas auto didácticos: Al recibir retroalimentación más completa desde la plataforma, el estudiante puede realizar más problemas, los cuales lo irán guiando con las pistas para llegar a la solución de los problemas sin necesidad de contar con la figura del profesor. ¿Cómo funciona esta nueva herramienta? Profesor Lo primero que se debe tomar en cuenta por parte del profesor / creador de problemas es que el problema sea meramente educativo, quiere decir, que este no vaya a ser tomado en cuenta o ya se esté usando en concursos, ya que esto podría dar ventaja a usuarios que ya hayan visto las salidas esperadas. Una vez que ya se definió que el problema se utilizará con fines educativos se procede a la configuración. Si el problema es nuevo, se sigue el mismo procedimiento como para crear cualquier problema: Menú \u003e Problemas \u003e Crear un problema, donde se encontrará el siguiente campo:\nLas opciones disponibles son:\nNinguno (predeterminado): El problema continúa como siempre ha existido, sin mostrar diferencias de salidas en los casos. Sólo ejemplos: Se mostrarán las diferencias de salidas para todos los casos que se guardaron en el directorio examples. Todos: Se mostrarán las diferencias de salidas para todos los casos que se agregaron en el archivo .zip, incluidos los ejemplos. En caso de que el problema ya exista y se desee agregar esta configuración, se debe ingresar a la sección de editar problema de la forma tradicional: Menú \u003e Usuario \u003e Mis problemas, y después dar clic en el icono de Editar problema . En este formulario también se encontrará disponible la configuración:\nEl siguiente paso es agregar el problema a algún curso; recuerda que esta configuración sólo funciona en ese lugar.\nEstudiante Para que los estudiantes puedan aprovechar esta herramienta deben estar inscritos al curso que contenga problemas educativos. 1.- El primer paso a realizar es ingresar al curso, tal como se hace tradicionalmente, seleccionar la tarea en la que estará trabajando y elegir el problema educativo.\n2.- Después se debe enviar una solución y esperar a que el juez de omegaUp evalúe el envío. En el listado de envíos aparece el botón para ver los detalles, dar clic.\n3.- En la ventana que aparece se mostrará la información de los casos, con su respectivo puntaje por cada grupo.\n4.- Puedes presionar cualquiera de los botones para ver la diferencia en las salidas de los casos, si todos los casos del grupo son los mismos que los esperados o si hay alguna salida que no coincide.\nEn la siguiente animación se puede ver su funcionamiento tal como le aparecerá al estudiante en el curso:"},"title":"Análisis de diferencias en salidas para envíos de problemas educativos"},"/posts/anunciando-omegaup-escuelas/":{"data":{"":"Con el objetivo de continuar mejorando las habilidades de programación de los estudiantes, nos emociona anunciar el lanzamiento de un nuevo proyecto: omegaUp Escuelas. Nuestro objetivo es llevar omegaUp a los salones de clases, creando una plataforma educativa, intuitiva y fácil de utilizar que se adapte a las necesidades de los profesores y estudiantes. La plataforma es una herramienta de aprendizaje que permite a los profesores enseñar a sus alumnos pensamiento algorítmico mediante la solución de problemas. Con ello, el estudiante desarrollará habilidades que le ayudarán en su crecimiento profesional.\nEn omegaUp Escuelas, el profesor puede crear sus propios cursos con tareas y exámenes utilizando problemas propios o problemas públicos que ya existen en la plataforma. En el primer caso, el profesor puede hacer uso de los recursos que tenemos disponibles en omegaUp para publicar sus problemas. Esto le permitirá adaptar la plataforma a su curso y a las necesidades de sus estudiantes. Si el profesor opta por la segunda opción, éste contará con una clasificación de problemas por tema y por nivel. Así, él puede seleccionar con mayor facilidad los problemas que apoyen el proceso de aprendizaje de sus alumnos.\nAdemás, ahora los profesores pueden registrar a sus estudiantes en un curso y seguir su avance en las tareas y exámenes asignados. A fin de facilitar la tarea administrativa del profesor, este puede descargar la lista de estudiantes y su avance a una hoja de cálculo, que le permite realizar un análisis más detallado de su curso.\nCon esta nueva iniciativa, los estudiantes cuentan con una plataforma más organizada donde pueden tener fácil acceso a sus tareas y exámenes además de revisar su avance general en tiempo real.\nomegaUp Escuelas aún está en desarrollo, pero la versión beta ya está disponible. Actualmente, se están llevando a cabo pruebas piloto en dos escuelas: ITSUR y CBTis 217. Gracias a Luis Germán Gutiérrez Torres y sus estudiantes por ayudarnos en este proceso.\nCada día el número de organizaciones y escuelas que están probando omegaUp Escuelas está creciendo. La OMI está utilizando la plataforma para crear cursos de entrenamiento. En cuanto a escuelas, tenemos un total de 16 cursos creados. Gracias a todos ellos por darnos la oportunidad de apoyarlos en este proceso de enseñanza-aprendizaje.\nTe invitamos a que visites omegaUp Escuelas y comiences a utilizarla. Si tienes alguna duda de cómo utilizarla, cómo incorporar la plataforma a tus clases, o si tienes algún comentario, escríbenos a escuelas@omegaup.org."},"title":"Anunciando omegaUp Escuelas"},"/posts/anunciando-omegaup-mentores/":{"data":{"":"La misión de omegaUp es incrementar el número de ingenieros de software talentosos en América Latina, por lo que nos complace anunciar públicamente el programa omegaUp Mentores. El objetivo de este proyecto es ayudar a que nuestros usuarios más activos potencialicen sus habilidades, conectándolos con gente de experiencia que puedan servirles de guía para el desarrollo de su carrera profesional.\nPara ello, omegaUp ofrecerá a los coders del mes la posibilidad de recibir mentoría personalizada de ingenieros de software voluntarios con experiencia internacional, habiendo laborado en las principales empresas de tecnología del mundo, tales como Microsoft, Facebook, Amazon, Google, entre otras. Además, el usuario galardonado se hará acreedor a un diploma y un premio que podrá ser de utilidad en su desarrollo técnico o académico. Los ganadores interactúan con sus mentores mediante videollamadas y correos electrónicos. En el mes de Enero, el usuario Jorge Salazar Cruz, estudiante del CBTis 60 en Guanajuato, México, tuvo la oportunidad de hablar con Rafael Díaz, ingeniero de software en Microsoft.\nJorge Salazar (CBTIs 60) \u0026 Rafael Díaz (Microsoft)\nTe invitamos a continuar resolviendo problemas en omegaUp para que obtengas más puntos en la plataforma y logres mejorar dia a dia. ¡Tú puedes ser el próximo Coder del mes!\nPuedes encontrar más información de cómo se calcula el coder del mes en omegaUp aquí: https://blog.omegaup.com/2014/06/el-nuevo-ranking-de-omegaup/ . Para dudas y mayor información sobre este programa, puedes contactarnos en mentores@omegaup.com"},"title":"Anunciando omegaUp Mentores"},"/posts/aventuras-en-el-evaluador-parte-1/":{"data":{"":"Como parte de los propósitos de año nuevo, me dispuse a hacer un refactor masivo del código con el cual se evalúan y ejecutan las soluciones en omegaUp. Habían muchas motivaciones para hacer la actualización: tener un sandbox más moderno, eliminar un montón de código duplicado, mejorar las pruebas, el logging, el paralelismo en los jueces, cómo se despliega el tiempo y la memoria, el desempeño de los envíos, soportar C++11 y más lenguajes. Son muchísimos cambios, así que haré dos posts explicándolos: este post se centrará en los cambios que se hicieron en la arquitectura de jueceo y el siguiente se enfocará únicamente en el nuevo sandbox.\nEl primer cambio que se va a notar es que el servidor donde se hospeda la página principal ya no califica envíos! Gracias a nuestros queridos empleadores, conseguimos un par de máquinas virtuales gratuitas con Linux en Azure que se utilizarán exclusivamente para correr programas de los concursantes. Estas máquinas son menos poderosas que el servidor que usábamos antes, pero gracias a que el nuevo sandbox tiene muchísimo menos overhead, la diferencia será casi negligible. Una de las consecuencias de esto es que la página va a ser un poco más responsiva y los veredictos serán más rápidos. Esto también trae seguridad, porque aunque quisieran hacer trampa, ahora será casi imposible: las máquinas donde se ejecuta código de concursantes ya no son las mismas máquinas donde están las salidas esperadas :).\nOtro cambio grande es la manera en la que se mide y reporta la memoria que consumen los programas. Antes la ejecución del programa se detenía cada cierto tiempo para poder medir exactamente cuántos bytes estaban siendo utilizados. Ahora para bajar el overhead del sandbox, la política de medición es mucho más laxa y sólamente se toman en cuenta los bytes de memoria privada del programa: esto excluye la librería de C estándar, el código ejecutable del programa, y algunas constantes. En Java, la manera en la que se establece el límite de memoria no cambió (así que cualquier envío que fuera MLE antes lo seguirá siendo), pero ahora para que se vea más bonito el reporte, se excluye de la cuenta la memoria ocupada por la máquina virtual de Java. Hablando de Java, la causa #1 de errores de compilación antes se reportaba como Runtime Error: usar un nombre de clase que no es “Main”. Ahora se reporta como error de compilación y se te indica que la clase se debe llamar Main.\nTodos los runtimes y compiladores fueron actualizados. Ahora usamos GNU GCC 4.8, Java OpenJDK 7.0, Free Pascal 2.6, Ruby 1.9, Python 2.7, Glorious Glasgow Haskell Compiler 7.6 y Karel 1.1. Soportamos ahora sí todos los features de Java 7 (bienvenido sea el operador diamante), y agregamos la opción para compilar en C++11 (posiblemente en un futuro eliminemos la versión anterior de C++, gnu++03, cuando el soporte de C++11 sea lo suficientemente maduro).\nEl bug más feo que se arregló fue uno en el cual si habían más de 2 jueces conectados, únicamente se usaban dos, desperdiciando mucho tiempo y poder de cómputo. Esto únicamente ocurría durante concursos muy grandes, pero era bastante molesto para nosotros. También habían muchos errores con el manejo de la cola de espera, tanto de los jueces para poder compilar envíos, como la de los envíos que esperan un juez disponible. El resultado es que donde antes habían esperas de varios segundos, ahora aún en periodos donde la cola está llena las máquinas que juecean estarán esperando únicamente ~20 milisegundos entre envíos en lo que se les asigna algo para hacer.\nDespués de aproximadamente 80 commits en nuestros varios repositorios, espero que disfruten nuestra nueva y mejorada infraestructura (que en realidad debería ser totalmente invisible si hice bien mi trabajo)."},"title":"Aventuras en el evaluador, parte 1"},"/posts/bases-de-liga-de-programacion-de-omegaup/":{"data":{"":"omegaUp Invita a todos los estudiantes de nivel media superior y superior a participar a la 2° edición de la Liga de programación omegaUp.\nReglas:\nDeben ser estudiantes de Preparatoria, Licenciatura, Maestría, Doctorado o Postdoctorado. Los puntos otorgados por cada problema serán tomados como parte del puntaje final. El primer AC de cada etapa recibirá 10 puntos extras. Problemas resueltos parcialmente serán tomados en cuenta. Para determinar los ganadores se utilizará como criterio el número de puntos obtenidos y como segundo criterio el número de AC que tenga a lo largo de las etapas, es decir gana el quien tenga mayor cantidad de puntos y en caso de ser necesario mayor número de problemas resueltos correctamente. Dinamica:\nLa Liga de Programación omegaUp contará con diferentes etapas a lo largo del 2022 y parte del 2021. Al final de cada concurso se entregan los puntos correspondientes a cada participante. Al llegar a la etapa final de la liga de programación de omegaUp se sumarán todos los puntos de cada participante que se obtuvieron durante todas las rondas y se premiará al participante que más puntos haya sumado. Premios:\nLos premios para los primeros 3 lugares se darán trofeos únicos. Cada participante recibirá una constancia de participación. Se entregará un reconocimiento especial y playeras personalizadas a los mejores 10 participantes. Los participantes tendrán la oportunidad de hacerte notar con empresas de tecnología que están buscando talento en Ingeniería de Software. Lenguajes de programación permitidos:\nC C++ Java Cualquier punto no especificado en esta convocatoria, será resuelto por el Comité Organizador y su decisión será inapelable."},"title":"Bases de Liga de Programación de omegaUp"},"/posts/cambios-en-el-ranking/":{"data":{"":"Continuando con los cambios en el ranking de omegaUp, a partir de hoy sólo los problemas resueltos marcados como **públicos **van a contar puntos para calcular el score. Este cambio es con la intención de hacer el ranking más justo con problemas visibles a todos.\nDe igual forma, el **Coder del Mes **también será calculado sólo con problemas públicos.\nDesafortunadamente varios competidores cayeron bastantes posiciones en el ranking. Ayúdenos a convencer a su problemsetter favorito a que los problemas se publiquen al finalizar los concursos."},"title":"Cambios en el ranking"},"/posts/categorias/":{"data":{"":"Conoce las Categorías de Usuarios de omegaUp\nHemos asignando una categoría a cada usuario de omegaUp. La categoría de cada usuario depende su posición actual en el ranking de omegaUp como se muestra a continuación:\nEl top 1% de usuarios mejor posicionados en el rank obtiene la categoría ω (“omega pequeña”) y color rojo. El top 9% de usuarios siguientes obtiene categoría Ω (“omega grande”) y color amarillo. El top 15% de usuarios siguientes obtiene categoría Θ (“zeta” o “theta”) y color azul. El top 35% de usuarios siguientes obtiene categoría Ο (“ómicron grande”) y color verde. El top 40% de usuarios siguientes obtiene categoría ο (“ómicron pequeña”) y color gris. ¿Cómo puedo saber mi categoría?\nPuedes verla en tu página de perfil.\n¿Cómo asciendo de categoría?\n¡Resolviendo más problemas! Conforme resuelvas más problemas, tu posición en el rank irá subiendo y con ella tu categoría.\n¿De dónde vienen los nombres de las categorías?\nDe la notación de Landau.\n¿Por qué omega pequeña (ω) es más alto que omega grande (Ω)?\nEl orden de las categorías viene de la definición de las notaciones de Landau.\nNotación\nDefinición formal\nDescripción\nInterpretación práctica\nf(n) = o(g(n))\nf es dominada por arriba asintóticamente por g.\nf \u003c g\nf(n) = O(g(n))\nf es acotada por arriba asintóticamente por g.\nf \u003c= g\nf(n) = Θ(g(n))\nf(n) = o(g(n)) y f(n) = O(g(n))\nf es acotada por arriba y abajo asintóticamente por g.\nf = g\nf(n) = Ω(g(n))\nf es acotada por abajo asintóticamente por g.\nf \u003e= g\nf(n) = ω(g(n))\nf es dominada por abajo asintóticamente por g.\nf \u003e g"},"title":"Categorías omegaUp"},"/posts/chocolates/":{"data":{"":"Problema: Los Chocolates del Agente Nieves\nEn este problema tenemos un tubo de chocolates los cuales se van a vender uno cada día, pudiendo vender únicamente los que están en ese momento en los extremos. El precio por vender un chocolate es igual al precio base de chocolate multiplicado por el número de días que se han vendido chocolates (empezando en 1).\nEl objetivo es encontrar la mayor ganancia posible al vender todos los chocolates.\nSi lo quisiéramos resolver como una búsqueda, ¿qué tendríamos que considerar? En una búsqueda, nos importa obtener dos cosas, el espacio de búsqueda (es decir, cómo estará representado nuestro estado y qué valores puede tener), y las operaciones en nuestra búsqueda.\nEn cuanto a nuestros estados en la búsqueda, nos importa saber qué chocolates aún tenemos disponibles y cuántos días han pasado. Podríamos empezar teniendo N valores booleanos por cada chocolate y un número para saber cuántos días han pasado, por ejemplo, si tenemos 3 chocolates y aún no vendemos nada, tendríamos el estado (1, 1, 1, 1), si ya vendimos el primer chocolate, tendríamos (0, 1, 1, 2), si vendimos el tercer chocolate tendríamos (1, 1, 0, 2) y si vendemos los chocolates 1 y 2, tendríamos (0, 0, 1, 3). Sin embargo, esta representación es un poco inútil, ya que en el peor de los casos, tendríamos 1000 chocolates, lo cual hace un estado de 1000 posibles valores.\nPodemos mejorar esto solo guardando únicamente los índices a los extremos del tubo, ya que ya sabemos que aún tenemos todos los chocolates entre estos dos valores. Eso transforma los estados anteriores a los siguientes estados respectivamente: (1, 3, 1), (2, 3, 2), (1, 2, 2). y (3, 3, 3). Esto vuelve al estado muchísimo más manejable, pues cada valor puede valer únicamente entre 1 y 1000.\nYa que tenemos nuestro estado, definimos las operaciones que hay que hacer para ir entre estado y estado, y estas operaciones son únicamente 2, vender el chocolate de la izquierda, o vender el chocolate de la derecha, si estamos en el estado (1, 3, 1) y vendemos el de la izquierda, nos lleva al estado (2, 3, 2), y si vendemos el de la derecha, nos lleva al estado (1, 2, 2). Podemos continuar estas instrucciones recursivamente sobre los estados que resulta y generar un árbol de búsqueda:\nUna vez teniendo el árbol de búsqueda, podemos proceder a darle valor a cada uno de los nodos. Del nodo inicial (1, 3, 1), si decides vender el chocolate de la izquierda, obtendrás una ganancia igual a lo que te de el nodo (2, 3, 2) más el precio del chocolate 1 multiplicado por el número de días, que en este caso es 1, y si decides vender el chocolate de la derecha, la ganancia será lo que de el nodo (1, 2, 2) más el precio del chocolate 3 (múltiplicado por 1). De las dos opciones, tomaremos el máximo.\nLlenemos ahora el resto del árbol de búsqueda con estos datos:\nDe aquí podemos ver dos cosas, la primera es que los nodos de hasta abajo, que son nuestros nodos hoja, tienen el mismo valor en el chocolate izquierdo como en el derecho, por lo que el valor máximo que podemos obtener de ellos es el precio de ese único chocolate por el número de días que llevamos. Y la segunda cosa es que tenemos nodos repetidos, por lo que cuando hagamos nuestra búsqueda, necesitamos guardar cálculos que ya hayamos hecho para no calcular un mismo estado más de una vez.\nNuestro árbol de búsqueda ya está terminado, así que es hora de convertirlo a una función matemática. Nuestra función recibe como entrada un estado, en este caso el chocolate más a la izquierda que nos queda, el más a la derecha y el nivel en el que estamos, y dado lo que aprendimos de nuestro árbol de búsqueda, regresará el siguiente valor:\nCon esto, y considerando que debemos evitar repetir valores duplicados, es más que suficiente para resolver el problema con el método que más te guste, ya sea dinámica o memorización, aunque hay un pequeño problema para guardar los valores visitados.\nVamos a necesitar un arreglo de 1000 x 1000 x 1000 si es que queremos guardar un arreglo que se identifique de esta forma:\narreglo[izquierda][derecha][nivel]\nY esto es mucho más de lo que cabe en memoria, por lo que tenemos que encontrar una forma de reducir la memoria que necesitamos.\nLo que nos tenemos que dar cuenta es que la variable nivel es innecesaria, pues puede calcularse utilizando el número de chocolates que nos quedan en el tubo y el número de chocolates que teníamos originalmente:\nnivel = total - chocolates_en_el_tubo + 1\nY para calcular el número de chocolates que nos quedan en el tubo solo se necesitan el índice del chocolate más a la izquierda, y más a la derecha, que ya tenemos en nuestro estado.\nchocolates_en_el_tubo = derecha - izquierda + 1\nDespejando:\nnivel = total - derecha + izquierda - 1 + 1\nnivel = total - derecha + izquierda\nDe esta forma, podemos eliminar el nivel de todos nuestros estados y cambiar el valor de nivel de todas las fórmulas por el valor de arriba. Esto simplifica nuestro arreglo de visitados de 1000 x 1000 x 1000 a un arreglo de tan solo 1000 x 1000, lo cuál es suficiente en tiempo y memoria."},"title":"Solución a \"Los Chocolates del Agente Nieves\""},"/posts/coder-del-mes-2025/":{"data":{"relanzamiento-de-coder-del-mes#Relanzamiento de \u0026ldquo;Coder del Mes\u0026rdquo;":"Relanzamiento de “Coder del Mes”¡Nos complace anunciar mejoras importantes en el proceso de selección del Coder del Mes en omegaUp! Como algunos de ustedes habrán notado, hemos experimentado algunos problemas ocasionales con esta función recientemente. Esto se debió a la complejidad del código subyacente, lo que dificultaba la identificación y resolución rápida de los problemas. Entendemos que estas interrupciones pueden ser frustrantes, y siempre nos esforzamos por brindar una experiencia fluida y confiable. Agradecemos su paciencia mientras trabajábamos para abordar estos desafíos.\nPara solucionar esto, hemos realizado una refactorización profunda del motor del Coder del Mes. Hemos reescrito una parte significativa del sistema, enfocándonos en la simplicidad y el mantenimiento. Esto significa que el código ahora es significativamente más fácil de entender, depurar y mejorar. Si bien es posible que no vean ningún cambio inmediato en la superficie, esta refactorización interna nos prepara para una mayor confiabilidad y estabilidad en el futuro. Esperamos una experiencia del Coder del Mes más fluida y consistente a partir de ahora en omegaUp, y también nos permitirá agregar nuevas funciones y mejoras más fácilmente en el futuro.\nPara recordarles cómo funciona, el algoritmo del Coder del Mes se basa en los siguientes criterios:\nProblemas de Calidad: Solo se consideran problemas que han sido marcados con el sello de calidad. Primeras Resoluciones: Solo cuentan los problemas que el usuario resuelve por primera vez durante el mes en curso. Puntos por Problema: Los puntos que otorga cada problema se calculan según la fórmula descrita en: https://blog.omegaup.com/posts/el-nuevo-ranking-de-omegaup/ Soluciones Vistas: No se consideran problemas cuya solución oficial ya haya sido vista por el usuario en omegaUp. Problemas Creados: No se consideran problemas que el usuario haya agregado a omegaUp. Categoría “Para Ellas”: En esta categoría, solo pueden participar usuarias registradas con género femenino. Ganadores Recientes: Un usuario que haya sido elegido Coder del Mes en los últimos 12 meses no es elegible. El algoritmo calcula los puntos que cada usuario elegible obtiene por resolver problemas de calidad, teniendo en cuenta estos criterios. El Coder del Mes es seleccionado en base a estos cálculos.\nAdemás, queremos anunciar que el Coder del Mes de febrero será publicado el 1 de marzo de 2025. A partir de esa fecha, publicaremos el Coder del Mes del mes anterior, tanto para la categoría general como para la categoría femenina, el primer día de cada mes. ¡Gracias nuevamente por su comprensión!"},"title":"coder-del-mes-2025"},"/posts/codigo-de-conducta-en-omegaup/":{"data":{"":"omegaUp es una plataforma educativa y creemos que debemos fomentar un ambiente con respeto y la mismas oportunidades para todos. Por ello creamos el siguiente Código de Conducta, que debes cumplir para utilizar omegaUp.com.\nEn general y en especial en los concursos, cursos, el blog y redes sociales de omegaUp se crea una comunidad, donde se espera que los usuarios actúen con respeto y empatía hacia los demás. Todos los códigos enviados por los usuarios deben estar dirigidos a resolver el problema y no a violar las reglas o desestabilizar el sistema (el juez). Los usuarios no deben participar en ninguna actividad injusta que influya en los resultados propios o de cualquier otro usuario. Se debe asegurar con el profesor del curso, u organizador del concurso, si está permitido el uso de libros, notas, herramientas y código que hayas escrito previamente. Todos deben respetar los derechos de autor. Esto significa que, si se utiliza código de otra persona, el usuario debe contar con permiso explícito del autor original para hacerlo. Igualmente, los usuarios que desean añadir un problema de un tercero a la plataforma, deben seguir las reglas de reproducción o contar con permiso explícito del autor para hacerlo. El contenido que aporten los usuarios a la plataforma no debe ser inapropiado, ni ofensivo. Esto quiere decir que no se permite contenido que promueva insultos, acoso de ningún tipo, comentarios despectivos o publicar información personal de otros. Intentar extraer el código de otro usuario sin su permiso se considera trampa. Cualquier violación a estas reglas dará lugar a disposiciones de penalización, incluyendo descalificación al Rank General o a los programas de Coder del Mes o desactivación de la cuenta. "},"title":"Código de Conducta en omegaUp"},"/posts/como-contribuir-correr-y-editar-omegaup-en-tu-maquina-local/":{"data":{"":"omegaUp es un proyecto open source. Todo el código que se usa para correr el sitio se encuentra en github. Inclusive pueden ver los últimos cambios aquí. En este post vamos a hablar de cómo configurar tu máquina para correr localmente omegaUp y poder contribuir.\n**Instrucciones de instalación de omegaUp: **https://github.com/omegaup/omegaup/wiki/C%C3%B3mo-empezar-a-desarrollar\nEn omegaUp usamos github para administrar todo el código que corre el sitio. En caso de que no estés familiarizado con git, la ayuda de github y el git book son excelentes lugares para empezar.\nLas instrucciones básicas para hacer funcionar todo el código de omegaUp localmente se encuentran en el Wiki de nuestro repo.\nPara facilitar la instalación de todas las librerías, aplicaciones y servicios requeridos para hacer funcionar omegaUp usamos una máquina virtual. Vagrant nos ayuda a configurar la máquina virtual de forma simple. Literalmente esto es equivalente a instalar omegaUp con un sólo comando y tiene la ventaja de que, al ser todo instalado sobre la máquina virtual, no interfiere con la configuración de tu computadora.\nHappy coding!"},"title":"Cómo contribuir: correr y editar omegaUp en tu máquina local"},"/posts/conacup-2012-todo-un-exito/":{"data":{"":"Los días 3 y 4 de Noviembre del 2012, 80 de los mejores programadores de México se dieron cita en el ITESO de Guadalajara, Jalisco para participar en el 2do Concurso Nacional Abierto de Programación CONACUP, organizado por la Sociedad Latinoamericana de Ciencia y Tecnología SOLACyT.\nEl equipo organizador del CONACUP 2012El equipo organizador del CONACUP 2012\nNos da mucho gusto que Omegaup fue la plataforma oficial para la evaluación de los problemas y estamos completamente comprometidos con el proyecto para los años venideros.\nCONACUP 2012 CONACUP 2012 Foto Oficial\nEl CONACUP 2012 fue sin duda, una competencia bastante emocionante. Los 5 primeros lugares fueron:\nMiguel Ángel Covarrubias (macs) Itzel Carolina Delgadillo Ulises Mendez Martínez Juan Antonio Ruiz Leal Hugo Dueñas Scoreboard Final CONACUP 2012Scoreboard Final CONACUP 2012\n¡Muchas felicidades a todos los participantes! Esperamos verlos el próximo año. Mientras tanto, estamos trabajando para publicar las redacciones finales en Omegaup, esperen noticias."},"title":"CONACUP 2012 - Todo un éxito"},"/posts/concursos-con-subtareas/":{"data":{"antecedentes#Antecedentes":"","cómo-crear-un-concurso-con-la-modalidad-de-subtareas#¿Cómo crear un concurso con la modalidad de subtareas?":"Nos es grato informar que hemos liberado una nueva modalidad de concursos llamada “Concursos con subtareas”, para poder cubrir satisfactoriamente las necesidades de los concursos realizados en la Olimpiada Internacional de Informática (IOI por su siglas en inglés), el cual ha modificado la fórmula para calcular el puntaje asignado a un concursante para un problema en específico.\nAntecedentesAnteriormente en omegaUp sólo se contaba con dos distintos tipos de concursos:\nCalificación parcial: En este modo de concursos se tomaba en cuenta el mayor puntaje de la suma de todos los grupos de casos. El modo era utilizado para los concursos de la OMI, entre otros.\nCalificación todo o nada: En este modo de concursos el participante tenía que obtener el 100% de los casos correctos para que se contaran en su puntaje, de otra forma el marcador para dicho problema sería 0 sin importar si tenía respuestas parcialmente correctas. Para los concursos del ICPC era para los que se utilizaba este modo de concursos.\nCon este nuevo modo de concursos podremos cubrir una mayor parte de concursos desde la plataforma de omegaUp, lo cual puede ayudar a escuelas, organizaciones a realizar estos concursos con la seguridad de que se pueden calcular los puntajes correctamente.\nDefinición del nuevo método de evaluaciónAl dar de alta un problema, este ya cuenta con una división de subtareas (o grupos de casos) y a cada subtarea se le asigna un porcentaje de puntaje, de tal forma que la suma de todas las subtareas nos da un 100%.\nLa definición de este nuevo método de evaluación es la siguiente:\n“El puntaje final para cada subtarea será el máximo puntaje de esta subtarea a lo largo de todos los envíos. El puntaje para cada tarea será la suma de los puntajes para sus subtareas. (Por ejemplo, considere a un concursante que hizo 2 envíos en una tarea que contiene 2 subtareas. En la primera solución enviada obtuvo 30 puntos para la primera subtarea y 10 puntos para la segunda subtarea, en la segunda solución obtuvo 0 puntos para la primera subtarea y 40 puntos para la segunda subtarea. Entonces el puntaje final para esta tarea será 70)”\nPara representar gráficamente el ejemplo anterior, véase la la siguiente imagen:\nImage 1Image 1\nPara el método de concursos parcial, el puntaje del problema sería 40, debido a que es el mayor puntaje por envío obtenido.\nTomando en cuenta el nuevo método, donde se tienen que sumar los puntajes mayores por cada subtarea, el puntaje total sería 70, debido a que para la subtarea (caso) 1 se obtendría 30 y para la subtarea (caso) 2 se obtendría 40.\n¿Cómo crear un concurso con la modalidad de subtareas?La forma de crear un concurso con la modalidad de subtareas se realiza de la misma forma que ya se crean los concursos al día de hoy. Sólo existe un campo nuevo en el formulario llamado “Modo de puntaje” donde se tiene que elegir la opción de “Máximo por grupo”:\nImage 2Image 2\nEn la vista de Arena, no hay cambios de interfaz considerables. Los elementos continúan siendo los mismos. En el caso de la lista de envíos seguirá mostrando los mismos veredictos.\nLo único que cambia es el modo en el que se calcula el ranking, tanto en la tabla de mini-ranking:\nImage 3Image 3\nComo en el scoreboard:\nImage 4Image 4\nY en el navegador de problemas:\nImage 5Image 5\nAtentamente, el equipo de omegaUp.","definición-del-nuevo-método-de-evaluación#Definición del nuevo método de evaluación":""},"title":"Concursos con Subtareas"},"/posts/concursos-en-modo-virtual/":{"data":{"":"Estimados usuarios de omegaUp\nEstamos muy felices de anunciar que hemos implementado una nueva funcionalidad de concursos en modo virtual en omegaUp :)\n¿Qué es un concurso en modo virtual?\nConcursos en modo virtual te permite reproducir un concurso pasado en un modo especial que imita el concurso real como sucedió. Con el scoreboard reproduciéndose en sincronía con el concurso original.\nEstos son los pasos a seguir para crear y participar en un concurso en modo virtual:\nCrear concurso virtual. Crear el concurso virtual es muy simple! Solo tienes que ir a la sección de concursos en arena, buscar el concurso que te interesa y hacer click en el botón de modo virtual. Pon un tiempo y hora de inicio para tu concurso virtual. Entra a tu concurso virtual. Simplemente haz click en comenzar concurso. También puedes invitar a tus amigos o rivales a tu concurso en modo virtual"},"title":"Concursos en Modo Virtual"},"/posts/concursos-por-equipos/":{"data":{"1--creación-de-grupo-de-equipos#1.- Creación de grupo de equipos":"","2--carga-de-equipos#2.- Carga de equipos":"","21--carga-de-equipos-con-identidades-auto-generadas#2.1.- Carga de equipos con identidades auto-generadas":"","3--creación-de-concurso-por-equipos#3.- Creación de concurso por equipos":"","31--ingreso-como-equipo-con-cuenta-previamente-existente#3.1.- Ingreso como equipo con cuenta previamente existente":"","32--ingreso-como-equipo-con-cuenta-auto-generada#3.2.- Ingreso como equipo con cuenta auto-generada":"","4--envío-de-soluciones-a-problemas-de-concurso-por-equipos#4.- Envío de soluciones a problemas de concurso por equipos":"Nos es grato informar que hemos liberado una nueva funcionalidad llamada “Concursos por equipos”, para poder atender los concursos con formato de ICPC, los cuales se realizan en equipos. Para que esta nueva modalidad de concursos pueda utilizarse, también se han liberado algunas características extras que se describirán más adelante.\nSi estás familiarizado con la plataforma encontrarás similitud con funcionalidades que ya existen desde hace tiempo. Si no es el caso, comenzamos con el primer paso.\n1.- Creación de grupo de equiposPara tener un mejor control de los equipos que van a participar en un concurso con la modalidad de equipos, es necesario crear un grupo de equipos, el cual es muy similar a los grupos que se utilizan al día de hoy, sólo que en este caso existen algunas variantes, ya que en lugar de identidades se agregarán equipos que contienen usuarios y/o identidades.\nPara crear el grupo es necesario ir al menú superior derecho y elegir la opción de Mis grupos de equipos. Aquí se mostrará el listado de grupos de equipos que hayas creado, con la opción de editarlos. En caso de ser la primera vez que ingresas, sólo te aparecerá el botón de Crear nuevo grupo de equipos.\nEn esta pantalla encontrarás un formulario donde tendrás que ingresar el nombre del grupo, una breve descripción que indique el propósito del mismo y el número límite de integrantes permitidos por equipo. El alias no es necesario escribirlo ya que se autogenera de acuerdo al nombre que indiques. En caso de que el alias ya sea utilizado en otro grupo de equipos, habrá necesidad de elegir un nombre distinto para que se regenere el alias, así hasta encontrar uno disponible.\nEn la siguiente animación se muestra lo mencionado anteriormente:\n2.- Carga de equiposUna vez que guardas el grupo, te aparecerá la vista de edición, y se seleccionará la pestaña de cargar equipos. Este paso es similar a la carga de identidades de un grupo, en este post puedes ver la manera de cargar el archivo. La diferencia con ese proceso es que estas identidades son para equipos, quiere decir que dentro de cada identidad se podrán asociar tantos miembros como se hayan configurado en el formulario de Crear grupo de equipos. Estos miembros se pueden cargar en el archivo .csv, en caso de que conozcas los nombres de usuarios (usernames) de cada miembro o lo puedes hacer posteriormente en la pestaña de equipos donde podrás agregarlos manualmente a cada equipo.\nLa regla principal en la creación de equipos es que un usuario no puede pertenecer a dos equipos distintos del mismo grupo de equipos. Así que si por equivocación se llegara a intentar realizar esta acción, la plataforma mandaría un mensaje de error.\nCabe destacar que la carga de identidades y equipos está en una etapa experimental que aún no se abre en su totalidad al público en general hasta probar que se le está dando un uso adecuado, así que si estás interesado en crear grupos de equipos, nos puedes escribir a engineering@omegaup.com para que te podamos habilitar los privilegios necesarios.\nEn la siguiente animación se muestra el proceso de lo antes descrito:\n2.1.- Carga de equipos con identidades auto-generadas Habrá ocasiones en que se requiera organizar un concurso con una gran cantidad de equipos, lo cual hará más complicada la carga de los miembros de cada equipo debido a que este número pudiera llegar a ser demasiado grande.\nPara esta situación se considera una opción de generar las identidades para cada equipo una vez que se carga el archivo .csv. Esto quiere decir que sólo será necesario cargar el archivo sin incluir nombres de usuarios, y en su lugar habrá que seleccionar la casilla de Autogenerar identidades que se encuentra en el formulario. Para este caso en particular es de suma importancia descargar el archivo con las identidades que se generaron antes de guardar los cambios, ya que aquí se van a mostrar el listado de usernames junto a su contraseña, la cual sólo se podrá visualizar en este punto, ya que al guardar los cambios estas contraseñas de van a encriptar. Lo cual ocasionará que ya no sea posible volverlas a ver en la plataforma.\nEn la siguiente animación se muestra el proceso antes mencionado:\n3.- Creación de concurso por equiposUna vez que ya hayas creado los grupos de equipo, es momento de generar el concurso por equipos. En este caso, el formulario es exactamente el mismo que se utiliza para cualquier tipo de concurso, sólo que ahora se agregó un nuevo campo en el formulario llamado Concurso por equipos y aparece como una casilla de tipo checkbox. Al momento de activar dicha casilla también se habilita un campo de texto donde tendrás que buscar el grupo de equipos, ya sea por nombre o por alias. En caso de tener activa la casilla, pero no hayas escrito el nombre del grupo, obtendrás un error indicando que este campo es obligatorio.\nYa que se haya creado el concurso, te aparecerá la vista de Editar concurso, y a diferencia de los concursos normales, en este tipo de concurso verás en las opciones una sección de Agregar grupo, en lugar de la opción de Agregar concursante, debido a lo explicado al inicio de este post. También se oculta la opción de Modo de acceso, esto con la finalidad de evitar que se creen concursos para equipos públicos (sólo por el momento, en un futuro se evaluará si se abre esta opción).\nEn la sección de Agregar grupo podrás reemplazar al equipo, siempre y cuando ninguno de los equipos haya realizado al menos un envío de alguno de los problemas.\nEn la siguiente animación se muestra todo lo que se comentó previamente:\n3.1.- Ingreso como equipo con cuenta previamente existente Una vez que ya se creó el grupo de equipos y el concurso por equipos. Es momento de notificar a los usuarios que fueron inscritos al concurso por medio de un equipo, para que puedan acceder al concurso.\nCabe destacar que estos usuarios ya contarán con una identidad de equipo, la cual se muestra en el menú superior derecho. La forma de distinguir una identidad de una identidad de equipo es por la nomenclatura del nombre de usuario (username). La nomenclatura de una identidad de grupo es la siguiente:\n[group_name]:[identity_name ].\nEn tanto la nomenclatura de las identidades de un grupo de equipos es la siguiente:\nteams:[group_name]:[identity_name].\nEntonces, para poder visualizar el concurso que fue creado para equipos es necesario hacer un intercambio a la sesión de esta nueva identidad a la que fue asociado el concursante.\nEn la siguiente animación se muestra lo mencionado anteriormente:\n3.2.- Ingreso como equipo con cuenta auto-generada En el caso de las identidades que se crearon mediante la carga de archivo .csv y se eligió la opción de Autogenerar identidades ya no es necesario hacer el cambio de cuenta para poder ver el concurso en el listado. Esto quiere decir que una vez que inicia sesión aparecerá el nombre del equipo en la parte superior derecha, tal como se muestra en la siguiente animación:\n4.- Envío de soluciones a problemas de concurso por equiposPor último, ya que el usuario encontró el concurso por equipos al que fue añadido sólo será necesario que ingrese a dicho concurso y comience a realizar envíos a las soluciones de los problemas. Al ser un concurso por equipos, los integrantes del equipo también podrán acceder de la misma forma y todos podrán realizar envíos simultáneamente. Las reglas del concurso son las mismas que en el resto de concursos, no podrán realizar envíos de un mismo problema hasta que haya transcurrido el tiempo entre cada envío con el que fue configurado el concurso (60 segundos por defecto).\nEn la animación se muestra un ejemplo de lo antes mencionado:\nAtentamente, el equipo de omegaUp."},"title":"Concursos por equipos"},"/posts/concursos-recomendados/":{"data":{"":"Respondiendo a los comentarios que hemos recibido sobre la organización de la lista de concursos en la Arena, hemos implementado el concepto de Concursos Recomendados:\nA partir de ahora tendremos una lista separada para los Concursos Recomendados actuales y pasados. Para pedir que tu concurso sea marcado como recomendado escribe un email a omegaup-soporte@googlegroups.com.\nLos únicos requerimientos son:\nQue el concurso sea formalmente establecido (sea parte de una olimpiada, concurso de ACM u algún otro concurso de programación). Que el creador del concurso se comprometa a mantenerlo en buen estado respondiendo las clarificaciones que pueda. Idealmente los Concursos Recomendados deben tener problemas nuevos aunque no es estrictamente necesario. El tamaño del concurso no importa. Concursos privados que cumplan estos requerimientos y que se planean hacer públicos posteriormente también cuentan. Esperamos sus comentarios."},"title":"Concursos recomendados"},"/posts/concursos-virtuales/":{"data":{"":"¿Te gustaría revivir un concurso de programación que ya pasó? ¿Te gustaría ver cómo se mueve la tabla de posiciones en tiempo real mientras vas subiendo tus soluciones? ¿Te gustaría saber cómo te “hubiera ido” en “aquél concurso” al que no pudiste ir?\n¡El futuro es hoy! Todo esto ya es posible en omegaUp gracias a la nueva funcionalidad de “concursos virtuales”.\nPara activar esta nueva funcionalidad simplemente elige un concurso en la arena y selecciona “Concurso virtual”, el concurso empezará y la lista de posiciones se irá actualizando conforme los participantes del concurso fueron subiendo sus soluciones, así podrás saber cómo te va con respecto a los competidores que participaron en el concurso.\nKudos a Vincent, estudiante de Japón, por implementar esta nueva funcionalidad el verano pasado como parte de su internship en Google Summer of Code.\n¡Gracias a Google por el apoyo para llevar este proyecto a cabo a través de Google Summer of Code! Esperamos poder ser parte de este programa en el futuro.\nAquí les dejamos unos concursos interesantes:\n- OPI 2017 https://omegaup.com/arena/CPIO2017-virtual-uJq/virtual\n- OMI 2017 (día 1) https://omegaup.com/arena/OMI2017DIA1PUBLICO/virtual\n- OMI para Secundarias 2018 https://omegaup.com/arena/OMIS2018PUBLICO/virtual\n- OMI para Primarias 2018 https://omegaup.com/arena/OMIP2018PUBLICO/virtual\nParticipa en esta y más conversaciones en nuestro blog: https://blog.omegaup.com/concursos-en-modo-virtual/"},"title":"Concursos Virtuales"},"/posts/cupa-2012-resultados/":{"data":{"":"El pasado 20 de Octubre se llevó a cabo el Concurso Universitario de Programación de Aguascalientes CUPA. Participaron 26 equipos de 3 personas en un examen de 9 problemas. Los problemsetters oficiales fueron la Dra. Aurora Torres (Plano Estropeado), David Esparza Alba (Traductor, Display Descompuesto, Puntos imantados, Primos juntos siempre y Santas bombillas ) y Óscar Dávalos (Cadenas de Potencias de 2, Múltiplos y Cubos.). Omegaup fue la plataforma de evaluación del CUPA.\nParticipantes del CUPA 2012 Participantes del CUPA 2012\nLos 3 primeros lugares fueron:\nEquipo: Radical, Universidad Autónoma de Aguascalientes: Juan Antonio Ruiz Leal Francisco Javier Alarcón Esparza Flavio Hernández González Equipo **MEI, ** Universidad Panamericana campus Bonaterra: José Maximiliano Ruíz Macías Fernando Ignacio Arreola Gutiérrez Eric Valdivia Lozano Equipo **aguascalientitos, **Olimpiada Mexicana de Informática en Aguacalientes Itzel Carolina Delgadillo Pérez Quetzali Ramírez Guillén Andrea Acevedo Mejía ¡Muchas felicidades a todos los participantes! Esperamos volverlos a apoyar el próximo año. Mientras tanto, el problemset oficial ya se encuentra abierto en modo práctica en Omegaup aquí."},"title":"CUPA 2012 - Resultados"},"/posts/el-camino-de-mexico-rumbo-a-la-ioi-2015/":{"data":{"etapa-1#\u003cstrong\u003eEtapa 1\u003c/strong\u003e":"","etapa-2#\u003cstrong\u003eEtapa 2\u003c/strong\u003e":"","material-de-estudio#Material de Estudio":"","selectivo-final#Selectivo Final":"Un año más ha pasado y México ya tiene lista su delegación que nos representará en la International Olympiad in Informatics 2015 a celebrarse en Kazakhstan, del 26 de Julio al 2 de Agosto. A continuación presentamos la colección de exámenes y problemas que se usaron durante el preselectivo dentro de omegaUp. Esperamos que esta colección de problemas sirva de entrenamiento a futuras delegaciones de México y otros países de América Latina.\nDe izquierda a derecha, los integrantes de la Selección Mexicana de Informática 2015 son:\n**MEX-4: Emmanuel Antonio Cuevas **(Emmanuel_Antonio) **MEX-2: Carlos Galeana Hernández **(charlyhlms) MEX-1: Juan Carlos Sigler Priego (Juan_Carlos_Sigler_Priego) **MEX-3: Ángel David Ortega Ramírez **(blak_dragon1) Material de EstudioEn nuestro post anterior, El camino rumbo a la IOI 2014 hay una buena colección de materiales que sugerimos a los olímpicos leer mientras avanzan por las diferentes etapas del preselectivo.\nEtapa 1Durante esta etapa le pedimos a los olímpicos que lean el libro de Problemas y Algoritmos de Luis Vargas como mínimo como guía para resolver los problemas.\nTemas básicos: variables, cadenas, arreglos, matrices, ciclos, mcm, mcd, etc.. IOI 2015 Etapa 1, Problemset 1 IOI 2015 Etapa 1, Problemset 2 Pilas, colas y búsqueda binaria IOI 2015 Etapa 1, Problemset 3 IOI 2015 Etapa 1, Problemset 4 Examen 1 Búsqueda, árboles, acotamiento y poda IOI 2015 Etapa 1, Problemset 5 IOI 2015 Etapa 1, Problemset 6 Recursión y backtracking IOI 2015 Etapa 1, Problemset 7 IOI 2015 Etapa 1, Problemset 8 Examen 2 Búsquedas con espacios de estados IOI 2015 Etapa 1, Problemset 9 IOI 2015 Etapa 1, Problemset 10 Programación Dinámica IOI 2015 Etapa 1, Problemset 11 IOI 2015 Etapa 1, Problemset 12 IOI 2015 Etapa 1, Problemset 13 Examen 3 Divide y vencerás IOI 2015 Etapa 1, Problemset 14 IOI 2015 Etapa 1, Problemset 15 Grafos IOI 2015 Etapa 1, Problemset 16 IOI 2015 Etapa 1, Problemset 17 Examen 4 Etapa 2 IOI 2015 Etapa 2, Examen 1 IOI 2015 Etapa 2, Examen 2 IOI 2015 Etapa 2, Examen 3 IOI 2015 Etapa 2, Examen 4 IOI 2015 Etapa 2, Examen 5 Selectivo Final IOI 2015 Selectivo Final, Examen 1 IOI 2015 Selectivo Final, Examen 2 IOI 2015 Selectivo Final, Examen 3 IOI 2015 Selectivo Final, Examen 4 IOI 2015 Selectivo Final, Examen 5 "},"title":"El camino de México rumbo a la IOI 2015"},"/posts/el-camino-rumbo-a-la-ioi-2014/":{"data":{"":"Después de varios meses de preparación y selección, México está listo para participar en la IOI 2014 a celebrarse en Taiwán del 13 al 20 de Julio.\nSelección Mexicana de Informática 2014 De izquierda a derecha, nuestros seleccionados son:\nCarlos Galeana Hernández del Distrito Federal Daniel Talamás Cano de Coahuila Diego Alonso Roque Montoya de Nuevo León Jordán Alexander Salas de Coahuila Nuevamente, nuestra selección cuenta con 3 ganadores absolutos de la Olimpiada Mexicana de Informática: Jordán ganó la OMI 2014, Talamás ganó la OMI 2013 y Diego Roque ganó la OMI 2012. Les deseamos la mejor de las suertes!\nTodos los concursos de selección y la gran mayoría de las prácticas usadas durante el proceso están disponibles en omegaUp. Estos fueron los concursos y problemas usados:\nEtapa 1 Durante esta etapa le pedimos a los olímpicos que lean el libro de Problemas y Algoritmos de Luis Vargas como mínimo como guía para resolver los problemas.\nTemas introductorios: variables, cadenas, arreglos, matrices, ciclos, mcd, mcm:\nIOI 2014 Etapa 1, Problemset 1 IOI 2014 Etapa 1, Problemset 2 Soluciones Lecturas recomendadas: Los temas 1, 2, 4 y 5 del blog de Pier Paolo. Sección VII del Libro de Luis sobre Algoritmos Sección II del Libro de Luis sobre Algoritmos Mathematics for TopCoders. Pilas, colas y búsqueda binaria\nIOI 2014 Etapa 1, Problemset 3 (nivel introductorio) IOI 2014 Etapa 1, Problemset 4 (nivel retador) Lecturas recomendadas: Del libro de Luis sobre Problemas y Algoritmos, los capítulos 4, 10, 13 y la Sección 2 completa serán de utilidad para estos exámenes. Del Blog de Pier Paolo, las secciones 2 y 3 pueden ser de utilidad. El tutorial de Topcoder sobre Búsqueda Binaria. Pueden practicar también con los problemas de los mismos temas del año pasado en omegaUp: Problemset 1 y Problemset 3. Búsquedas, árboles y acotamiento y poda\nIOI 2014 Etapa 1, Problemset 5 (nivel introductorio) IOI 2014 Etapa 1, Problemset 6 (nivel retador) Soluciones y más soluciones Lecturas recomendadas: Del libro de Problemas y Algoritmos de Luis Vargas, la secciones 2 y 7 enteras y los capítulos 5, 14, 15 pueden ser de utilidad. Del blog de Pier Paolo pueden encontrar información relevante en las secciones 9 y 11. Repasen también los conceptos de búsqueda en amplitud y búsqueda en profundidad. Pueden practicar con los Exámenes 4 y 5 de la Etapa 1 del año pasado: Las soluciones de algunos de esos problemas las pueden encontrar aquí y aquí. Recursión y backtracking\nIOI 2014 Etapa 1, Problemset 7 (nivel introductorio) IOI 2014 Etapa 1, Problemset 8 (nivel retador) Soluciones Lecturas recomendadas: Sección I completa del libro de Algoritmos de Luis Vargas (capítulos del 1 al 5) más el capítulo 11. Sección 9 completa del blog de Pier Paolo sobre algoritmos Los exámenes 6 y 7 de la preselección del 2013. Algunas soluciones a esos problemas se encuentran en el blog. An Introduction to Recursion, part 1 \u0026 part 2. Búsquedas con espacios de estados\nIOI 2014 Etapa 1, Problemset 9 (nivel introductorio) IOI 2014 Etapa 1, Problemset 10 (nivel retador) Lecturas recomendadas: Capítulo 19: Estructura de la Solución y Espacio de Búsqueda, del libro de Problemas y Algoritmos de Luis Vargas. También les recomendamos revisar y practicar con el problemset 8 del año anterior. Algunas soluciones a ese problemset están en el blog. Divide y vencerás\nIOI 2014 Etapa 1, Problemset 11 (nivel introductorio) IOI 2014 Etapa 1, Problemset 12 (nivel retador) Lecturas recomendadas: Capítulo 4 del libro de Problemas y Algoritmos. Programación dinámica\nIOI 2014 Etapa 1, Problemset 13 (nivel introductorio) IOI 2014 Etapa 1, Problemset 14 (nivel medio) IOI 2014 Etapa 1, Problemset 15 (nivel retador) Soluciones Lecturas recomendadas: Sección VI del libro de Problemas y Algoritmos. Tutorial de Topcoder: Dynamic Programming. Programación Dinámica en el blog de Pier Paolo. Teoría de Grafos\nIOI 2014 Etapa 1, Problemset 16 (nivel introductorio) IOI 2014 Etapa 1, Problemset 17 (nivel retador) Lecturas recomendadas: Grafos en el blog de Pier Paolo. Tutorial en Topcoder: Introduction to graphs and their data structures. **Etapa 2 **\nEsta etapa consistió de entrenamientos presenciales y prácticas externas.\nEtapa 3\nIOI 2014 Etapa 3 Examen 1 IOI 2014 Etapa 3 Examen 2 IOI 2014 Etapa 3 Examen 3 IOI 2014 Etapa 3 Examen 4 IOI 2014 Etapa 3 Examen 5 Selectivo final\nIOI 2014 Etapa 4 Examen 1 IOI 2014 Etapa 4 Examen 2 IOI 2014 Etapa 4 Examen 3 IOI 2014 Etapa 4 Examen 4 IOI 2014 Etapa 4 Examen 5 IOI 2014 Etapa 4 Desempate Material de lectura\nComo parte del proceso, recomendamos a nuestros olímpicos revisar a profundidad los siguientes sitios con material de estudio y problemas para practicar:\nTemario oficial para la IOI. El libro en español de Luis Vargas sobre Problemas y Algoritmos. Básicamente el objetivo de la Etapa 1 es que dominen los contenidos de este libro, por lo que su lectura (y práctica) es casi obligatoria. Les recomendamos no esperar a que inicie el preselectivo para empezar a leerlo. Libros recomendados para la IOI, a estas alturas su lectura es casi obligadasi desean llegar y tener buenos resultados en la IOI: Introduction to Algorithms 3rd Edition, Cormen et. al. Competitive Programming 1, 2 y 3, Steven \u0026 Felix Halim. La versión electrónica del Libro 1 ya es gratis. Otro libro introductorio: Algorithms Unlocked de Cormen. Más prosa y menos profundidad en las demostraciones que el Introduction al Algoritmos. Recomendado para quienes están en su primer año de concursos. omegaUp :) El blog de Pier Paolo, sección Algoritmos: http://pier.guillen.com.mx/ El blog de Rodrigo Burgos: http://algorithmmx.blogspot.com/ Topcoder Contenido educacional (altamente recomendado!) Preguntas omegaUp - Cualquier duda técnica que tengan, la pueden publica en nuestro sitio de preguntas. También pueden leer nuestras respuestas a preguntas pasadas. Guía rápida para el ACM ICPC. Muy buena para repasar pero no todos los temas aplican para la IOI, chequen el temario primero. Otros sitios para practicar\nCroatian Open Competition in Informatics (COCI). Varios meses antes de la IOI, el comité de la Olimpiada de Croacia hace exámenes en línea. Los exámenes son de muy buen nivel y todos los problemas con sus soluciones están publicados en la misma página, les recomendamos darles un vistazo y practicar con todos ellos. Noten que los problemas de la COCI están en inglés y no son traducidos al español, por lo que es bueno que estén preparados. Afortunadamente Google Translate típicamente hace un buen trabajo con estos enunciados. USA Computing Olympiad (USACO) Estos problemas sí son traducidos al español. Otro detalle importante sobre la USACO/COCI es que sus futuros competidores en la IOI también participan en estos concursos, por lo que les servirá para medir su nivel. USACO Training Gate. Plataforma paso-a-paso para entrenar con problemas para la IOI. Incluye muy buenas explicaciones de la construcción de soluciones a varios problemas y tutoriales. Este blog tiene varias soluciones para el USACO training gate. Úsenlas sólo cuando estén completamente atorados en un problema, después de haberlo intentado. Topcoder.com/tc Codeforces: http://codeforces.com/ ACM UVa Online Judge Codechef: http://www.codechef.com/ Esperamos que esta información le sirva a las próximas generaciones que participarán por un lugar en la Selección Mexicana de Informática."},"title":"El camino rumbo a la IOI 2014"},"/posts/el-nuevo-buscador-de-problemas-de-omegaup/":{"data":{"":"","#":"Usuarios de omegaUp:\nHemos creado un Asistente de búsqueda de problemas. Aprovechando las etiquetas y puntuaciones de calidad y de dificultad que ustedes han venido otorgándole a los problemas de la plataforma, hemos implementado este nuevo buscador que permite filtrar los problemas que les interesen en base a diversos temas y la dificultad que éstos deberían poseer.\nEl Asistente de búsqueda de problemas es una alternativa más fácil de usar para usuarios iniciantes de omegaUp y permite que todos puedan mejorar sus habilidades de programación en tópicos específicos.\n¿Cómo funciona el asistente de búsqueda? Un breve ejemplo\nUsarlo es súper fácil, simplemente debes acceder a la pestaña de Problemas y, debajo de los campos de búsqueda, se encuentra un enlace que dice “Probar el nuevo buscador de problemas”, al hacer click en dicho enlace, se abrirá el nuevo buscador, a partir de ahí el proceso es muy simple:\nEscoger los temas y lenguaje de interés: puedes filtrar problemas que puedan ser resueltos únicamente con Karel o con varios lenguajes, además, al escribir en el campo de Tags, serán listados los temas que coincidan con lo que estás buscando, ¡puedes escoger más de uno solo! Recuerda que si escoges múltiples temas, serán listados los problemas que contengan AL MENOS uno de ellos. Cuando finalices tu selección, clickea en Siguiente. Escoger el rango de dificultad: los problemas de omegaUp pueden ser calificados desde Muy Fáciles hasta Muy Difíciles, en esta opción tú podrás seleccionar las posibles dificultades que tendrán los problemas que estás buscando. Si deseas escoger problemas que sean únicamente de un tipo de dificultad, puedes poner los selectores de inicio y fin de rango, en el mismo lugar. Una vez seleccionado el rango, debes clickear en Siguiente. Escoger la prioridad: en este paso deberás escoger el orden respecto al cual deberán ser listados los problemas, puedes escoger entre Calidad (la puntuación de calidad), Puntos para ranking (los puntos que otorga al ser resuelto) y Popularidad (cuántas veces se ha intentado resolver). Cuando hayas definido tu prioridad, clickea en Confirmar. Voilà! Los problemas que se ajustan a tus criterios de búsqueda aparecerán en la lista y podrás empezar a resolverlos y mejorar tus habilidades de programador!\nEsperamos que esta nueva implementación te sea muy útil, si tienes alguna duda o consulta puedes contactarnos en los comentarios."},"title":"El Nuevo Buscador de Problemas de omegaUp"},"/posts/el-nuevo-ranking-de-escuelas-de-omegaup/":{"data":{"":" Rankings de escuelas\nQueremos presentarles el nuevo ranking de escuelas de omegaUp, tanto mensual como histórico. Cada uno de ellos funciona de manera similar, salvo por algunas variaciones que detallaremos a continuación:\nEl score de una escuela para el ranking mensual, se obtiene a partir de la suma de los puntos que provee cada problema que los usuarios de la escuela han resuelto dentro del mes actual. Contamos los puntos de cada problema una única vez, por lo que si 10 usuarios de una misma escuela, resolvieron el mismo problema que otorgaba 0.5 puntos, la contribución de éstos es 0.5 y no 5 (0.5*10).\nEl score de una escuela para el ranking histórico es calculado de la misma manera que el rank mensual, con el diferencial de que el score se calcula a partir de todos los problemas que se resolvieron desde que la escuela fue creada. Recuerda que un problema se cuenta como resuelto por una escuela, siempre que un usuario asociado a la misma, lo haya resuelto. Si dicho usuario, luego modifica su escuela actual en su perfil, dicho problema y el puntaje que éste aportaba al score de su escuela anterior, no se mueven a la nueva, puesto que a la fecha en que resolvió dicho problema, el usuario aún no pertenecía su nueva escuela.\nAsí que si lo que un coder desea es que su escuela mejore su score en el ranking de omegaUp, debe priorizar que los alumnos de la misma resuelvan la mayor cantidad de problemas distintos en la plataforma, pues el hecho de que varios resuelvan el mismo problema, aportaría lo mismo a que uno solo lo haga.\nAtentamente,\nEl equipo de omegaUp"},"title":"El nuevo ranking de escuelas de omegaUp"},"/posts/el-nuevo-ranking-de-omegaup/":{"data":{"":"Con este commit hemos introducido un cambio significativo en la forma de calcular el ranking general de omegaUp. Ahora no sólo es importante cuántos problemas ha resuelto un usuario sino que también estamos incluyendo la dificultad de cada uno de esos problemas. La dificultad es inversamente proporcional a la cantidad de soluciones completas (AC) que tiene ese problema.\nPara ser más precisos, estamos definiendo los puntos que da un problema así: $latex P_i = \\frac{100}{log_2(N+1)}$,\ndonde $latex N$ representa la cantidad de ACs que tiene un problema.\nEntre más ACs tenga un problema, menos puntos va a valer. Sólo estamos contando a lo más 1 AC por usuario para evitar que las soluciones de una misma persona afecten artificialmente los puntos de score del problema.\nScreen Shot 2014-06-12 at 7.44.06 AM El score que usamos en el ranking esta dado por la suma de los puntos de todos los problemas que un usuario ha resuelto con AC.\nScoreboard del 6-12 Este nuevo sistema implica que los scores ahora son dinámicos: con cada problema que un usuario resuelva se va a afectar el score de otras personas que ya hayan resuelto el mismo problema anteriormente. La única manera de subir el score es resolviendo más problemas ya que, con el tiempo, el valor que otorga cada problema va a decaer.\nTambién agregamos una columna en la lista de problemas disponibles, Puntos para ranking, que ayuda a los usuarios a saber qué problemas atacar y cuánto valen en este nuevo sistema. Es importante notar que el valor que se muestra es el actual: en el momento que resuelvas un problema, los puntos que otorga van a cambiar.\nScreen Shot 2014-06-12 at 7.36.05 AM Qué te parece el nuevo sistema? Subiste o bajaste en el ranking? Déjanos tus dudas y sugerencias en los comentarios."},"title":"El nuevo ranking de omegaUp"},"/posts/engranes-khayyam-solucion-enrique-lira/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 1** Autor: **Omar Ocegueda (Khayyam) **Solución por: **Enrique Lira\nPara poder resolver este problema hay que ver ciertas propiedades a las cuales podemos llegar fácilmente a partir de ejemplos. Una primera duda que nos surge es: ¿Vuelve al estado inicial?, si hacemos un par de ejemplos podemos ver que si, otra duda que nos surge es: ¿Cuándo vuelve al estado inicial?, y aquí comienza lo complicado. Para saber cuando vuelve a su estado inicial hay que notar ciertas cosas, una de ellas es que en cuanto el diente 1 vuelve a tocar al valle 1 hemos vuelto al estado inicial, no hay forma de que el diente 0 toque al valle 0 sin haber vuelto al estado inicial, entonces hay que buscar ese instante.\nConsideremos ra y rb como el número de vueltas que ha dado el engrane a y el engrane b respectivamente en un momento dado después de x pasos, hay que notar que si ra y rb son enteros significa que hemos vuelto al estado inicial o estamos en el estado inicial (ra igual a cero y rb igual a cero).\nPara que tanto ra y rb sean enteros, es necesario que x sea divisible tanto por N como por M y hay que encontrar el numero más pequeño distinto de cero (cero es el momento inicial) en el que esto pasa. Para nuestra fortuna esto es fácilmente calculable y es algo que nos enseñan en la escuela, se llama mínimo común múltiplo.\n$latex mcm(N,M) = \\frac{N * M}{MCD(N, M)}\u0026s=2$\nYa que sabemos después de cuantos pasos se repite (llamémoslos K), debemos notar que en esos K pasos ningún par (diente, valle) se va a repetir, dado que si se repite significaría que K no es el primer momento en el que se vuelve al estado inicial.\nSabiendo esto podemos saber cuantos dientes distintos pasan por cada valle, siendo K la cantidad de parejas (diente, valle) distintas que existen (no sé pueden generar más), se puede deducir que K / M es la cantidad de dientes distintos que pasan por cada valle, simplificando nos queda:\n$latex \\frac{N}{MCD(N, M)}\u0026s=2$\nAhora hay que buscar una forma de saber el primer diente que pasa por un valle x, con un poco de observación podemos saber que el numero del primer diente en tocar al valle x esta dado por el residuo de la división x sobre N ( x mod N ).\nYa que sabemos cual es el primer diente en tocar al valle x, debemos buscar la forma de calcular los otros dientes, con algunos ejemplos podemos notar que el numero del siguiente diente es M mod N veces mayor que el actual.\nEn el peor de los casos, los N dientes pasan por todos los valles, resultando nuestra solución actual con una complejidad de $latex O(LN)$ y funciona bastante bien para los 80 puntos del problema.\nPara llegar a la solución de 100 puntos hay que notar que después de que un diente y se junta en un valle x, el siguiente diente en juntarse con el valle x no depende del valle sino solo del diente, es por esto que si el diente y pasa por un conjunto de valles y uno de ellos no es estable, ninguno de los otros lo será y viceversa si el diente y pasa por un valle x que es estable, todos los demás valles por los que pase serán estables. Sabiendo esto podemos guardarlo en un arreglo que nos diga por cada diente si pasa por valles estables o no, reduciendo la complejidad a $latex O(N)$."},"title":"Solución a \"Engranes\""},"/posts/gsoc2022/":{"data":{"te-interesaría-trabajar-en-un-proyecto-de-ingeniería-de-software-para-omegaup-en-un-programa-patrocinado-por-google-te-invitamos-a-aplicar-a-_google-summer-of-code-2022_httpssummerofcodewithgooglecomprograms2022organizationsomegaup#¿Te interesaría trabajar en un proyecto de Ingeniería de Software para omegaUp en un programa patrocinado por Google? Te invitamos a aplicar a \u003ca href=\"https://summerofcode.withgoogle.com/programs/2022/organizations/omegaup\"\u003e\u003cem\u003eGoogle Summer of Code 2022\u003c/em\u003e\u003c/a\u003e.":"Verano de Programación de Google con omegaUp¿Te interesaría trabajar en un proyecto de Ingeniería de Software para omegaUp en un programa patrocinado por Google? Te invitamos a aplicar a Google Summer of Code 2022. ¿Qué es Google Summer of Code? Google Summer of Code, o GSoC, es un programa anual internacional en el cual Google premia con estipendios económicos a aquellas personas que sean aceptadas en el programa y completen exitosamente un proyecto de contribución a un proyecto de código abierto. Este año omegaUp forma las organizaciones elegibles.\n¿En qué proyectos puedo trabajar? Tenemos una lista de 5 proyectos de la cual podrás escoger.\n¿Hay una remuneración económica? Así es, Google otorga estipendios económicos a aquellas personas que sean aceptadas en el programa y completen exitosamente un proyecto. El monto que se otorgará depende del tamaño del proyecto y del país en el que residas. Para más detalles de los pagos ingresa a página oficial de GSoC.\n¿Cuáles son los requisitos? Cada proyecto de la lista detalla una lista de tecnologías que requiere. Además de eso, es necesario tener habilidad con git e inglés escrito y leído. No es necesario ser estudiante, a partir de este año cualquier persona es elegible.\n¿Cuál es el proceso de aplicación? El proceso consiste de los siguientes pasos:\nResuelve por lo menos 2 problemas de esta prueba. Únete a nuestro canal de discord. Instala el entorno de desarrollo de omegaUp: instrucciones. Resuelve un par de issues de tu elección de la lista. Escribe tu aplicación con una propuesta de solución al proyecto que hayas elegido de la lista de ideas. Manda tu aplicación antes del 18 de abril. Más detalles sobre el proceso de aplicación en nuestro wiki.","verano-de-programación-de-google-con-omegaup#Verano de Programación de Google con omegaUp":""},"title":"Verano de Programación de Google con omegaUp"},"/posts/guia-para-la-propuesta-de-insignias-en-omegaup/":{"data":{"":"Tú también puedes proponer nuevas insignias para la plataforma, simplemente debes tomar en cuenta las consideraciones que se detallan a continuación y abrir un issue en nuestro repositorio en Github haciendo clic aquí.\nConsideraciones:\nLas insignias en omegaUp son una manera de reconocer logros pequeños pero significativos, conseguidos por los usuarios al usar la plataforma. En dicho sentido, no está permitido proponer insignias ad-hoc, cuya posibilidad de ser conseguidas involucre aspectos que van más allá de la habilidad del estudiante o el uso que éste le da a la plataforma. Por ejemplo: Insignia por haber ganado un concurso en Enero Insignia por tener un nombre de usuario menor a 5 caracteres El nombre de una insignia está limitado a 50 caracteres y debe ser pensado como una característica y no como una acción del usuario. Por ejemplo, si lo que se desea proponer es una insignia para un usuario que ha enviado feedback sobre un problema, el nombre de dicha insignia debe ser: “Proveedor de Feedback”, en lugar de “Proveer Feedback” o “Haber provisto de Feedback”. La descripción de una insignia debe responder a la pregunta: ¿Qué debe haber realizado un usuario para recibir esta insignia?, y debe seguir el siguiente formato: “El usuario realizó [inserte la acción que realizó]”. Una insignia puede tener un ícono personalizado proporcionado por la persona que la propone o implementa. Los íconos personalizados tienen ciertas restricciones, que son: Debe ser un archivo .svg Las dimensiones del ícono son 600x600 píxeles. El archivo debe tener un peso máximo de 15kB. El ícono debe mantener siempre la forma de la insignia por defecto, lo único que puede ser ajustado son los colores y el relleno de la misma. Por lo tanto, en caso de ser requerido, el ícono personalizado puede ser creado a partir de una modificación del ícono por defecto, el cual puede ser descargado del siguiente enlace. El usuario que propone una insignia puede indicar también cómo debería ser la consulta en la base de datos, para que ésta sea asignada e incluso la prueba unitaria que se puede realizar. De esta manera podrá facilitar el trabajo de la persona que se encargue de implementar la misma. "},"title":"Guía para la Propuesta de Insignias en omegaUp"},"/posts/hackathon-omegaup-febrero-2017-resultados/":{"data":{"":"En omegaUp organizamos nuestro primer Hackathon del año abierto al público, del 23 al 25 de Febrero pasados. Esta vez incluimos un divertido Bug Bash, donde invitamos a nuestros voluntarios a encontrar bugs dentro de omegaUp y reportarlos en github.\nAgradecemos la participación de todos los voluntarios que estuvieron involucrados. Los resultados que tuvimos fueron muy positivos: 50 bugs nuevos fueron descubiertos en el Bug Bash y se completaron 17 pull requests, muchos de ellos arreglando bugs que se encontraron en el mismo evento.\nRafael Díaz (rcxr) y Joe (joemmanuel) hackathoneando.\nomegaUp ofreció como premio una tarjeta de regalo de Amazon a quién encontrara más bugs y otra más a quien reportara el bug más interesante. Felicitamos a pacopedraza por llevarse el premio. El ranking de más bugs reportados quedó así:\nrcxr* (15) erosethan** (13) alanboy* (12) pacopedraza (6) cruzjorgesalazar (1) *No compite por premio por ser directivo de omegaUp for schools. ** Ganador del bug más interesante.\nY el ganador al bug más interesante por votación fue “Create course with no credentials does nothing” abierto por erosethan.\nEl Hackathon y el Bug Bash se concentró en el nuevo proyecto que estamos trabajando internamente para facilitar el uso de omegaUp.com en el salón de clases: omegaUp para escuelas. Los profesores que usan la plataforma podrán crear Cursos dentro de omegaUp.com con **tareas y exámenes **para facilitar la organización de sus clases. Estas nuevas funcionalidades estarán disponibles para el público en general más tarde este año.\nAgradecemos a todos su participación para ayudar a omegaUp a cumplir su misión de incrementar el número de ingenieros de software talentosos en América Latina. Si te gustaría participar en futuros eventos, contáctanos en hello@omegaup.com."},"title":"Hackathon omegaUp febrero 2017 - Resultados"},"/posts/historias-omegaup-2018/":{"data":{"convocatoria#Convocatoria":"","fechas#Fechas":"","historias-omegaup-2018#“Historias omegaUp 2018”":"","incentivos-y-dinámica#Incentivos y dinámica":"","términos-y-condiciones#Términos y condiciones:":"Convocatoria“Historias omegaUp 2018” Convocamos a nuestra comunidad de usuarios, tanto alumnos como profesores, a que nos compartan cómo utilizan omegaUp en su vida diaria.\nLos formatos pueden ser: un video corto o un texto con fotografías. Muéstranos tu comunidad y los lugares donde utilizas omegaUp: escuela, hogar, cibercafé, etc.\nEn tu historia puedes incluir temas como:\nPara ti, ¿qué significa programar? ¿Cuáles son tus sueños profesionales? ¿En este momento de tu vida qué herramienta te hace falta para acercarte a esos sueños?\nCuando tengas tu historia lista, envíala a historias@omegaup.com desde el correo en el que te hayas registrado en nuestra plataforma. Adjunta tus fotos o video en el correo. Si los archivos son muy grandes, puedes utilizar una plataforma en la nube y compartir el enlace con nosotros.\nIncentivos y dinámica El comité evaluador revisará todas las historias y seleccionará una de ellas para otorgar:\nUna computadora portátil HP (Modelo 15-bs001) de 15.6\". $2,000.00 pesos (MXN) para libros. Además, las historias serán presentadas a nuestros donadores en la Cena de Gala Anual de omegaUp en Bellevue, Washington.\nFechas La convocatoria comienza el lunes 19 de marzo y termina el viernes 27 de abril.\nLa persona seleccionada será anunciada el día lunes 7 de mayo a las 20:00 horas (Hora Central de México) en un broadcast en vivo en nuestro canal oficial de Facebook.\nSi tienes alguna duda ó comentario contáctanos a historias@omegaup.com\nTérminos y condiciones: Al momento de enviarnos el material, nos estás dando permiso de utilizar y compartir el contenido en nuestras redes sociales. Tienes que ser mayor de 13 años para participar. La convocatoria está abierta solamente para ciudadanos residentes de países de Latinoamérica."},"title":"Historias omegaUp 2018"},"/posts/ibero-american-competition-in-informatics-2016-modo-practica/":{"data":{"":"¿Quieres seguir practicando? El modo práctica del concurso Ibero-american Competition in Informatics 2016 ha sido habilitado aquí. Suerte!"},"title":"Ibero-american Competition in Informatics 2016 - Modo Práctica"},"/posts/iniciando-milestone-en-omegaup-karate-kid/":{"data":{"":"Después de año y medio de desarrollo (en nuestros tiempos libres) y de finalmente ser la plataforma de concurso en 3 de los eventos de programación más importantes de México ( Olimpiada Mexicana de Informática OMI, Concurso Nacional de Programación CONACUP y el Concurso Universitario de Programación de Aguascalientes CUPA) hemos decidido graduar nuestro motor de evaluación y concursos para invertir más tiempo en la usabilidad del sitio como plataforma de aprendizaje en un nuevo milestone: Karate Kid.\nDurante este nuevo milestone concentraremos nuestra energía en 3 escenarios principales:\nQue nuestros usuarios puedan usar OmegaUp como plataforma de entrenamiento. Actualmente el foco de OmegaUp ha sido soportar concursos en vivo, aunque hemos invertido en algunos features como el modo práctica. **Que nuestros usuarios puedan medir su avance y compararlo con otros usuarios, con un toque divertido.**No puedes mejorar lo que no puedes medir y para ello OmegaUp se encargará de encontrar el conjunto adecuado de estadísticas para ayudar a nuestros usuarios a mejorar. **Que nuestros usuarios puedan armar y arrancar sus propios concursos. **Actualmente arrancar un concurso en OmegaUp aún requiere un poco de intervención manual de los administradores, aunque cada vez menos. Para que nuestro modelo escale, necesitamos mejorar nuestra administración y automatización. Si tienes alguna idea relacionada con estas 3 áreas, nos gustaría escucharla. Puedes dejarnos un comentario en este post o escribirme un mail a joe [at] omegaup.com.\nOmegaUps trabajandoOmegaUps trabajando: @\\_alanboy, @limitedmage, @lhchavez\nOmegaUp sienta las bases para que concursos como el CONACUP puedan aumentar su cobertura escalando a varias sedes concurrentes y que concursos interestateles previos a Olimpiada de Informática se puedan llevar a cabo de forma remota. El 2013 va a ser un año bastante intenso para OmegaUp.\nOmegaUp es una plataforma open-source sin fines de lucro y todo el tiempo estamos buscando desarrolladores que gusten aportar al proyecto. Si te interesa, sabes o quieres aprender desarrollo web, diseño, o tienes alguna idea de sistemas distribuidos o machine learning que quisieras implementar, o tienes algún proyecto escolar que no sabes como invertir o simplemente quieres ganar experiencia desarrollando y manteniendo vivo un servicio web, siendo parte de un equipo de desarrollo remoto, puedes contactarme en joe [at] omegaup.com. Nuestro código se encuentra disponible en github.\nSalu2! -Joe"},"title":"Iniciando milestone en OmegaUp: Karate Kid"},"/posts/insignias-de-usuario-en-omegaup/":{"data":{"":"Estimados coders,\nTenemos el agrado de presentarles una nueva característica de la plataforma: “Insignias de Usuario”. Estas insignias son pequeños reconocimientos para los diversos logros alcanzados por ustedes y se encuentran ya disponibles en la plataforma.\nPara ver las insignias que has obtenido, simplemente debes acceder a tu perfil en omegaUp, ahora existe una nueva sección donde se listarán todas tus insignias conseguidas:\nAdemás, si quieres ver todas las insignias existentes, solo debes hacer click en el enlace Ver todas, que se encuentra al costado del número de insignias obtenidas. Recuerda que al poner el mouse sobre el ícono de la insignia, podrás ver la descripción de lo que tienes que hacer para poder obtener dicha insignia. Hay insignias que tienen un ícono sombreado por completo de negro, eso significa que aún no la has obtenido, ¡podrás ver el ícono de la insignia una vez la obtengas!\nSi quieres ver un poco más de información de una insignia, basta con que hagas click sobre ella, de esta manera, podrás acceder a una vista más detallada:\nY eso no es todo… Ahora, cada vez que recibas una insignia nueva, recibirás también una notificación, así siempre estarás al tanto de los nuevos reconocimientos adquiridos.\nY si te estás llenando de notificaciones, puedes marcarlas como leídas a todas, o de manera individual.\n¡Tú también puedes proponer nuevas insignias, solo debes seguir la Guía para la propuesta de Insignias de omegaUp!\nEsperamos que te guste esta nueva característica y que puedas desbloquear todas las insignias de usuario en omegaUp."},"title":"Insignias de Usuario en omegaUp"},"/posts/introduccion-a-omegaup-parte-0/":{"data":{"":" Hola!\nHemos recibido varias preguntas sobre cómo se envían soluciones a omegaUp. Decidí escribir una introducción a omegaUp, antes de empezar a aprender a resolver problemas. En resumen:\nEl objetivo de los concursos es acumular más puntos que todos los demás participantes. En caso de empate, se toma en cuenta la suma de los penalties (dependiendo del concurso puede no haber penalties, ser el tiempo desde que inició el concurso hasta que enviaste la solución o el tiempo desde que abriste el problema por primera vez hasta que lo resolviste). Jamás se te quitarán puntos por intentar resolver un problema: si ya habías enviado una solución con x puntos, únicamente se cambiará tu puntuación y penalty si obtienes más de x puntos. Toda la entrada y salida se hace mediante entrada estándar (“teclado” y “consola”), y no debes imprimir nada que no indique el problema: no debes poner cosas como “Dame un número”. omegaUp te proporcionará la entrada tal y como viene descrita en el problema. Todos los problemas de Java deben tener Main como nombre de clase. Si usas cualquier otro nombre, te regresará un Runtime error. cin (en C++) y Scanner (en Java) son relativamente lentos. En problemas donde haya mucha entrada, se recomienda usar scanf (en C/C++) y BufferedReader (en Java). Toda la entrada y salida está en formato Unix: las líneas terminan con “\\n”, no con “\\r\\n”. Primero veamos cómo luce la arena durante un concurso:\nEl reloj de arriba, si es negativo, te dice cuánto tiempo falta para que inicie el concurso. Cuando es positivo, te dice cuánto tiempo falta para que termine el concurso. Una vez que llega a cero, el concurso se cierra y ya no puedes enviar problemas. Hay tres pestañas en esta vista:\nProblemas: la que está mostrada arriba Ranking: te muestra con una gráfica el progreso del top 10 del concurso con respecto al tiempo y también muestra el ranking general para el concurso. Esta información se actualiza casi en tiempo real, así que si no ves un cambio en el scoreboard, ten paciencia y en un par de minutos se reflejará. Ten en cuenta que en algunos concursos, faltando poco tiempo para el final (puede ser una hora o media hora), el ranking deja de actualizarse para meter más emoción =) Clarificaciones: aquí puedes pedir clarificaciones específicas a la redacción de un problema, si algo no es suficientemente claro. Este no es el lugar para preguntar por qué cierto código no funciona (ese es el chiste del concurso! que tú sepas), así que evítate la molestia porque los jueces no te responderán. A los jueces les toma un poco de tiempo leer todas las clarificaciones y responderlas adecuadamente, así que ten paciencia. Ponte a resolver otro problema mientras. Nota: a veces verás que hay una nueva clarificación sin que tú hayas pedido una. Léela, porque es una clarificación global, o los jueces están intentando avisarte de algo. En la sección de Problemas es donde pasarás la mayor parte del concurso. En la parte de la izquierda está la lista de problemas junto con dos números (como 0 / 100). Estos números indican cuántos puntos has acumulado en ese problema y cuántos puntos vale el problema en total. A menos que los casos estén mal y los jueces hayan decidido re-juecear todos los envíos de un problema, esos puntos no pueden bajar si haces más envíos a un problema. Abajo de la lista de problemas, hay un miniranking con los mejores 10 participantes. Faltando poco tiempo antes del concurso, esta tabla dejará de actualizarse, no te apaniques.\nCuando selecciones un problema, verás la descripción de ese problema. En la mayoría de los concursos, se te agregará un penalty entre más te tardes en resolver un problema desde que inicia el concurso o lo abres por primera vez, así que trata de resolverlo lo más rápido posible. Este penalty NO te quita puntos, y solo se utiliza en caso de empates.\nHasta arriba viene una tablita con varias cosas útiles, como la cantidad de puntos máximos que te dará ese problema cuando lo resuelvas, el límite de tiempo que tienes para resolver cada caso y el límite de memoria que tienes para resolverlo. Después viene la descripción del problema (que usualmente es una pequeña historia) y le descripción formal del problema, la descripción formal del formato de la entrada, la salida y algunos ejemplos que confirman la explicación. Algunos problemas también incluyen una sección con todos los límites de las variables expuestas en la descripción del problema. Si no entiendes algo del problema, siéntete libre de escribir una clarificación. Por último, encontrarás una pequeña tablita con todos los envíos que has realizado para ese problema\nPuedes ignorar el ID, se utiliza únicamente por si algún juez te lo pregunta en caso de que haya problemas con el problema y haya necesidad de rejuecear envíos. Lo importante son las columnas de Puntos y Penalty. La información que aparece en el ranking toma en cuenta el envío que hayas hecho que tenga más puntos (y en caso de empate, el que tenga menos penalty). La columna de status son dos letras que te dan una pequeña pista de qué pasó con tu envío en general:\nAC - Accepted. Tu envío resolvió correctamente todos los casos de prueba y obtuviste la máxima cantidad de puntos. Felicidades! PA - Partially Accepted. Tu envío resolvió al menos un caso de prueba, pero hay al menos un caso que no resolviste correctamente. Intenta arreglar tu programa y vuélvelo a intentar. WA - Wrong Answer. Tu programa no resolvió ningún caso correctamente. TLE - Time Limit Exceeded. Al menos en uno de los casos, tu programa excedió el límite de tiempo. Intenta pensar en una solución más eficiente o busca en tu código si hay algún ciclo infinito. MLE - Memory Limit Exceeded. El menos en uno de los casos, tu programa excedió el límite de memoria. Intenta pensar en una solución que utilice menos memoria. En C y C++, algunos MLE se pueden reportar como RTE, sobre todo si declaraste arreglos gigantes. RTE - Runtime error. En al menos uno de los casos, tu programa tuvo un error fatal: puede ser una excepción en Java, no utilizaste “Main” como nombre de clase en Java, divisiones entre cero, desbordaste el stack, te saliste de los límites de un arreglo, etc. Vuelve a leer el problema y piensa qué casos se te olvió considerar y qué entrada puede hacer que tu programa se comporte de esta manera. RFE - Restricted function. En al menos uno de los casos, tu programa intentó realizar una operación prohibida. En general, no puedes abrir ningún archivo, no puedes conectarte a internet, no puedes ejecutar otros programas y no puedes comunicarte con nada del sistema fuera del problema. Limítate a resolver el problema usando algoritmos. CE - Compilation error. Tu programa no pudo ser compilado. omegaUp utiliza gcc y g++ en Linux, y usamos Java 1.6, así que podrían haber incompatibilidades entre tu ambiente de desarrollo y el que usamos nosotros. Si haces click en el botón de “Ver” el código, verás tu código seguido del error del compilador. JE - Judge error. Un error interno de omegaUp. Esto no debería pasar nunca, pero si te sale, alguno de los jueces ya lo vio y lo resolverá lo más rápido posible, así que no es necesario que lo reportes. Intenta otro problema mientras tanto, y ten por seguro que no serás penalizado por ese envío, porque no fue tu culpa. Como puedes darte cuenta, varios de los status no son mutuamente exclusivos. Siempre intentaremos el error más severo (los errores más severos están en la parte de abajo de esta lista), así que por ejemplo, si un envío te marca TLE y tienes algunos puntos, en ninguno de los casos detectamos un MLE ni un RFE, tuviste algunos casos bien, pero pudiste haber tenido otros casos mal y en al menos un caso excediste el límite de tiempo.\nSi crees que tu programa está resolviendo bien el problema, deténte a pensar por qué podría estar mal. El 99% de las veces, el problema está bien (sobre todo si hay alguien más que ya lo logró resolver), pero si tienes evidencia que hay algún error en el problema (por ejemplo, si dice la descripción que no habrán números mayores a 1000, y en tu programa validas esto y haces que te devuelva un veredicto como MLE), por favor pide una clarificación con esta información y tu ID de envío para que los jueces lo revisen.\nAhora sí, estás listo para continuar con la parte 1 del tutorial de omegaUp."},"title":"Introducción a omegaUp, parte 0"},"/posts/introduccion-a-omegaup-parte-2-problemas-basicos/":{"data":{"":"Hola de nuevo. Continuando con la serie Introducción a Omegaup, esta vez vamos a hacer referencia a los problemas más sencillos de la plataforma a la fecha. Aquí se encuentra la parte 1 de esta serie.\nPara estos problemas, no se requiere conocer una técnica o un algoritmo en específico: simplemente requieren implementar (o simular) lo que se describe en el problema o hacer una o dos observaciones relativamente sencillas que permiten simplificar la implementación o acortar el número de operaciones que tu programa tendría que hacer y con ello poder resolver el problema dentro de los límites.\nMaterial de estudio\nAntes de pasar a la lista de problemas, quiero empezar con las lecturas recomendadas para empezar a resolver problemas en omegaUp:\nEl Libro de Luis Vargas sobre Algoritmos. Este es el libro que usamos para preparar a los preseleccionados de México para la Olimpiada Internacional de Informática. Su lectura completa es recomendada, sin embargo las secciones VII y II son fundamentales. Los temas 1, 2, 4 y 5 del blog de Pier Paolo sobre algoritmos. The Importance of Algorithms (Topcoder Algorithm tutorials) Mathematics for Topcoders (Topcoder Algorithm tutorials) Problemas directos\nEstos concursos fueron diseñados para familiarizarse con la programación competitiva en general. Son excelentes para empezar y su solución generalmente no requiere dominar una técnica en específico, más bien requieren saber usar las construcciones (ciclos, condiciones, etc…) del lenguaje correctamente:\nCódigo Rush 2013 (Taller) Código Rush Otoño 2013 CUPA 2012 Warmup Problemas no-tan-directos\nEngranes (solución) Lento (solución) Subprimos (solución de diego_futbolm) La venganza de Silvio (solución) Las cartas del Dr. Lira (solución) El tablero de Bety (solución de spleensarethebest) Triángulos (solución TriangleConstruction en Topcoder) Tienes más sugerencias de problemas o dudas sobre los existentes? Escríbelos en los comentarios."},"title":"Introducción a Omegaup, parte 2 - Problemas básicos"},"/posts/introduccion-a-omegaup/":{"data":{"":"Estamos iniciando una serie de 10 posts para ayudar a nuestros nuevos usuarios a navegar con facilidad entre la gran cantidad de problemas de omegaUp, en forma de mini-tutoriales con los conceptos básicos, temas y fuentes. Esta colección de tutoriales y ligas te ayudarán a resolver muchos de los problemas de omegaUp y aumentar tu nivel de programación.\nEn este post inicial voy a cubrir los aspectos más básicos de la resolución de problemas. Vamos a tomar como base el problema clásico sumas.\nEnunciado del problema\nNos piden leer 2 números enteros y escribir la suma de ambos. Dónde los leo y cómo los escribo? Todos los problemas de omegaUp (con excepción de los problemas de Karel) usan la entrada estándar (stdin) y la salida estandar (stdout) para comunicarse. omegaUp prohibe abrir archivos por seguridad.\nCómo sabe omegaUp que mi solución está bien o mal? Los problemas de omegaUp tienen un conjunto de “casos de prueba” predeterminados que se usan para revisar tu solución. Cada caso de prueba consta de una entrada (por ejemplo 1 1) y su solución previamente calculada (2 en este caso).\nTu programa es compilado y ejecutado contra cada uno de los casos de prueba: se le da la entrada a tu programa y se compara tu salida con la salida oficial. Si tu programa imprime 2, entonces se considera el caso como correctamente resuelto.\nTu puntaje final se calcula en base al porcentaje de casos que tu solución resuelve correctamente. El número de casos de prueba predeterminados que tiene un problema es variable (pueden tener desde 1 hasta cientos distintos). Si tu solución obtiene AC (accepted), quiere decir que has resuelto todos los casos correctamente.\nCon esta información en mente, la solución suena bastante trivial. He aquí un ejemplo en C:\ny uno en Java:\nEnviamos esta solución… y nos encontramos que no resuelve todos los casos (obtiene WA, wrong answer). Por qué? (Recomiendo al lector que haga una pausa aquí y trate de entender por qué no funciona).\nLímites\nHay datos que no hemos considerado en la descripción del problema: los límites. Existen 3 tipos de límites comunes en omegaUp:\nLímite de tiempo: Tu solución no puede tardar más del tiempo indicado para resolver un caso. Para nuestro problema Sumas, tenemos 1 segundo para producir una solución. Para entender por qué el tiempo es un factor limitante, te recomiendo leer The Importance of Algorithms en los tutoriales de Topcoder. Límite de memoria: Tu solución no puede usar más megabytes de los permitidos por el límite para producir la respuesta. **Límites en las variables de entrada: **No todos los problemas tienen una sección específica donde se indice cuáles son los valores mínimos y máximos de una variable, por lo que necesitamos leer con atención el problema para obtenerlos. En nuestra solución anterior, hay un dato que no consideramos: La suma de ambos números cabe en un entero de 64 bits. En nuestra solución anterior estábamos usando el tipo de datos int, los cuales tienen un límite de 32 bits (Un int en C puede guardar números entre $latex -2^{31}$ hasta $latex 2^{31}-1$, es decir, de -2147483648 hasta 2147483648 ). Para satisfacer el límite de 64 bits, necesitamos usar variables que puedan soportarlo: long long (en C)\nNota como tuvimos que cambiar el %d del printf/scanf por %lld para leer y escribir correctamente el entero long long. omegaUp evalúa las soluciones en Linux y para C/C++ usa el compilador g++.\nLa misma solución en Java:\nSi quieres saber más sobre los tipos de variables y sus límites, te recomiendo leer: Representation of integers and reals en Topcoder.com .\nPara saber más…\nAquí enlisto varias fuentes de muy buena información sobre cómo resolver problemas y diseñar algoritmos para concursos de programación en general. Los siguientes tutoriales estarán basados en estas fuentes, les recomiendo mucho darles una revisada:\nProblemas y Algoritmos, Luis Vargas. El blog de Pier Paolo sobre Algoritmos TopCoder tutorials. En particular les recomiendo empezar por The Importance of Algorithms y How to find a solution. El blog de Rodrigo Burgos (nivel avanzado) Con qué otros problemas puedo practicar?\nAquí hay algunos otros problemas con los que puedes practicar para iniciarte en omegaUp. Incluyo un link al código de la solución, pero mi recomendación es que trates de hacerlos por tí mismo. Ve la solución sólo en caso de que estes completamente bloqueado:\naMAYUSCULAS. Solución. Bisiesto. Solución. Patos. Solución. Tienes otros tips o algunos tutoriales/soluciones que quieras compartir? Escríbelos en los comentarios."},"title":"Introducción a omegaUp, parte 1"},"/posts/invasion-zombie/":{"data":{"":"","primer-solución#Primer solución":"","segunda-versión#Segunda versión":"Hola!, este es mi primer post en Omegaup y voy a describir mi solución para el problema Invasion zombie. Hace un año encontré este problema, me pareció interesante y logre resolverlo, aunque algo tricky. Hace unos días me tope con este problema nuevamente y lo resolví por segunda ocasión, pero con una solución más simple, al menos eso creo.\nPrimer solución La idea principal tanto en la primera como en la segunda solución es diseñar una función $latex f(d)$ que nos retorne el número de colonias infectadas después de $latex d$ días, nos interesa el mínimo valor de $latex d$ tal que el número de colonias infectadas sea mayor o igual a $latex C$. Una propiedad importante es la siguiente, $latex f(d)$ nunca decrece, es decir $latex f(d) \u003c= f(d+1)$. Esta propiedad nos permite utilizar búsqueda binaria para encontrar las respuesta en $latex O(\\lg_{2}(n))$. Diseñar una función que determine el número de colonias infectadas, dependiendo del background de cada uno, es la parte interesante, y es donde difieren las dos versiones, bueno, un poco. Este es el código de la primer versión, no voy a entrar en detalles porque ni yo me acuerdo bien que trucos aplique, pero la idea es parecida a la de la de la segunda versión, lo que cambia es la estrategia.\nSegunda versión Bueno, empecemos, trascurridos $latex d$ días, ¿cuántas colonias han sido infectadas? Simulemos la invasión y veamos si podemos encontrar un patrón. No es complicado llegar a la siguiente fórmula: $latex f(d) = d^{2} + (d+1)^{2}$ Si el espacio de la ciudad fuese ilimitado nuestra función de verificación sería algo parecido a:\nSin embargo, el espacio de la ciudad es limitado y habrá casos como los siguientes: Entonces nuestro objetivo es encontrar el área delimitada por la ciudad (un cuadrado de N * N unidades), lo cual se pone un poco tricky. La siguiente imagen nos ayudará a entender el código de la solución sin entrar en tantas explicaciones. Es decir, el área total menos el área de los triángulos superior, inferior, izquierdo y derecho. Obsérvese que los triángulos pueden traslaparse y por lo tango estaríamos restando esas áreas 2 veces, por ello tenemos que calcular las áreas de traslape (nw, ne, se y sw en la imagen) y regresar lo a la suma total. Lo que sigue es la implementación:\nEspero que les sea útil, dudas, comentarios o correcciones son bienvenidas."},"title":"Invasion Zombie"},"/posts/ioi-2015-entrevista-con-blak_dragon1/":{"data":{"":"\nPara terminar con la serie de entrevistas a los representantes de México en la IOI 2015, tuvimos la oportunidad de platicar con blak_dragon1 (Ángel Ortega). Esto fue lo que nos dijo:\nCuéntanos cómo empezaste a programar y qué te motiva a resolver problemas:\nTodo empezó en un curso llamado “Aprende a Programar” para las Escuelas Secundarias Técnicas. Yo estudiaba en la Escuela Secundaria Técnica No. 37 el 1er grado, ahí fue donde me invitaron a hacer un examen para lograr un lugar en el curso, y me agradó la idea porque algo que ya me llamaba atención en esos días era el uso de la computadora. Conseguí quedarme y aquí vi un poco de lógica matemática y Karel. Esto fue el inicio de todo, nos platicaron de la Olimpiada Mexicana de Informática y que esta da pie para la International Olympiad in Informatics. Eso me emocionó bastante para seguir adelante dentro de la olimpiada estatal del Distrito Federal.\nUna motivación que encuentro es que me puede traer una gran cantidad de oportunidades tanto académicas en distintas universidades como laborales en grandes empresas internacionales, además que con el tiempo le he tomado un gusto a la resolución de problemas y a la sensación de competencia dentro de la olimpiada.\n**Vas a representar a México este año en la IOI. Cuéntanos cómo te preparaste para lograrlo. **Cómo son tus días de entrenamiento?\nSiento que en el proceso para la IOI de este año me he dedicado más a la olimpiada a comparación de otros años. Esta ocasión realmente aproveche las vacaciones y recesos escolares para entrenar, me puse a leer un poco sobre temas, estructuras de datos y algoritmos que pudieran servirme (Unas ocasiones leí de Algorithms, Fourth Edition de Robert Sedgewick, y en otras ocasiones fue Algorithm Design de Kleinberg y Tardos) y aumenté la cantidad de horas por semana para practicar a partir de organizarme mejor para repartir el tiempo para no desatender los asuntos de la escuela y mejorar para la olimpiada.\nAlgo que considero muy importante fue el practicar con problemas de preselectivos de años pasados presenciales antes de una semana de exámenes para eliminación. Hice algo muy parecido con los exámenes de la USACO, antes de presentar mi primer examen de nivel Plata hice 2 exámenes de ese nivel para para darme una idea de la dificultad y en mi primer examen subí a Oro. Antes del examen de nivel Oro también practiqué con un examen de Oro pasado y así no me sorprendiera el cambio de dificultad. Y en estas alturas me preparo con exámenes completos de las IOI pasadas para irme ambientando.\nQué le recomiendas a los que van empezando? Algún material, libro o método de entrenamiento?\nYo les recomiendo que sigan al pie de la letra las instrucciones y recomendaciones que nos dan para la preselección, intentar hacer todo los problemas cada problemset, familiarizarse con exámenes de las olimpiadas abiertas de otros países (como USACO de Estados Unidos, COCI de Croacia) ya que sus exámenes también serán tomados en cuenta para las primeras etapas. Si tienen asesores estatales que los estén apoyando aprovéchenlos al máximo, pregúntenle todas sus dudas y póngales bastante atención, cuando vean un tema con él, estando en casa refuercen lo visto leyendo de un libro el tema visto, un buen libro que les servirá para cubrir una gran cantidad de temas es Problemas y Algoritmos que se encuentra en Material Recomendado al inicio de OmegaUp.\nCuál es tu problema favorito de omegaUp y por qué? Hay un problema en particular que hayas disfrutado mucho resolver?\nEl que más disfruté resolver sin duda fue Fortune Telling 2 (parte de la Japan Olympiad in Informatics 2014), ya que la combinación estructuras de datos y métodos de solución que implementé me pareció que fue variada (Búsqueda binaria con Segment Tree y al final un BIT), de igual forma sentí que el análisis para llegar a la idea fue progresivo, lo fui haciendo parte por parte y cada vez descubría algo me acercaba más a la solución. Otro aspecto por el cual me agrada es porque es de los primeros problemas en los que sin saber previamente que tienen una solución con una estructura de datos puede describir cómo resolverlo.\nDescríbenos tu estrategia para atacar un concurso. En qué momento decides cambiar de problema?\nLo que siempre hago es leer todos los problemas que vengan en el examen y mientras voy leyendo, al llegar a la parte de los límites intentar ver si hay alguna solución parcial que en ese instante pueda deducir si conseguiré programarla sin problemas durante el examen, a partir de eso veo la cantidad mínima de puntos podré lograr. De igual forma ordeno los problemas del más fácil al más difícil y empiezo a atacarlos, empezando por el fácil. Cuando llego a un punto en el que llevo demasiado tiempo (40 minutos, 60 ya exagerando) pensando y sigo perdido o sin encontrar nada nuevo es en donde cambio de problema. Si ya pensé demasiado tiempo todos los problemas pendientes por resolver me arriesgo por la solución con más puntos que haya encontrado durante el tiempo de análisis de cada problema y si aún queda tiempo, regreso a seguir pensado otro poco pero por lo regular ya no vuelvo a tener tiempo para pensar de nuevo.\nAparte de resolver problemas, cuáles son tus hobbies? cuáles son tus libros favoritos? qué música escuchas? practicas algún deporte?\nDe hobbie me gusta armar puzzles 3D (Al estilo del cubo Rubik pero con variaciones). Los libros de literatura que he leído son principalmente los que me han dejado leer como tarea y los que más me han agradado son “Los días enmascarados” y “Aura” de Carlos Fuentes, junto con “Al sur de la frontera al, oeste del sol” de Haruki Murakami. De música me gusta mucho el Power Metal, principalmente si tiene un toqué Sinfónico (Al estilo Rhapsody of Fire), encuentro cierta inspiración al escuchar música con un ritmo enérgico. También me agrada el basquetbol, aunque no lo practico formalmente, durante algunos recesos de la escuela me gusta salir a jugar."},"title":"IOI 2015 - Entrevista con blak_dragon1"},"/posts/ioi-2015-entrevista-con-charlyhlms/":{"data":{"":"\nEsta vez tocó el turno de entrevistar a charlyhlms quién representará a México por segunda vez en la International Olympiad in Informatics. Esto fue lo que nos dijo:\nCuéntanos cómo empezaste a programar y qué te motiva a resolver problemas:\nEmpecé a programar cuando tenía 13 años, durante mi segundo año de secundaria. Estaba en el taller de Computación y a principios de ese año nos enseñaron a programar en Pascal y Karel, en ese entonces me parecía algo divertido y diferente, fue por eso que cuando me comentaron sobre la Olimpiada decidí inscribirme.\nResolver un problema es un proceso bastante interesante, no importando el tipo de problemas al que nos enfrentemos, tanto problemas de olimpiadas como problemas de la vida diaria representan retos que afrontamos constantemente, retos que a mi parecer son una manera de poner a prueba la creatividad de una persona y su capacidad de aplicar el conocimiento que ha adquirido, sin importar de donde, para un fin práctico. Además de esto, creo que todos podemos concordar en que después de resolver un problema suele haber una sensación de satisfacción, de sentirnos mejores en lo que hacemos por que tuvimos la capacidad de dar solución a un problema por nuestros propios medios y saber que cada problema que resolvemos nos aporta nuevos conocimientos. Más particularmente para los problemas de olimpiada hay un par de situaciones que siempre me parecieron muy interesantes: El hecho de que no baste con obtener una buena idea, sino que además tengas que escribir está idea para que una computadora pueda hacer lo que tienes en mente; y que después de haber obtenido la solución completa a un problema siempre puedes mirar atrás, aprender de los errores que cometiste en el proceso o de las nuevas ideas que pusiste en práctica, y de como ahora todo ahora parece tan obvio, después de que en un principio no parecías saber ni por donde empezar. La combinación de todo esto es lo que me ha motivado a dedicar buena parte de mi tiempo a resolver problemas.\n**Vas a representar a México este año en la IOI. Cuéntanos cómo te preparaste para lograrlo. **Cómo son tus días de entrenamiento?\nLlegar a la IOI fue un proceso que principalmente requirió mucha disciplina y constancia a la hora de entrenar. No creo poder describir un día normal de entrenamiento porque mi manera de entrenar cambiaba dependiendo de en que me quería enfocar. Entre las cosas que hacía estaba presentar un examen por semana, para esto usaba fuentes como la Usaco o exámenes de IOIs u OMIs pasadas. Después de hacer el examen leía las soluciones tanto de los problemas que resolví como los problemas que no resolví e implementaba estas soluciones completas.\nTambién le dediqué mucho tiempo a leer para aprender nuevos temas y técnicas además de mejorar mis habilidades matemáticas, un libro que aún no acabo de leer pero estoy disfrutando es Art and Craft of Problem Solving. Además de esto hubo un tiempo en que me interesaba mejorar mi rapidez a la hora de implementar además de mi capacidad para escribir códigos sin errores, para ello escribía todos mis códigos en papel antes de escribirlos en computadora, lo bueno de hacer esto es que al escribirlos en papel, con pluma, no se tienen las herramientas de edición que se tienen cuando se hace en un editor de texto, por lo que se vuelve muy importante estar completamente seguro de lo que se está implementando. En general estás fueron algunas de las cosas que hice durante este año de entrenamiento, pero como dije no sólo es importante tener un buen plan o método de entrenamiento sino también ser capaz de cumplir con las metas que uno se propone y ser muy constante.\nDe los 4 representantes de México, tú eres el olímpico con más experiencia. Tuviste la oportunidad de participar en la IOI 2014, qué lecciones aprendiste y qué planeas hacer diferente este año?\nIr a una IOI ha sido una de las mejores experiencias en mi vida, no haber obtenido una medalla no opacó este hecho pero si es algo que me ha sido difícil superar. Lo importante de esto es que me dio la oportunidad de aprender muchas cosas sobre la competencia y sobre lo que tenía que mejorar. Entendí cosas muy importantes como la relevancia de manejar el tiempo de la manera correcta, y en especial de mantener la calma durante el examen sin importar lo difícil que se pongan las cosas. Comprendí y trabajé en las cosas que debía mejorar, algunas de ellas ya las mencioné: mi rapidez y la eficacia con la que programo por ejemplo. No creo que el resultado que obtuve el año pasado fue en vano, la experiencia me ha servido demasiado, y para esta IOI estoy muy motivado, motivado como nunca lo he estado, porque voy a disfrutar mucho la competencia y porque estoy seguro que estoy en un mejor momento que el año pasado.\nQué le recomiendas a los que van empezando? Algún material, libro o método de entrenamiento?\nDurante mi primer año en la pre-selección un libro que me resultó de mucha ayuda fue Problemas y Algoritmos por Luis Enrique Vargas Azcona. Incluye muchos de los temas básicos y no tan básicos que se abarcan durante las primeras etapas del pre-selectivo y una gran ventaja es que está escrito en español, y muchos de los problemas propuestos en el libro se pueden resolver en OmegaUp. Además de ese libro leí Introduction to Algorithms, y Algorithm Desing por Jon Kleinberg, también me fueron de mucha utilidad aunque quizá son un poco más avanzados y están escritos en inglés.\nClaro que aparte de tener una fuerte base de teoría y conocer muchos temas, resulta igual de importante dedicar la mayoría del tiempo de entrenamiento a resolver problemas. Una muy buena página para entrenar es la Usaco Training Gateway (http://train.usaco.org/usacogate), resulta bastante útil porque los problemas están divididos por secciones y cada sección abarca un tema diferente. Y como parte importante de la competencia es ser capaz de resolver problemas incluso bajo la presión y el estrés de un examen, también recomendaría hacer exámenes constantemente, para esto además de OmegaUp, hay un par de buenas páginas como la USACO http://www.usaco.org/ y COCI http://hsin.hr/coci/ en las que se pueden encontrar exámenes de años pasados.\nCuál es tu problema favorito de omegaUp y por qué? Hay un problema en particular que hayas disfrutado mucho resolver?\nDiría que mi problema favorito de OmegaUp es Pequeños Autobuses, fue un problema que enfrenté por primera vez durante un eliminatorio de la pre-selección, pero fui capaz de resolverlo hasta unas semanas después. Esos problemas que te toman mucho tiempo resolver siempre terminan siendo “divertidos”. Aparte de este problema en general disfruto mucho resolver tareas de IOI; resultan divertidos porque aunque se trate de un problema relativamente sencillo suele haber detalles que lo hacen ser un problema interesante, ya porque necesitan una idea bastante creativa o bien porque requieren de una implementación elegante. Algunos problemas de IOI de este estilo son: Bloques, Fuerza Media, Montañas, Joining Points, Impresora de Tipos, Cueva, Ríos, Loros (Todos estos están disponibles en OmegaUp), además de Batch Scheduling de la IOI del 2002, Amazing Robots de la IOI del 2003 y Robots de la IOI 2013.\nDescríbenos tu estrategia para atacar un concurso. En qué momento decides cambiar de problema?\nLo primero que hago cuando enfrento un examen es siempre leer todos los problemas y asegurarme de entenderlos perfectamente, al punto de que pueda dejar de ver la descripción del problema y no olvidar los detalles importantes. Después de esto mi estrategia suele cambiar dependiendo de la dificultad de los problemas que intentaré resolver, pero normalmente intento atacar cada uno de los problemas en orden. Al atacar un problema me doy una cantidad limitada de tiempo para pensar en la mejor idea que me sea posible, digamos, media hora, aunque este tiempo puede disminuir si me doy cuenta que no estoy obteniendo avances importantes, o por el contrario aumentar si creo estar cerca de una solución completa. Después de esto implemento la mejor solución que haya obtenido y al obtener los puntos esperados cambio de problema. Al final si ya he intentado algo para todos los problemas del examen, elijo alguno de los problemas que no resolví completamente e intento mejorar mi puntaje obteniendo mejores ideas.\nSobre cuando “cambiar de problema”, al menos yo sólo lo hago cuando he dedicado mucho tiempo a depurar mi código. Siempre hay ocasiones en que obtenemos una buena idea, la implementamos y después de subirla no obtenemos los puntos que esperábamos, aunque puede llegar a ser bastante molesto no es prudente darse por vencido en ese mismo instante como no es conveniente dedicar más tiempo de lo adecuado a buscar un error en la idea o en la implementación. Depende mucho del examen y de la situación particular en la que te encuentres, pero siempre se debe dedicar una parte del examen a buscar el posible error en nuestra implementación o incluso en la idea, pero es igual de relevante, en caso de no poder encontrar dicho error, ser capaz de abandonar el problema, bien cambiando de problema o bien intentando una solución diferente que probablemente dé menos puntos. Saber manejar el tiempo durante un examen se vuelve en ocasiones tan crucial como tener buenas ideas o ser rápido codificando, pero esto es algo que se obtiene con la práctica, después de haber realizado una buena cantidad de problemas y exámenes.\nAparte de resolver problemas, cuáles son tus hobbies? cuáles son tus libros favoritos? qué música escuchas? practicas algún deporte?\nAdemás de resolver problemas, me gusta leer y escribir y también tocar la batería. Algunos de mis libros favoritos son El Llamado de la Selva por Jack London, Nada de Janne Teller y El Juego del Ángel de Carlos Ruíz Zafón. También disfrutó bastante de escuchar música, creo que mis gustos son bastante variados pero normalmente escucho Rock, algunos de mis grupos favoritos son The Beatles y Soda Stereo aunque recientemente comencé a escuchar otro generó musical: Jpop. Viajar es también algo que siempre me ha gustado y la olimpiada me ha dado la oportunidad de hacerlo con bastante frecuencia."},"title":"IOI 2015 - Entrevista con charlyhlms"},"/posts/ioi-2015-entrevista-con-emmanuel_antonio/":{"data":{"":"\nEmmanuel_Antonio será uno de los representantes de México en la International Olympiad in Informatics 2015. Tuvimos la oportunidad de entrevistarlo previo al concurso y esto fue lo que nos dijo:\nCuéntanos cómo empezaste a programar y qué te motiva a resolver problemas:\nEmpecé a programar cuando el maestro Luis Citalán me invitó a entrar al taller de la Olimpiada en la escuela. Me motiva ver a esas personas que han logrado cosas muy importantes.\n**Vas a representar a México este año en la IOI. Cuéntanos cómo te preparaste para lograrlo. **Cómo son tus días de entrenamiento?\nYa es mi segundo año en la olimpiada, en el primer año aprendí muchas cosas nuevas en los entrenamientos y el segundo año lo dediqué a practicar esas cosas que había aprendido.\nQué le recomiendas a los que van empezando? Algún material, libro o método de entrenamiento?\nNo dejar de practicar, cada vez busquen problemas de mayor dificultad, que vean problemas de olimpiadas pasadas para así saber que temas son los que les hacen falta aprender o practicar y sobre todo que lo hagan por gusto, no porque se sientan obligados o algo así.\nCuál es tu problema favorito de omegaUp y por qué? Hay un problema en particular que hayas disfrutado mucho resolver?\nNo sabría decir cual es mi favorito. Disfruto aquellos que después de pensarlos un buen rato al fin te llega la idea de la solución.\nDescríbenos tu estrategia para atacar un concurso. En qué momento decides cambiar de problema?\nLeer todos los problemas y entender que es lo que pide cada uno de ellos, después empiezo con el que yo considero que podría estar más fácil. Cambio de problema cuando siento que pasa un buen rato y no logro avanzar en la idea.\nAparte de resolver problemas, cuáles son tus hobbies? cuáles son tus libros favoritos? qué música escuchas? practicas algún deporte?\nMe gusta salir con mis amigos, ver películas o series y jugar. Me gustan los libros que tiene misterio o algo policiaco. Escucho casi de todo, son muy pocos los tipos de música que no me gustan. Me gusta mucho jugar fútbol. :D"},"title":"IOI 2015 - Entrevista con Emmanuel_Antonio"},"/posts/ioi-2015-entrevista-con-juan_carlos_sigler_priego-mex/":{"data":{"":"Estamos inaugurando la categoría de Entrevistas en el blog de omegaUp y en esta ocasión tuvimos la oportunidad de hablar con Juan_Carlos_Sigler_Priego quien representará a México en la International Olympiad in Informatics (IOI) 2015.\nCuéntanos cómo empezaste a programar y qué te motiva a resolver problemas.\nEmpecé a programar cuando me metí al Curso de la OMI en mi Estado (Distrito Federal), más que nada me motiva el ver como todo esto le ha ayudado a ex-concursantes, gente que la contrata empresas muy importantes, como MIcrosoft y Google, aunque a mi en lo personal me gustaría formar mi propia empresa.\nVas a representar a México este año en la IOI. Cuéntanos cómo te preparaste para lograrlo. Cómo son tus días de entrenamiento?\nYa llevo un rato en esto de entrenarme, este año en particular me decidi en hacerme un tiempo de dos horas minimo diarias en atacar problemas, más aparte me ayuda mucho los entrenamientos sabatinos con mi delegación.\nQué le recomiendas a los que van empezando? Algún material, libro o método de entrenamiento?\nPara ser sincero no he leído muchos libros, ya que no hay muchos recursos en español. Lo que si les sugiero es que entrenen constantemente, con problemas DE SU NIVEL (resolvibles para ustedes y que necesiten pensar), es impoductivo estar resolviendo los diversos problemas de A+B.\nCuál es tu problema favorito de omegaUp y por qué? Hay un problema en particular que hayas disfrutado mucho resolver?\nHay uno en particular que me gustó mucho hacerlo, mas que nada porque es mi temas favoritos, se llama Loca People y la fuente es Nievecitos.\nDescríbenos tu estrategia para atacar un concurso. En qué momento decides cambiar de problema?\nPrimero es leer todos los problemas, a veces, si uno esta en exceso muy fácil, lo hago y después sigo leyendo. Ya que tengo bien definido que debo hacer en cada uno, trato de ordenarlos por dificultad y así los empiezo a atacar. Cuando estoy ya unos 10 minutos atorado en un problema o en una idea, me despejo 2 minutos y cambio de problema.\nAparte de resolver problemas, cuáles son tus hobbies? cuáles son tus libros favoritos? qué música escuchas? practicas algún deporte?\nMe gusta mucho jugar con mi familia, ver peliculas. Mis libros favoritos son los que tienen misterio. Escucho toda clase de musica aunque lo que mas escucho es Bruno Mars. En la semana, 2 días voy a natación y me gusta de vez en cuando ir a jugar futbol."},"title":"IOI 2015 - Entrevista con Juan_Carlos_Sigler_Priego (MEX)"},"/posts/juego-lento-ethan-jimenez/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 1\nAutor: Ethan Jimenez\nEmpecemos analizando el caso en que solo jugamos con un montón de fichas, dada la restricción de tomar únicamente una sola ficha el juego se vuelve predecible ya que no hay más opción que tomar una ficha de ese montón. Si el montón tiene una sola ficha el jugador con el primer turno pierde, si hay dos fichas el jugador con el primer turno gana, si hay tres fichas el jugador con el primer turno pierde, y así alternadamente, podemos entonces deducir que si hay un número impar de fichas en el montón, el jugador con el primer turno perderá, por el otro lado, si el montón tiene un número par de fichas ganará la partida.\nLa pregunta clave para este problema es, ¿realmente hay diferencia entre tomar una ficha de un montón y tomar una ficha de otro montón? Aumentemos la cantidad de montones en el juego, digamos que ahora tenemos dos montones de fichas, ambos montones tienen una sola ficha, el jugador con el primer turno ganará, detente por un momento a experimentar qué sucede si aumentamos la cantidad de fichas en un montón, en el otro y en ambos montones, teniendo en mente la pregunta anterior.\nDespués de probar con diferentes configuraciones de juego podemos decir que la respuesta a la pregunta es no, tomar primero una ficha de un montón no es diferente a haberla tomado de cualquier otro montón, con lo que podemos concluir que, si tenemos dos montones, el primero con a1 fichas y el segundo con_a2_fichas, este juego es equivalente a tener un solo montón con _a1+a2_fichas, una vez establecido podemos volver a nuestro análisis inicial y calcular quién ganará.\nDe manera análoga deducimos que si tenemos _N_montones de fichas y elegimos _K_de ellos, podemos reducir la configuración herpes transmission de esta partida a un juego con solo un montón de _k1+k2+…+kN_fichas, donde kies el número de fichas en el montón elegido i. Una vez que sabemos lo anterior debemos darnos cuenta que para ganar tenemos que elegir K de los N montones cuya suma total sea un número impar.\nPara asegurarnos que un conjunto de montones tiene un número impar de fichas debemos considerar lo siguiente, un número impar más un par da un número impar, un número impar sumado a un impar da un número par y un número par más un par da otro número par. Dado lo anterior podemos definir una regla para tener una suma total impar, debe existir una cantidad impar de montones con un número de fichas impar, si le agregamos cualquier cantidad montones con número de fichas par no se modifica la condición de tener un total impar.\nEn conclusión, es posible ganar el juego cuando existe más de un montón con número impar de fichas, si hay una cantidad impar de montones impares ya se cumple la condición deseada, pero si hay una cantidad par de montones impares debemos quitar uno para cumplirla, para obtener el juego con la mayor cantidad de fichas el montón que quitemos debe ser el que tenga menos fichas, nota que, como mencioné antes, agregar montones pares no afecta la condición de victoria, por lo que para aumentar la cantidad de fichas en el juego se deben agregar todos ellos."},"title":"Solución a \"Juego Lento\""},"/posts/muchas-gracias-2da-gala-anual-de-omegaup/":{"data":{"":"","#":" Prof. Pedro Fuentes dando un gran discurso en la 2da Gala de omegaUp.\nQueridos amigos, Gracias a la increíble generosidad de todos los participantes, nuestra 2ª Gala Anual celebrada el 19 de Octubre trajo casi $ 40,000 en fondos que serán utilizados para ayudarnos a mejorar omegaUp.com como una plataforma de aprendizaje gratuita para llegar a más estudiantes, y continuar nuestros programas sociales.\nCódigos de Yucatán by Rafa Díaz, Artist \u0026 member of omegaUp Board of Directors\nEduardo Sosa, Consul Adscrito de México en Seattle, en el discurso de apertura.\nHemos sido honrados por la presencia de Eduardo Sosa, Cónsul de México, Clary Monzón, Cónsul General de El Salvador y Miguel Ángel Velásquez, Cónsul General de Perú. “El trabajo de omegaUp debe ser visto como el puente que une los sueños de nuestros estudiantes con un entorno de innovación que ya está sucediendo en todo el mundo”, fueron las palabras de apoyo del honorable Cónsul Eduardo Sosa. “Los puentes te van a llevar más lejos que las paredes. Son más difíciles de hacer, y deshacer.”, fueron las palabras de aliento del honorable Cónsul Miguel Ángel Velásquez.\nMiguel Ángel Velásquez, Honorable Consul de Perú. Clary Monzón, Honorable Consul de El Salvador in Seattle\nMiguel Ángel Velásquez, Honorable Consul de Perú en Seattle\nHemos celebrado los logros de la Escuela del Año, el Instituto Técnico Superior del Sur de Guanajuato representado por el Prof. Germán Gutiérrez, el organizador principal de la Coding Cup ITSUR 2019, un concurso de programación organizado en omegaUp que cuenta con 1500 estudiantes que participaron en todo México.\nLa Escuela del Año: Nancy Pacheco, parte del omegaUp Board of Directors y Prof. Germán Gutiérrez del Instituto Tecnológico Superior del Sur de Guanajuato.\nEl Prof. Pedro Fuentes compartió, en un emotivo discurso, su experiencia al guiar a los alumnos del Centro de Bachillerato Tecnológico Agropecuario #39 en Temoac, Morelos, a participar en competiciones internacionales de robótica utilizando la magia de la programación como su fuerte. La historia del Prof. Pedro estará siempre grabada en nuestros recuerdos como un ejemplo de logro y éxito a través de la perseverancia.\nSalvador Segura - parte del omegaUp Board of Directors, cerrando la Gala 2019.\nGracias - amigos, voluntarios y donadores - por hacer posible estas historias de éxito. Su apoyo inspira talento y nos motiva a continuar en este viaje.\nomegaUp Fundraising Team y amigos\nPara mayor información sobre la organización, visita omegaUp.org y síguenos en Facebook.\nSinceramente,\nJoemmanuel Ponce Director Ejecutivo - omegaUp."},"title":"¡Muchas gracias! - 2da Gala Anual de omegaUp"},"/posts/omegaup-apoya-al-1er-concurso-de-programacion-uvm/":{"data":{"":"El pasado 29 de noviembre se llevó a cabo, en las instalaciones de UVM Campus Sur Guadalajara, el Primer Concurso de Programación UVM, bajo el marco del “Innovation and Technology Fest”.\n1er Concurso UVM1er Concurso UVM\nParticiparon Estudiantes del campus e invitados de CUCEI UdeG, teniendo un total de 13 concursantes. El examen se llevó a cabo a las 10 de la mañana con una duración de 3 horas y consistió de 5 problemas sencillos. La evaluación se llevo a cabo gracias a la plataforma Omegaup.\n1er Concurso UVM1er Concurso UVM\nEl objetivo principal del concurso fue la promoción de este tipo de eventos y descubrir posibles talentos.\nLos resultados fueron:\n1\nHector Jauregui Acevedo\n285\n2\nEduardo Velez Santiago\n205\n3\nLuis Abraham\n205\n4\nEduardo\n200\n5\nLuis Mario\n200\n6\nvase920814\n200\n7\nLuis Alfonso Vélez Saldivar\n169\n8\nLisette Paulina Lozano Gómez\n100\n9\nIván Acevez\n100\n10\nfragalfernando\n100\n11\nJosé Miguel Ramos Reyes\n100\n12\nCarlos Omar Haro Cordero\n0"},"title":"OmegaUp apoya al 1er Concurso de programación UVM"},"/posts/omegaup-inc/":{"data":{"":"Durante más de 5 años omegaUp ha sido un proyecto de medio tiempo para nosotros. Escribir nuevas funcionalidades es difícil ya que todos tenemos otras responsabilidades de tiempo completo. Así que hace 7 meses comenzamos a considerar la opción de formalizar nuestro proyecto y convertirnos en una organización establecida legamente, que nos permitiera recibir ingresos y contratar a desarrolladores que se dedicaran de tiempo completo a diseñar y mantener la plataforma.\nEsta fue la primera reunión que tuvimos al respecto, donde analizamos las ventajas y desventajas de incorporarnos. A lo largo de los meses siguientes trabajamos revisando requerimientos legales, escribiendo nuestros by-laws y en general, estableciendo las bases de lo que sería OmegaUp como una entidad legal. Decidimos que una organización sin fines de lucro en Estados Unidos era lo más apropiado, tanto por la naturaleza de lo que hacemos, así como por nuestra ubicación física.\nDespués de mucho trabajo, el 7 de octubre del 2016 recibimos la confirmación por parte del IRS de que nuestra organización es exenta del impuesto federal bajo el IRC sección 501(c)(3). Esto significa que OmegaUp es reconocida como una caridad publica a nivel estatal y federal y por ende todos sus donantes pueden deducir de sus impuestos las contribuciones que hagan a OmegaUp. También nos califica para recibir legados, transferencias o regalos.\nComo parte del proceso de incorporación, se formó un comité directivo cuya responsabilidad será la de mantener la salud, preservación y progreso de esta organización. Cada uno de los miembros del comité directivo representara los intereses de los donantes y de la gente beneficiada con este proyecto.\nMás información sobre la organizacion puede encontrarse en http://omegaup.org"},"title":"OmegaUp Inc"},"/posts/omegaup-presentado-en-la-international-olympiad-in-informatics-2014/":{"data":{"":" Del 13 al 18 de Julio del 2014 se llevó a cabo la International Olympiad in Informatics (IOI) en Taipei, Taiwán. En paralelo a la IOI, el comité organiza la publicación de la revista IOI Journal donde los países participantes pueden publicar artículos sobre la olimpiada en general, tanto técnicos como reportes y explicaciones de cómo es la olimpiada alrededor del mundo. Dichas publicaciones se presentan durante la IOI, en la IOI Conference.\nEste año México participó en el IOI Journal Volumen 8 con la presentación del paper de omegaUp:\n**omegaUp: Cloud-Based Contest Management System and Training Platform in the Mexican Olympiad in Informatics L.H. CHÁVEZ, A. GONZÁLEZ, J. PONCE. **\nIOI Conf omegaUp El paper explica la motivación y el funcionamiento detrás de omegaUp. Es un buen documento introductorio para quienes deseen apoyar en el proyecto. También pone a omegaUp como pionero en el uso de la nube y seccomp-bpf para evaluadores de concursos en líneaEl resto de los papers publicados este año y en años pasados está aquí."},"title":"omegaUp presentado en la International Olympiad in Informatics 2014"},"/posts/panel-de-administracion-para-tus-problemas/":{"data":{"":"He visto que mucha gente sube problemas y luego hace un concurso de prueba para ver si sus soluciones funcionarían en tiempo y memoria. No más! A partir de hoy, si tú subiste un problema o te dieron permisos de administrador para él, puedes abrirlo desde Mis problemas y te mostrará todos los envíos (de todos los usuarios) y las clarificaciones que han hecho. Disfruten!"},"title":"Panel de administración para tus problemas"},"/posts/practicando-para-la-omi-en-omegaup/":{"data":{"":"Si estás practicando para la Olimpiada Mexicana de Informática 2014, omegaUp tiene disponibles los exámenes nacionales desde el 2009 para que intentes resolverlos. Aquí están los enlaces a los concursos de práctica\nOMI 2009, día 1 (Karel) OMI 2009, día 2 (Lenguaje) OMI 2010, día 1 (Karel) OMI 2010, día 2, (Lenguaje) OMI 2011, día 1 (Karel) OMI 2011, día 2 (Lenguaje) OMI 2012, día 1 (Karel) OMI 2012, día 2 (Lenguaje) OMI 2013, día 1 (Karel) OMI 2013, día 2 (Lenguaje) Nuevamente agradecemos a Kuko Lopez de la OIEG por ayudarnos a subir los problemas del 2009 al 2011.\nQue se diviertan!"},"title":"Practicando para la OMI en omegaUp"},"/posts/preselectivo-ioi-2015-inicio/":{"data":{"cómo-prepararse#Cómo prepararse?":" OMI Esta semana iniciamos el preselectivo rumbo a la International Olympiad in Informatics 2015. 36 ganadores de la Olimpiada Mexicana de Informática 2014 van a participar en este proceso y pelearán por un lugar para representar a México. Este fue el mensaje de bienvenida:\nEstimados olímpicos, líderes y delegados,\nEspero que se encuentran muy bien. Los felicito por sus buenos resultados en la OMI y les doy la bienvenida al Proceso de selección para la IOI 2015 a celebrarse en Astana, Kazakhstan. Este año, los 35 mejores concursantes de la OMI pasada van a pelear un lugar entre los 4 representantes de México en la IOI.\nLa Etapa 1 del preselectivo consistirá de prácticas y exámenes en línea que iniciarán el 13 de Junio. A partir de esa semana, se publicarán 2 problemas de práctica por tema y tendrán una semana para resolverlos al 100%. Cada tema abarcará 2 semanas, usualmente la primer semana publicaremos problemas introductorios y la segunda semana serán problemas más retadores. Cada dos temas, es decir, aproximadamente cada mes, habrá un examen que cubrirá los temas ya vistos. Cada problema de práctica resuelto por completo en el periodo asignado (1 semana) valdrá 100 puntos y los exámenes valdrán 300 puntos. La agenda con los temas y fechas de publicación se encuentra aquí.\nLos 20 alumnos con más puntos calificarán a la Etapa 2. La Etapa 2 iniciará con un entrenamiento presencial en el mes de Noviembre en un lugar por definir.\nCómo prepararse?Es importante darse cuenta que están por entrar a un proceso de entrenamiento que requiere de mucha disciplina, concentración, dedicación y una inversión considerable de tiempo. Al final representarán a México a nivel internacional y nuestras expectativas sobre sus resultados son muy altas. No hay diferencia entre la preparación que ustedes van a llevar a cabo y la que usualmente lleva un atleta de alto rendimiento. A partir de este momento deben de ser muy vigilantes y conscientes de cómo invierten su tiempo día a día si quieren llegar lejos en la competencia, particularmente para quienes compiten por primera vez. No simplemente se trata de pasársela resolviendo mil problemas sencillos o parecidos, sino que hay que practicar de forma deliberada e inteligente para desarrollar talento. Sin más, lo mínimo esperado de la Etapa 1 es que dominen por completo los contenidos del libro Problemas y Algoritmos de Luis Vargas. Les recomiendo que no esperen a que inicien los exámenes para empezar a leerlo puesto que las prácticas no van a dejar de fluir de Junio a Octubre. También es **crucial que revisen la recapitulación del selectivo de la IOI 2014. **En ese post encontrarán lecturas recomendadas para cada uno de los temas y otros sitios para practicar.\nEl proceso de la Etapa 1 está diseñado para consumir 10 horas de su tiempo a la semana, asumiendo que no dominan los temas por ver. Nosotros pensamos una distribución adecuada el tiempo es: 3 horas de lectura de material, 4 horas entrenando con los ejercicios del material o las prácticas del año pasado y 3 horas resolviendo los problemas de práctica de este año. En una encuesta realizada a los participantes del año pasado, el promedio de horas que invirtieron a la semana fueron precisamente 10. Sin embargo, cuando les preguntamos cuántas horas más creen ellos que le pudieron haber dedicado al proceso a la semana, después de conocer sus resultados, contestaron que otras 10 en promedio :).\nAl final del camino encontrarán grandes recompensas, desde la satisfacción personal al verse como de los mejores del país, el orgullo de representar a México internacionalmente y también les abrirá las puertas para ser considerados por las mejores universidades del mundo para estudiar y por las mejores empresas de software para trabajar (Google, Microsoft, Facebook, Amazon, Intel…). También varias startups interesantes han salido de ex-finalistas del proceso de preselección.\nPara los alumnos que es su primer año compitiendo: No se desanimen al competir con otros que llevan varios años participando. En muchas de las IOIs pasadas hemos tenido el caso donde alguien que compite por primera vez le gana un lugar en la selección a alguien que fue a la IOI anterior, simplemente por que se preparó mejor.\nPara los alumnos que repiten: probablemente ya manejen con fluidez el nivel de los temas que vemos en la Etapa 1. No quiere decir que los menosprecien :). Repásenlos con cuidado. Sin embargo, tampoco quiere decir que aflojen su preparación. Propónganse retos grandes, como subir a Gold en la USACO, llegar a rojo en TopCoder/Codeforces, resolver todos los problemas de las IOIs pasadas, terminar el Cormen, etc.\nSin más por el momento, les deseo mucha suerte en este proceso de preselección. Cualquier duda, por favor contáctenme respondiendo este correo. Saludos! -Joe"},"title":"Preselectivo IOI 2015 - Inicio"},"/posts/privacy-policy/":{"data":{"":"","#":"This Privacy Policy governs the manner in which OmegaUp collects, uses, maintains and discloses information collected from users (each, a “User”) of the https://www.omegaup.com website (“Site”).\nPersonal identification information We may collect personal identification information from Users in a variety of ways, including, but not limited to, when Users visit our site, register on the site, fill out a form, and in connection with other activities, services, features or resources we make available on our Site.Users may be asked for, as appropriate, name, email address. Users may, however, visit our Site anonymously. We will collect personal identification information from Users only if they voluntarily submit such information to us. Users can always refuse to supply personally identification information, except that it may prevent them from engaging in certain Site related activities.\nNon-personal identification information We may collect non-personal identification information about Users whenever they interact with our Site. Non-personal identification information may include the browser name, the type of computer and technical information about Users means of connection to our Site, such as the operating system and the Internet service providers utilized and other similar information.\nWeb browser cookies Our Site may use “cookies” to enhance User experience. User’s web browser places cookies on their hard drive for record-keeping purposes and sometimes to track information about them. User may choose to set their web browser to refuse cookies, or to alert you when cookies are being sent. If they do so, note that some parts of the Site may not function properly.\nHow we use collected information OmegaUp may collect and use Users personal information for the following purposes:\n_To run and operate our Site_We may need your information display content on the Site correctly. _To improve customer service_Information you provide helps us respond to your customer service requests and support needs more efficiently. _To personalize user experience_We may use information in the aggregate to understand how our Users as a group use the services and resources provided on our Site. _To improve our Site_We may use feedback you provide to improve our products and services. _To send periodic emails_We may use the email address to send User information and updates pertaining to their order. It may also be used to respond to their inquiries, questions, and/or other requests. How we protect your information We adopt appropriate data collection, storage and processing practices and security measures to protect against unauthorized access, alteration, disclosure or destruction of your personal information, username, password, transaction information and data stored on our Site.\nSharing your personal information We do not sell, trade, or rent Users personal identification information to others. We may share generic aggregated demographic information not linked to any personal identification information regarding visitors and users with our business partners, trusted affiliates and advertisers for the purposes outlined above.\nThird party websites Users may find advertising or other content on our Site that link to the sites and services of our partners, suppliers, advertisers, sponsors, licencors and other third parties. We do not control the content or links that appear on these sites and are not responsible for the practices employed by websites linked to or from our Site. In addition, these sites or services, including their content and links, may be constantly changing. These sites and services may have their own privacy policies and customer service policies. Browsing and interaction on any other website, including websites which have a link to our Site, is subject to that website’s own terms and policies.\nChanges to this privacy policy OmegaUp has the discretion to update this privacy policy at any time. When we do, we will post a notification on the main page of our Site, revise the updated date at the bottom of this page. We encourage Users to frequently check this page for any changes to stay informed about how we are helping to protect the personal information we collect. You acknowledge and agree that it is your responsibility to review this privacy policy periodically and become aware of modifications.\nYour acceptance of these terms By using this Site, you signify your acceptance of this policy. If you do not agree to this policy, please do not use our Site. Your continued use of the Site following the posting of changes to this policy will be deemed your acceptance of those changes. Privacy policy created by GeneratePrivacyPolicy.com\nContacting us If you have any questions about this Privacy Policy, the practices of this site, or your dealings with this site, please contact us.\nThis document was last updated on June 05, 2015"},"title":"Privacy Policy"},"/posts/quedate-en-casa-con-omegaup-nuestra-respuesta-al-covid-19/":{"data":{"":"","#":"Querida comunidad omegaUp: La epidemia del COVID-19 ha causado cambios importantes en nuestra vida diaria, trabajo, escuela y familia. Para ayudar a manejar el Distanciamiento Social a toda nuestra comunidad, hemos creado la campaña Quédate en casa con omegaUp: una serie de iniciativas educacionales en línea para apoyar la continuidad de la educación tecnológica en Latinoamérica.\n1. Tutoriales para Profesores: ¿Cómo usar omegaUp para dar clases de programación en línea? omegaUp.com es una plataforma gratuita en Español que ayuda a estudiantes a mejorar sus habilidades en Ingeniería de Software resolviendo retos de programación de una forma divertida y competitiva. Profesores de más de 100 escuelas de nivel Medio Superior y Superior en México y Latinoamérica usan la plataforma para dejar tareas y exámenes con retos de programación que los alumnos pueden resolver en línea.\nTe invitamos a ver nuestros video-tutoriales para saber cómo funciona la plataforma de omegaUp y cómo puedes usarla para administrar tus cursos de programación en línea. Aquí dejamos el primer tutorial, en los próximos días produciremos más tutoriales que publicaremos en nuestra página de Facebook:\nhttps://www.youtube.com/watch?v=NgaYc9eYBbo\n2. Para estudiantes: Ciclo de Conferencias en línea vía Facebook Live Experiencias de Carrera es uno de los programas sociales de omegaUp que busca conectar el talento latinoamericano con experiencia en la industria de la Ingeniería de Software con estudiantes para motivarlos a continuar en el ramo de las Ciencias Computacionales y compartir la experiencia de trabajar en compañías como Google, Microsoft, Facebook entre otras.\nUsualmente omegaUp organiza estas pláticas para las instituciones reconocidas como La Escuela del Mes y Clubes de Programación omegaUp. Sin embargo durante Marzo y Abril abriremos el ciclo de conferencias a todos los estudiantes que deseen entrar a través de Facebook Live. Síguenos en nuestra página de Facebook para que te enteres de las fechas y no te pierdas a ninguno de nuestros excelentes ponentes.\n3. Para estudiantes: Aprende a programar en C++ con omegaUp - curso en línea En omegaUp estamos preparando un curso en línea gratuito y abierto al público en general para aprender a programar en C++ en línea, con omegaUp. El curso estará basado en el material de Introducción a C++ que tenemos disponible en la plataforma de omegaUp.\nEste curso será una excelente oportunidad para alumnos de nivel Medio Superior y Superior que deseen ampliar sus conocimientos de Ingeniería de Software, o todos aquellos simplemente empezar a incursionar en el amplio mundo de las Ciencias Computacionales.\nSíguenos en nuestra página de Facebook para conocer los horarios y más detalles sobre el curso.\n4. Liga de Programación omegaUp ¿Estás interesado en el mundo de la programación competitiva? omegaUp organizará la 1er Liga de Programación omegaUp, una serie de concursos semanales abiertos al público en general con temas y niveles de dificultad variados, empezando el próximo Jueves 26 de Marzo.\nDemuestra tus habilidades de resolución de problemas computacionales y mejora tu nivel compitiendo contra los mejores. Para más detalles sobre las bases, registro, premios y fechas consulta nuestra página de Facebook.\n5. Para nuestros amigos en Centroamérica: 1er Copa Centroamericana de Programación En omegaUp también estamos organizando la 1er Copa Centroamericana de Programación, una competición dirigida a nuestra comunidad de El Salvador, Honduras y Guatemala. El concurso se llevará a cabo el Sábado 25 de Abril. Para mayor información sobre los requisitos y registro te invitamos a leer nuestras bases aquí.\nEn estos momentos difíciles es cuando más creemos que podemos contribuir a la causa educacional. Por favor ayúdanos a compartir este mensaje con el hashtag #QuédateEnCasaConOmegaUp. Estamos en contacto y por favor cuiden de su salud y la de sus familiares manteniéndose en casa.\nJoe Ponce Director Ejecutivo, omegaUp"},"title":"Quédate en casa con omegaUp - nuestra respuesta al COVID-19"},"/posts/ranking-contribuidores/":{"data":{"":"En omegaUp queremos reconocer a todas las personas que usan la plataforma. En este artículo describiremos el “Ranking de contribuidores”, que busca distinguir a contribuidores que han publicado buenos problemas en omegaup.com. La métrica para cada usuario, llamada author_score, es calculada a través de la siguiente fórmula:\n$$author_score = sum(problem-quality).$$\nEn resumidas cuentas, la puntuación de contribuidor de cada persona, será igual a la suma de los puntos de calidad de cada uno de sus problemas. Estos puntos de calidad son los calculados a través del feedback de calidad que deja cada usuario cuando califica los problemas que resolvió o intentó resolver."},"title":"Ranking de contribuidores"},"/posts/ranking-de-contribuidores-de-omegaup/":{"data":{"actualizaciones-continuas#Actualizaciones Continuas":"En omegaUp, reconocemos y valoramos el impacto positivo de aquellos que contribuyen al desarrollo de nuestra plataforma. Presentamos con entusiasmo nuestro renovado sistema de clasificación, diseñado para destacar la dedicación y habilidades de aquellos que han ayudado a dar forma a omegaUp, ya sea creando desafiantes problemas de programación o contribuyendo de diversas formas.\nEn esta ocasión anunciamos el nuevo ranking de nuestros contribuidores más activos del mes en omegaUp:\n¿Cómo funciona?Para evaluar la contribución de cada usuario, hemos introducido una nueva métrica llamada author_score. Esta métrica se calcula utilizando una fórmula específica, author_score = sum(problem_quality).\nEn esencia, el author_score de cada usuario es igual a la suma de los puntos de calidad de los problemas que ha creado. Estos puntos de calidad se determinan a partir del feedback recibido por los problemas, que proviene de las evaluaciones realizadas por otros usuarios cuando resuelven o intentan resolver los desafíos.\nLa calidad de un problema se determina a través del feedback proporcionado por la comunidad. Cuando un usuario resuelve o intenta resolver un problema, tiene la oportunidad de dejar comentarios sobre su calidad. Estos comentarios se tienen en cuenta al calcular el author_score del creador del problema.\nActualizaciones ContinuasEn omegaUp, estamos comprometidos con la mejora constante. Realizaremos actualizaciones regulares para garantizar que el sistema de clasificación sea justo, desafiante y represente con precisión el talento de nuestra creciente comunidad de contribuidores.\nSumérgete en la competencia, desafía tus límites y eleva tu posición en el nuevo ranking de contribuidores de omegaUp. Celebremos juntos el espíritu de la programación y el aprendizaje continuo. ¿Estás listo para destacar?","cómo-funciona#¿Cómo funciona?":""},"title":"El nuevo ranking de contribuidores de omegaUp"},"/posts/ranking-de-escuelas-en-omegaup/":{"data":{"cómo-funciona#¿Cómo funciona?":"","cómo-registro-mi-escuela#¿Cómo registro mi escuela?":"","sugerencias#¿Sugerencias?":"Uno de los principales enfoques de nuestro equipo este 2017 ha sido facilitar el uso de omegaUp en las escuelas. Previamente anunciamos el lanzamiento de omegaUp Escuelas, un conjunto de funcionalidades que ayuda a los profesores a administrar cursos dentro de la plataforma y crear tareas y exámenes.\nEn esta ocasión anunciamos el nuevo ranking de escuelas más activas del mes en omegaUp:\n¿Cómo funciona?La intención del ranking de escuelas es fomentar la participación activa de las escuelas en omegaUp. Para el mes en turno, calculamos el número de usuarios activos y problemas distintos resueltos de cada escuela. El ranking colocará a la escuela con mayor número de usuarios activos en el primer lugar y el número de problemas distintos resueltos se usará como criterio de desempate.\nUn usuario activo es aquel que ha resuelto al menos un problema completamente (AC) y el número de problemas resueltos es el total de problemas distintos que colectivamente han resuelto (AC) todos los usuarios registrados con una escuela.\nEl ranking se calcula una vez al día, los cambios en usuarios activos y problemas resueltos se verán reflejados al día siguiente. Recuerda que ambos números se calculan sólo para el mes en turno: todos los contadores de este ranking se reinician a principio de cada mes.\n¿Cómo registro mi escuela?Lo único que tienes que hacer para que tu escuela sea considerada para el ranking de escuelas de omegaUp es asegurarte de llenar correctamente tu Escuela en tu perfil de omegaUp. Para construir el ranking usamos la información del perfil de todos los usuarios de la plataforma.\nAsegúrate de usar el mismo nombre de escuela que todos tus demás compañeros. Por ejemplo: ESCOM y Escuela Superior de Cómputo son considerados como diferentes nombres aunque se refieran a la misma escuela.\n¿Sugerencias?Si tienes comentarios o sugerencias sobre esta y otras funcionalidades de omegaUp déjanos tus comentarios en este post. ¿Te gustaría ayudarnos a mejorar la plataforma? ¡Contáctanos en hello@omegaup.org!"},"title":"Ranking de Escuelas en omegaUp"},"/posts/reclutamiento-ingenieria/":{"data":{"quieres-contribuir-al-equipo-de-ingeniería-de-software-de-omegaup#¿Quieres Contribuir al Equipo de Ingeniería de Software de omegaUp?":"¿Quieres Contribuir al Equipo de Ingeniería de Software de omegaUp?Si te apasiona la programación y buscas un proyecto desafiante donde aplicar tus habilidades, omegaUp te ofrece la oportunidad de contribuir al desarrollo de nuestra plataforma educativa. Buscamos personas motivadas y dispuestas a invertir tiempo y esfuerzo en aprender y crecer con nosotros.\n¿Qué es omegaUp?\nomegaUp es una plataforma en línea que ofrece desafíos de programación y aprendizaje para estudiantes de todos los niveles. Nuestra misión es fomentar el desarrollo de habilidades tecnológicas.\n¿Qué Buscamos?\nBuscamos personas con iniciativa y compromiso que deseen contribuir con su talento al desarrollo de nuestra plataforma. La participación en el equipo de ingeniería de omegaUp requiere dedicación y la voluntad de aprender y adaptarse a nuestros procesos. Estamos abiertos a colaborar con personas en cualquier etapa de su carrera profesional en ingeniería de software, desde estudiantes de los primeros semestres hasta profesionistas con años de experiencia.\nEl Proceso de Incorporación:\nHemos establecido un programa de entrenamiento para nuevos voluntarios. Este programa requiere que los candidatos exploren los siguientes recursos y demuestren su capacidad para contribuir:\nDocumentación: La documentación de nuestro código y proceso de desarrollo está disponible en nuestro wiki de GitHub. Este es el punto de partida para cualquier persona interesada. Videotutorial: Un videotutorial sobre cómo instalar el entorno de desarrollo local está disponible aquí. Canal de Discord: El canal #dev_training en nuestro servidor de Discord ofrece un espacio para consultas técnicas. Se puede escribir en inglés o español. “Good First Issues”: Una lista de tareas introductorias está disponible en GitHub: “Good first issues”. “Good Second Issues”: Para aquellos que ya tienen experiencia, hay una lista de tareas más desafiantes: “Good second issues”. El Entrenamiento:\nEl entrenamiento está abierto a cualquier persona que desee participar. No es necesario solicitar permiso.\n¿Cómo Unirse al Equipo?\nPara ser considerado miembro del equipo de ingeniería, se requiere haber revisado la documentación y resuelto 5 “Good first issues” + 5 “Good second issues”. Una vez alcanzado este nivel, los candidatos serán contactados y, si lo desean, se les proporcionará una cuenta de correo @omegaup.com.\n¿Interesado?\nSi estás dispuesto a invertir el tiempo y el esfuerzo necesarios, explora los recursos mencionados y comienza a trabajar. El equipo de omegaUp valora la iniciativa y el compromiso."},"title":"reclutamiento-ingenieria"},"/posts/reglas-del-coder-del-mes/":{"data":{"":"","#":"El reconocimiento del Coder del Mes en omegaUp se hizo con el objetivo de reconocer a coders activos en la plataforma. A continuación listamos las reglas del programa.\nExisten dos programas de Coder del Mes: Coder del Mes para Ellas y Coder del Mes General. Cada inicio de mes se publicarán los ganadores de los dos programas de Coder del Mes. La ganadora del Coder del Mes para Ellas será elegida entre las usuarias que se han identificado con el género femenino en su perfil. El Coder del Mes general no hará distinción de género. Las personas ganadoras serán publicadas en la página principal de omegaUp.com durante el mes correspondiente. La persona con el mayor puntaje acumulado durante el mes resolviendo problemas con distintivo de calidad* será el ganador del Coder del Mes General. La usuaria con el mayor puntaje acumulado durante el mes resolviendo problemas con distintivo de calidad* será la ganadora del Coder del Mes para Ellas. Debes seguir el Código de Conducta de omegaUp. Es posible que se haga una publicación en redes sociales felicitando a los ganadores. Esto dependerá de los recursos disponibles de omegaUp. Dicha publicación incluye compartir información como el alias del usuario y el nombre del usuario. Los administradores de los programas tienen el derecho de determinar la honestidad de los usuarios en sus soluciones utilizando diferentes métodos y descalificar al usuario si se encuentran violaciones. Cualquier violación a estas reglas dará lugar a disposiciones de penalización, incluyendo descalificación al Rank General o a los programas de Coder del Mes. *Los problemas con distintivo de calidad son aquellos que muestran EN el título del problema el siguiente icono: Dicho distintivo es asignado por el departamento de Educación de omegaUp. omegaUp se reserva el derecho de declarar vacío el reconocimiento de ambos programas de Coder del Mes en cualquier momento. Así como de modificar en cualquier momento cualquiera de los puntos anteriores con o sin previo aviso."},"title":"Reglas del Coder del Mes"},"/posts/reporte-de-actividades-2019/":{"data":{"por-favor-únete-a-nuestra-causa-haciendo-tu-donación-hoy-httpsomegauporgdonatehttpsomegauporgdonate#\u003cstrong\u003ePor favor únete a nuestra causa haciendo tu donación hoy: \u003ca href=\"https://omegaup.org/#donate\"\u003ehttps://omegaup.org/#donate\u003c/a\u003e\u003c/strong\u003e":" “Yo sí creo que omegaUp me ayudó a llegar aquí [Microsoft], porque fue la primera plataforma que usé, y por bastante tiempo, para aprender las bases; y eso realmente cambió el destino de mi vida y para dónde fue mi camino” - Elsy Pinzón, Software Engineer en Microsoft de Yucatán, México.\nQueridos amigos,Cuando escribimos la primer línea de código de omegaUp.com 8 años atrás, estábamos cambiando la industria del software en México, pero no lo sabíamos aún. El 2019 marcó el tercer año de operaciones desde que omegaUp se convirtió en una asociación sin fines de lucro ( registro 501(c)(3) en Estados Unidos) con la misión de construir el camino del mejor talento en Ingeniería de Software en América Latina, ofreciendo una plataforma de aprendizaje accesible y programas sociales.\nEstamos convencidos que el idioma no debe ser una barrera de entrada a la industria de la Ingeniería de Software: es por eso que creamos omegaUp.com, una plataforma gratuita online con contenido en Español donde los estudiantes pueden mejorar sus habilidades de programación resolviendo retos. Creemos en el rol fundamental que los profesores tienen en la educación de sus alumnos: es por eso que creamos herramientas en omegaUp para que los profesores administren sus cursos de programación, tareas y organicen exámenes.\nomegaUp.com\nGracias a la generosidad de ustedes, nuestros donadores, en 2019 pudimos ofrecer un servicio gratuito en omegaUp.com a 22,689 usuarios que resolvieron al menos 1 reto, 88% de ellos de México. En total nuestros usuarios resolvieron 189,151 retos. omegaUp se usa en más de 200 Preparatorias y Universidades, haciéndolo una herramienta de vital importancia en la educación de Ciencias Computacionales de muchos estudiantes. Sólo hay una forma de que una plataforma online pueda ser tan popular sin un presupuesto de promoción: simplemente hace el trabajo de los profesores y estudiantes más fácil.\nLuis Héctor Chávez, CTO de omegaUp (atrás) y Juan Pablo Gómez, Software Engineer en omegaUp (right) ayudando a más contribuidores de Open Source en el CCOSS 2019.\nNuestros programas sociales van dirigidos a inspirar talento promocionando las carreras exitosas de la comunidad latinoamericana en la Ingeniería de Software. Este año empezamos Historias omegaUp, una serie de entrevistas con Ingenieros de Software de Microsoft y Facebook que aprendieron a programar en omegaUp.com.\nEsperamos que estas historias ayuden a inspirar más talento en Latinoamerica validando el valor de nuestra comunidad en la industria.\nCon nuestro programa Experiencias de Carrera, organizamos 8 videoconferencias, conectando más de 2000 estudiantes con el talento de la industria que trabaja en compañías como Amazon, DigitalOnUs, Microsoft y Oracle. Estudiantes de escuelas como el Colegio de Bachilleres Tecnológico Agropecuario (CBTa #39) en Temoac, Morelos, CONALEP 252 en Veracruz, la Universidad de Guanajuato, México, tuvieron la oportunidad de escuchar experiencias y recomendaciones de talento latinoamericano actualmente trabajando en la industria.\nSalvador Segura (Director de Business Programs en Microsoft) platicando con alumnos del CONALEP 252 en Veracruz, México\nLanzamos Clubes de Programación omegaUp, un programa piloto que tiene como objetivo apoyar grupos estudiantiles y clubes de programación con recursos que maximicen su impacto. Estamos trabajando muy de cerca con la Universidad Autónoma de Chihuahua y el Colegio de Bachilleres de Chihuahua. Además, cada mes premiamos al mejor estudiante de omegaUp con nuestro programa de Coder del Mes.\nMiguel Romero, Director de Programas en omegaUp (centro) con alumnos del Colegio de Bachilleres de Chihuahua, México\nUno de los retos más cruciales que enfrentamos como industria es la diversidad de género. Sólo el 26% de los usuarios de omegaUp son mujeres. Este número no está nada cerca de donde quisiéramos que esté, y como una plataforma educativa de alto impacto reconocemos nuestra responsabilidad social para ayudar con este problema. Estamos comprometidos a ayudar a cerrar la brecha existente incentivando y apoyando esfuerzos de diversidad de género a través de los Clubes de Programación registrados en nuestro programa, donde es un objetivo mutuo incrementar la participación femenina en las actividades del club. Nuestros logros no podrían ser posibles sin el tremendo esfuerzo y pasión de nuestros 23 voluntarios distribuidos en Estados Unidos, México y Perú. A todos ellos, muchas gracias por su fantástico compromiso e incansable labor en cumplimiento de la misión de omegaUp.\nVoluntarios de omegaUp en el área de Seattle, WA\nVoluntarios de omegaUp en México y Silicon Valley\nTodos estos resultados fueron obtenidos con un presupuesto operativo de tan sólo $62,247 dólares de los cuales 71% se usaron para nuestros programas sociales: omegaUp.com, Experiencias de Carrera, Coders del Mes y Clubes de Programación. Invertimos 17% en nuestros esfuerzos de recaudación de fondo como la 1ra Gala Anual “The Aztec Coders” celebrada in Bellevue, WA, USA, donde gracias a la generosidad de nuestros donantes conseguimos $30,785 dólares en donaciones equivalentes al 49% de nuestro presupuesto anual.\nomegaUp 1st Annual Gala 2018: The Aztec Coders\nTu apoyo inspira talento. Juntos podemos contribuir a crear una industria de Ingeniería de Software más diversa empoderando a nuestra comunidad Latinoamericana. Por favor únete a nuestra causa haciendo tu donación hoy: https://omegaup.org/#donate Invitación a la Gala Anual de Recaudación de Fondos - Coding Latam. Octubre 19, Bellevue, WA, USA\nGracias por toda su ayuda.\nJoemmanuel Ponce CEO, omegaUp","queridos-amigos#\u003cstrong\u003eQueridos amigos,\u003c/strong\u003e":"","tu-apoyo-inspira-talento-juntos-podemos-contribuir-a-crear-una-industria-de-ingeniería-de-software-más-diversa-empoderando-a-nuestra-comunidad-latinoamericana#\u003cstrong\u003eTu apoyo inspira talento. Juntos podemos contribuir a crear una industria de Ingeniería de Software más diversa empoderando a nuestra comunidad Latinoamericana.\u003c/strong\u003e":""},"title":"Reporte anual de actividades 2019"},"/posts/resolviendo-problemas-con-un-limite-bajo-de-memoria/":{"data":{"":"Gracias @Rodrigo-RCC por este aporte!\nEl límite de memoria de un problema puede cambiar drásticamente la forma en la que podemos resolverlo. Por ejemplo, el problema https://omegaup.com/arena/problem/La-especie-dominante-en-marte nos pide encontrar el número que más se repite en una secuencia, si además sabemos que ese número aparece al menos más de la mitad de las veces. Si estamos usando C++ y conocemos relativamente bien la biblioteca estándar del lenguaje, nuestro primer intento sería algo así:\n#include \u003ciostream\u003e #include \u003cmap\u003e int main( ) { std::map\u003cint, int\u003e frecuencias; for (int n; std::cin \u003e\u003e n;) { frecuencias\\[n\\] += 1; } // revisar qué valor apareció más e imprimirlo } Si enviamos el código anterior, nos llevaremos la desagradable sorpresa de obtener \\`MLE\\` (memoria límite excedida). Aunque esta publicación no tiene por objetivo explicar cómo se resuelve el problema, sí podemos mencionar que lo adecuado es un \\*algoritmo de streaming\\* que surgió en el área de lo que ahora se conoce como \\*Big Data\\*. Entonces, el límite bajo de memoria es un intento de obligar al usuario a deducir dicho algoritmo, el cual usa únicamente tres variables enteras. Desafortunadamente, incluso el siguiente código... ```cpp #include \u003ciostream\u003e int main( ) { // leer la entrada y no hacer nada con ella // no nos sabemos el algoritmo y tenemos poca memoria :( for (int n; std::cin \u003e\u003e n;) { continue; } } ¡También supera la memoria límite del problema! Un usuario podría pensar (equivocadamente) que entonces el problema es imposible de resolver. Para evitar esta confusión, los usuarios de la plataforma deben tomar en cuenta lo siguiente: \\- Existe un único límite de memoria por problema, el cual es independiente del lenguaje de programación usado. En el problema descrito previamente, el autor no quiso aumentar artificialmente el límite de memoria sólo para aceptar envíos en todos los lenguajes, porque eso implicaría que alguien que use un lenguaje eficiente podría idear un algoritmo que no era el que el autor quería permitir. Entonces, es verdad que algunos problemas no se pueden resolver en ciertos lenguajes de programación, pero el autor debería garantizar que el problema se puede resolver de forma razonable en por lo menos un lenguaje de programación (de preferencia C y C++). - La biblioteca \\`\u003ciostream\u003e\\` de C++ consume mucha más memoria de la que uno podría imaginar inicialmente. Esto se puede verificar resolviendo un problema de \"Hola Mundo\" usando \\`\u003ciostream\u003e\\` y luego comparándolo con uno que sólo usa \\`\u003cstdio.h\u003e\\`. Peor aún, basta incluir \\`\u003ciostream\u003e\\` para que el consumo de memoria del programa aumente, ya que la inclusión de ese archivo al menos provoca que los objetos globales \\`std::cin\\` y \\`std::cout\\` se inicialicen. El siguiente código no calcula la respuesta correcta, pero al menos al menos no superará el límite de memoria :) ```cpp #include \u003cstdio.h\u003e int main( ) { // leer la entrada y no hacer nada con ella // no nos sabemos el algoritmo :( for (int n; scanf(\"%d\", \u0026n) == 1;) { continue; } } Esperamos que esta publicación les haya ayudado a tener una idea más cercana de cómo atacar cierto tipo de problemas inusuales y los invitamos a resolver el problema mencionado en el juez en línea. "},"title":"Resolviendo problemas con un límite bajo de memoria"},"/posts/retirando-c-a-favor-de-c11-a-finales-de-ano/":{"data":{"":"Para irse familiarizando con el lenguaje y las herramientas, asegúrense que tienen un IDE que contenga GCC versión 4.8 (o superior) y tenga la bandera -std=c++11. No deben haber problemas de compatibilidad, así que intenten mandar todos sus envíos de C++ en C++11 y háganos saber via Twitter o comentarios aquí si encuentran algún problema."},"title":"Retirando C++ a favor de C++11 a finales de año"},"/posts/revision-codigo-envios-cursos/":{"data":{"":"Nos complace anunciar la liberación de una nueva funcionalidad llamada “Revisión de código en envíos de cursos”. Esta herramienta permitirá a las personas organizadoras de cursos brindar retroalimentación directamente en el código enviado por sus estudiantes, agilizando así el proceso de revisión.","antecedentes#Antecedentes":"Anteriormente, en los cursos de omegaUp, solo se disponía de un campo general para escribir retroalimentación por cada envío realizado por la persona estudiante. Esto impedía que la persona organizadora contara con las herramientas necesarias para detallar adecuadamente los comentarios.\nAunque esta retroalimentación podía ser editada, al modificar el mensaje original, este ya no podía ser visualizado nuevamente.\nCon esta nueva funcionalidad, se busca que la persona organizadora tenga más opciones para proporcionar retroalimentación detallada en cada envío. Además, se ofrece la posibilidad de registrar una lista de personas que puedan colaborar en la importante tarea de revisión de código, fundamental en el desarrollo de software.","conclusión#Conclusión":"La nueva funcionalidad de revisión de código en omegaUp transforma la manera en que las personas organizadoras de cursos y asistentes de enseñanza pueden interactuar con las personas estudiantes. Al permitir una retroalimentación detallada y específica en el código, se mejora significativamente el proceso de aprendizaje y se facilita la comunicación efectiva entre todas las partes involucradas.\nEsta herramienta es especialmente valiosa para cursos en línea y para docentes con una gran carga de trabajo, ya que permite delegar la tarea de revisión sin perder el control sobre el contenido del curso.\nInvitamos a todas las personas organizadoras de cursos a aprovechar esta nueva funcionalidad y a experimentar de primera mano los beneficios de una retroalimentación más precisa y eficiente. ¡Empieza hoy mismo a mejorar la calidad de tus cursos con la revisión de código en omegaUp!","cómo-agregar-asistentes-de-enseñanza-en-un-curso#¿Cómo agregar asistentes de enseñanza en un curso?":"El proceso para agregar asistentes de enseñanza es similar al de agregar una persona administradora. Como se muestra en la imagen 1, lo primero que se debe hacer es ingresar a la vista de Editar curso en la sección de Cursos que administro:\nLuego, dirígete a la pestaña de Admins, donde podrás agregar cuentas individuales o, si lo prefieres, un grupo de cuentas:\nUna vez realizados estos pasos, todas las cuentas a las que se les haya asignado el rol de asistente de enseñanza podrán ingresar al curso y proporcionar retroalimentación a cualquier envío realizado por las personas estudiantes.\nLas personas con el rol de asistentes de enseñanza solo pueden ver los detalles del curso, pero no pueden editar nada, como se muestra en la siguiente imagen:","cómo-brindar-retroalimentación-como-organizador-del-curso-o-asistente-de-enseñanza#¿Cómo brindar retroalimentación como organizador del curso o asistente de enseñanza?":"Una vez que la persona organizadora del curso o el asistente de enseñanza reciben la notificación de que un estudiante ha solicitado retroalimentación en un envío, pueden proceder de la siguiente manera:\nIngresar al curso y a la tarea correspondiente. Seleccionar la pestaña de Envíos. Hacer clic en el botón de detalles del envío al que se dará retroalimentación. Estos envíos son fáciles de identificar, ya que muestran un globo indicando que tienen una solicitud de revisión, como se muestra a continuación: Al hacer clic en el botón de detalles del envío, será posible agregar comentarios de retroalimentación en las líneas de código donde la persona organizadora considere necesario. Estos comentarios ayudarán a la persona estudiante a comprender en qué puede mejorar su código. En la siguiente animación se muestra cómo realizar este proceso:\nEn este momento se abre la comunicación entre la persona estudiante y la persona organizadora del curso, ya que las personas estudiantes pueden interactuar en cada uno de los comentarios brindados por las personas organizadoras. En la siguiente imagen se muestra lo antes mencionado:","cómo-puedo-solicitar-retroalimentación-si-soy-estudiante#¿Cómo puedo solicitar retroalimentación si soy estudiante?":"El proceso para solicitar retroalimentación como estudiante es sencillo. Una vez que hayas ingresado a una actividad de un curso y realizado un envío a cualquiera de los problemas, encontrarás un botón en la tabla de envíos de dicho problema:\nAl hacer clic en el botón, se enviará una notificación a todas las personas organizadoras y asistentes de enseñanza del curso. Solo tendrás que esperar su retroalimentación.","definición-de-la-nueva-funcionalidad#Definición de la nueva funcionalidad":"Para entender cómo funcionarán las retroalimentaciones de código, es necesario comenzar explicando la creación de un nuevo rol dentro de los cursos en omegaUp.","rol-de-asistente-de-enseñanza#Rol de asistente de enseñanza":"Con la creación de la nueva funcionalidad, la tarea de revisión de código puede aumentar significativamente, al punto de que la persona organizadora del curso se vea abrumada cuando una gran cantidad de estudiantes soliciten retroalimentación en sus soluciones enviadas.\nLa primera alternativa para solucionar este problema es que la persona organizadora agregue más administradores al curso. Estos administradores tendrán los mismos privilegios que la persona organizadora, incluyendo la capacidad de realizar revisiones de código.\nEl principal inconveniente de esta solución es que todas las personas administradoras pueden modificar la configuración del curso, lo cual no es recomendable, ya que la persona organizadora podría perder el control sobre las tareas, fechas, listado de problemas, entre otras cosas.\nPor esta razón, se decidió crear un nuevo rol que permite a la persona organizadora agregar tantas personas como sea necesario con el perfil de asistentes de enseñanza dentro de un curso."},"title":"Revisión de código en envíos de cursos"},"/posts/se-realiza-la-1era-competencia-peruana-de-informatica-para-pre-universitarios/":{"data":{"":" 1ra Competencia Peruana de Informática Online\nEl pasado domingo 28 de mayo de 2017 se realizó la 1era Competencia Peruana de Informática Online (CPIO). Organizada por la Federación Olímpica Peruana de Informática (FOPI), la CPIO es la primera competencia en su tipo que convoca a alumnos pre-universitarios de todo el Perú para conformar la delegación peruana rumbo a la Competencia Iberoamericana de Informática y Computación (CIIC) 2017**.**\nFundada en diciembre de 2016 por Aldo Culquicondor, Edson Ticona, Jonathan Quispe, L. Rodolfo Nájera, Raúl Gallegos, Rodolfo Mercado y Yesica Aquino, la FOPI busca fomentar la informática competitiva pre-universitaria, apoyando a los niños y jóvenes peruanos a desarrollarse en este ámbito, preparando una delegación que represente al Perú y consolide logros internacionales.\nLa **CPIO **es una competencia multi-nivel de programación para jóvenes peruanos, con habilidades de resolución de problemas mediante el análisis, la lógica, el ingenio y la implementación de soluciones en un computador. El concurso realizado en omegaUp contó con la participación de competidores de las principales ciudades peruanas:Arequipa, Callao, Chepen, Cusco, Ica, Lima, Piura, Pucallpa, Puno y Tacna.\nAl ser la primera competencia de programación competitiva en el Perú, se espera que CPIO marque el inicio del desarrollo de la informática en los jóvenes peruanos y como consecuencia un mejor desarrollo tecnológico en aquel país sudamericano, mencionó Aldo P. Culquicondor Ruiz, presidente de la FOPI.\nLuego de la competencia, quedaron seleccionados ocho competidores para representar al Perú en la CIIC el próximo 10 de junio**:** Joaquin Rodrigo Palma Ugarte y Stheven Julmar Quispe Llamocca de Arequipa, Anthony Dante Yataco Torres y Nicolas Ticona Valdivia de Lima, Carlos Daniel Ramos Arellano de Piura, Johan Frank Cachicatari Ticona y Marcela Veronica Apaza Vilca de Puno y Roberto Carlos Huamán Rivera de Tacna.\nCon la realización de esta competencia, la organización sin fines de lucro omegaUp da un paso importante para cumplir su objetivo de aumentar el número de ingenieros de software talentosos en todos los confines de América Latina."},"title":"Se realiza la 1era Competencia Peruana de Informática Online en omegaUp"},"/posts/seguridad-ie-en-windows-xp/":{"data":{"":"","referencias#Referencias":"Debido a un reciente cambio para mejorar la seguridad de la conexión a omegaUp, hemos decidido dejar de soportar oficialmente IE en Windows XP, a pesar de que sabemos que aún sigue siendo el segundo sistema operativo más común a nivel mundial[1]. Si aún están obligados a usar Windows XP, por favor utilicen algún navegador moderno (Chrome, Firefox u Opera) o alguna versión portátil.\nPara los interesados, el cambio consistió en hacer un par de optimizaciones para nginx[2], para reducir el tiempo de espera al primer byte, y actualizar la configuración de TLS: se quitaron SSLv2 y SSLv3 (que ya se consideran inseguros), se agregaron TLSv1.1 y TLSv1.2, se eliminó RC4 como algoritmo de cifrado, y ahora se prefiere ECDHE como algoritmo de intercambio de llaves para proveer Perfect Forward Secrecy[3].\nReferencias Reporte NetMarketShare, Enero 2014 Optimizing NGINX TLS Time To First Byte (TTFB) - igvita.com Perfect Forward Secrecy - Wikipedia "},"title":"Seguridad: IE en Windows XP"},"/posts/solucion-a-alfiles/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 7 **Autor: **Hugo Dueñas\nLo primero que se debe de notar es que en cada una de las $latex 2n-1$ diagonales principales, las cuales mostradas en la imagen de abajo, habrá máximo 1 alfil. Lo mismo se cumple para las diagonales invertidas, mostradas también en una imagen abajo.\nAhora, cada diagonal principal se cruza con ciertas diagonales invertidas. Entonces se plantea una solución de tipo Backtracking que corre sobre las diagonales principales marcando diagonales invertidas a cada paso (representando que se ha colocado un alfil en el cruce de esas dos diagonales).\nUna implementación directa y sin optimizaciones ni podas para los casas donde $latex n = 8$ hará uso de $latex 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times7\\times6\\times5\\times4\\times3\\times2\\times1=203212800$ operaciones, lo cual no está muy lejos de ser una solución eficiente. Entonces bastan algunas podas para obtener una solución al 100%, podemos por ejemplo podar las ramas de la recursión que consideran combinaciones con una diagonal invertida repetida.\nA continación se lista una implementación en C++ de la solución:"},"title":"Solución a \"Alfiles\""},"/posts/solucion-a-bloqueo/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 8 Autor: Khayyam Fuente: Khayyam\nLa primera observación que hay que hacer es que si todas las carreteras son bidireccionales y entre cada par de ciudades existe exactamente un camino que las conecta (usando una o mas carreteras) entonces la representación gráfica del problema es un árbol: los nodos representan las ciudades y las aristas representan las carreteras. La siguiente figura, muestra el árbol que representa el caso de prueba dado como ejemplo. Los nodos rojos representan las ciudades ocupadas, el esfuerzo necesario para destruir cada carretera se muestra junto a la arista correspondiente. Entonces queremos eliminar un subconjunto de aristas de peso total mínimo de tal forma que los nodos rojos queden separados.\nCaso de ejemplo\nSolución\nEn problemas relacionados con árboles, es muy natural tratar de dividir el problema en problemas más pequeños que están dados por los sub-árboles del árbol original. Esto además sugiere usar recursión: “para resolver un árbol, primero resolvemos recursivamente sus sub-árboles y luego combinamos las sub-soluciones”.\nComencemos con los casos sencillos. Si hay solamente un nodo (el árbol tiene altura 0), entonces no habrá aristas y el esfuerzo total necesario es cero.\nConsideremos ahora un árbol de altura 1 como el de la siguiente figura. Como la raiz no es roja, basta con eliminar una de las dos aristas: elegimos la que requiera menos esfuerzo.\nCaso sencillo: altura 1\nSolución (suponemos que la arista izquierda requiere menos esfuerzo)\nSi la raiz fuera roja, entonces tendríamos que eliminar ambas aristas. Con lo anterior nos damos cuenta de que hay dos casos que debemos considerar:\nSi la raiz es roja, entonces debemos eliminar todas las aristas que la conectan con nodos rojos Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos: la solución óptima es dejar conectado el nodo rojo asociado a la arista mas costosa. Lo anterior se ilustra en la siguiente figura (aquí suponemos que la arista de la derecha es la mas costosa de todas):\nSi la raiz es roja, entonces debemos eliminar todas las aristas que la conectan con nodos rojos\nSi la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos\nAhora que tenemos la solución para los casos pequeños, veamos si podemos usar estas soluciones para construir la solución del problema general, como en la siguiente figura.\nSi la raiz es roja y el nodo blanco está conectado\na algun descendiente rojo, la solución ya no es correcta\nAún si la raiz es blanca, no podemos dejar conectado el nodo blanco\nya que si está conectado con un descendiente rojo, la solución sería incorrecta\nSupongamos que ya tenemos la solución para todos los hijos directos de la raíz, es decir, que ya cortamos de manera óptima las aristas de todos los subárboles, de modo que ningún par de nodos rojos se conectan en el sub-árbol. Usando sólo esta información, ¿podemos construir la solución del problema general?. Desafortunadamente, esto no es suficiente: nos gustaría dejar conectados a los hijos blancos, pero si existe un nodo rojo debajo de ellos, entonces tendríamos que desconectarlo también. Lo que necesitamos saber es precisamente si un hijo blanco está conectado con uno de sus descendientes rojos, de ser así diremos que el nodo blanco es “peligroso”. Si el nodo blanco está desconectado de todos sus descendientes rojos, entonces diremos que es “seguro”. Entonces tenemos tres tipos de nodos: ocupados, peligrosos y seguros, que representamos como nodos rojos, amarillos y verdes, respectivamente.Con este nuevo concepto, vemos que tenemos dos tipos de soluciones distintas para una raíz blanca: tenemos soluciones peligrosas y soluciones seguras. Es fácil ver que no existen “hojas peligrosas”, ya que las hojas están ocupadas (rojas) o son seguras (verdes).\nReformulemos nuestra solución con este concepto. Si la raíz es roja, entonces debemos desconectarla de todos sus hijos rojos y de todos sus hijos peligrosos. Esto significa que para cada hijo blanco tenemos dos opciones:\nHacer que el hijo sea seguro (verde) y no cortar la arista que lo une con la raíz (puede ser costoso hacerlo seguro, pero con eso nos ahorramos el costo de separarlo de la raíz) Hacer que el hijo sea peligroso (amarillo) y cortar la arista que lo une con la raíz (puede ser barato dejarlo inseguro, pero pagamos al separarlo de la raíz) Lo anterior resuelve el caso en que la raíz es roja.\nAhora, si la raíz no es roja, debemos calcular dos soluciones: la solución segura (dejar la raíz verde) y la solución peligrosa (dejar la raíz amarilla). Notemos que la solución segura es exactamente igual al caso anterior. Por otro lado, para la solución peligrosa, debemos dejar la raíz conectada a exactamente un hijo que sea rojo o peligroso. Para elegir cuál de todos los hijos rojos o peligrosos dejaremos conectado, basta iterar sobre todos los hijos y elegir la mejor opción. El código queda como sigue:"},"title":"Solución a \"Bloqueo\""},"/posts/solucion-a-cambio/":{"data":{"":"","solución-de-100-puntos#Solución de 100 puntos":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 7 **Autor: **Enrique Lira Vargas\nLo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.\nSolución de 30, 50 puntos Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.\nSolución de 100 puntos Consideremos la solución anterior y tratemos de calcularlo de abajo hacia arriba, habría que crear una función que nos dijera para una cantidad dada y un set de monedas que se pueden usar (para no repetir) nos diga cuantas formas distintas hay de completar dicha cantidad. Si se logra construir dicha función la solución al problema es simple puesto que se reduce a llamar dicha función con la cantidad que nos piden y el set completo de monedas. Lo interesante radica en cómo se compone dicha función, suponiendo que la función funciona hay que tratar de construirla, primero hay que considerar los casos especiales, si la cantidad es cero significa que no hay que hacer nada y entonces hay una forma de lograrlo (es una combinación válida), si la cantidad es mayor a cero hay que sumar las combinaciones de tomar una moneda de la primera denominación disponible con las de dejar de tomar monedas de dicha denominación.\nPara calcular las combinaciones de tomar una moneda de dicha denominación se puede usar la función a partir de la cantidad restante (la cantidad buscada menos la denominación de la moneda) y el mismo set de monedas.\nPara calcular las combinaciones de dejar de tomar monedas de cierta denominación de igual forma se puede usar la función con la misma cantidad pero con un set de monedas que no incluya la denominación que decidimos dejar de tomar.\nSi se toma la moneda sin considerar si la denominación es más grande que la cantidad entonces existe el caso donde la cantidad es negativa y en ese caso la respuesta debiera ser cero puesto que es una combinación no válida.\nDe igual forma si el set de denominaciones disponibles está vacío significa que ya no hay más denominaciones para probar y por lo tanto no hay ninguna forma de lograrlo.\nComo podemos notar dicha función es recursiva y se llama a si misma hasta que la cantidad se vuelve cero, negativa y/o el set de denominaciones queda vació, y si lo analizamos un poco podemos darnos cuenta de que funciona. La forma simple de saber que set de monedas es usable es guardar el índice de la primera moneda usable y eliminarlas en orden. Hay que notar que hasta el momento no hemos mejorado en nada la solución anterior, y la complejidad de esto es similar a la de nuestra idea anterior.\nLo que hay que notar es que la cantidad no tendrá más de 10,000 valores distintos y que nunca habrá más de 100 sets distintos, por lo tanto dicha función solo se puede mandar a llamar 1,000,000 de veces con parámetros distintos. Sin embargo sabemos que la cantidad de combinaciones puede llegar a ser mucho mayor. Entonces ¿Qué sucede?, pues es sencillo darse cuenta que dicha función se mandará a llamar más de una vez con los mismos parámetros y en todos esos casos siempre deberá entregar la misma solución, es por esto que podemos guardar las respuestas para cada uno de los casos en un array y así nunca tener que calcularlos más de una vez, esto hace que nuestro programa pueda correr en tiempo.\nEl asunto de los módulos creo que es algo que debiesen saber sin embargo les digo que el modulo se puede aplicar al sumar el tomar y el no tomar, puesto que (A + B) modulo X es igual a (A modulo X + B modulo X ) modulo X.","solución-de-30-50-puntos#Solución de 30, 50 puntos":""},"title":"Solución a \"Cambio\""},"/posts/solucion-a-carretera/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Examen 1 Autor: Freddy Román Cepeda Fuente: Edgar Augusto Santiago Nieves, Freddy Román Cepeda\nPara obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.\nEste código obtiene los primeros 30 puntos:\nPara el resto de los puntos: Sea $latex f(t)$ el ancho necesario para la fotografía en el segundo $latex t$. La observación crucial es que $latex f$ es una función unimodal: es decir, existe un punto $latex t_0$ tal que $latex f$ es decreciente a la izquierda de $latex t_0$ y es creciente a la derecha.\nComputar $latex f(t)$ para $latex t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $latex t$, lo cual toma tiempo $latex O(N)$. Como $latex f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $latex O(\\lg T)$, donde $latex T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $latex O(N \\lg T)$, suficiente para obtener todos los puntos del problema.\nEl siguiente código implementa la solución anterior con búsqueda binaria."},"title":"Solución a \"Carretera\""},"/posts/solucion-a-chilly-rapero/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 12 Autor: Ethan Jiménez Vargas\nLa clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.\nCrear las aristas entre los nodos tiene una complejidad de O(LN2) y la manera más simple de almacenar dichas aristas es mediante una matriz de adyacencia. Ya que tenemos el grafo planteado, buscaremos la manera más rápida de cambiar de palabra entre cualquier par de palabras, esto puede conseguirse usando el algoritmo de Floyd-Warshall con una complejidad de O(N3) que es suficiente para el problema.\nFinalmente, para obtener la respuesta sumamos el mínimo número de cambios requeridos entre todos los pares de palabras consecutivas en el rap, este número de cambios fue obtenido mediante el algoritmo de Floyd-Warshall. El número total de cambios lo multiplicamos por 0.2 y será la respuesta para el problema.\nComplejidad de la solución: O(LN2+N3)"},"title":"Solución a \"Chilly Rapero\""},"/posts/solucion-a-coleccion/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 5 Autor: Alexis Cervantes / César Cepeda Fuente: Alexis Cervantes / César Cepeda\n_Estructura de la solución: _¿Qué nos están pidiendo? El problema nos esta pidiendo que encontremos un subconjunto de las tarjetas tal que la suma de todos los puntajes de las tarjetas de ese subconjunto sea la maxima posible, y la suma de sus precios sea menor o igual al dinero con el que cuentas. En otras palabras lo que se esta buscando es que:\nla suma sea maxima siempre y cuando donde Xi** = {1 si se compró la tarjeta _i, **_y 0 si no se compró}\n**_Modelo del espacio de búsqueda como árbol: _**Al final de cuentas, incluso el nombre lo indica, este problema se puede reducir a asignarle a cada tarjeta un 0 ó un 1 dependiendo de si la vamos a comprar o no, por lo que una forma de modelar el espacio de búsqueda sería formar un número binario de N dígitosy crear todos los valores posibles para dicho número.\nPara formar todos los números, podemos pensar que en el nivel j del árbol vamos a decidir si compramos la tarjeta j, por lo tanto todos los nodos del nivel j tendrán dos hijos, uno de ellos indicando que si compramos la tarjeta y el otro indicando que no la compramos. El árbol de búsqueda queda como se muestra a continuación.\n_**Técnica de búsquda a utilizar: **_Dado que tenemos que entregar como resultado el camino con el mayor puntaje de todos , es preciso que revisemos el 100% de los caminos. Una forma de resolver el problema es utilizar búsqued en profundidad, sin embargo el espacio de búsqueda es un árbol binario con N niveles por tanto de _**2N **_estados. Para nuestro problema N=500 por lo que el espacio de búsqueda es indescriptiblemente grande, aunque claro que se pueden podar las ramas en las que el precio ya superó a la cantidad de dinero que tenemos, el aplicar la técnica de búsqueda en profundidad en este problema dificilmente alcanzaría para una **_N _**mayor que 24 ó 25.\nNecesitamos por tanto encontrar una poda mucho más agresiva.\nAnteriormente, en el ejemplo de los Tanques, utilizamos la búsqueda en profundidad para encontrar un camino mínimo, por lo tanto, debido a que cada nivel que descendemos el coste aumenta, se podía aplicar la poda de que si obteniamos algún mínimo se podían cortar todas las ramas cuyo coste fuera mayor o igual que el mínimo actual. Sin embargo al querer encontrar un máximo, esto no es posible, ya que el coste por rama siempre aumenta y lo que queremos es es encontrar el máximo, así que no sabemos si el camino nos va a llevar a algo mejor a menos que lo recorramos todo!\nPero que pasaría si tuvieramos una función tal que nos permitiera saber cual es el máximo posible que podemos obtener por una cierta rama? En ese caso, podríamos cortar cualquier rama si supieramos que por ese camino es imposible lograr algo mejor que lo que ya tenemos.\nEsta técnica se conoce como de “acotamiento y poda”. La idea es buscar una función que para cada estado del espacio de búsqueda nos de cotas del máximo posible al que se puede llegar por dicho camino y de mínimo seguro que podemos obtener también por ese camino.\nEsta técnica es increíblemente poderosa y conviene que mediten un momento sobre la misma. Vale la pena hacer notar que no siempre es sencillo encontrar la función de acotamiento correcta. Ya que una función que de una cota muy alta no nos sirve de mucho, ya que las podas serian pocas, pero una cota incorrecta nos puede hacer que entreguemos resultados incorrectos. Por lo tanto al utilizar esta técnica, siempre debemos buscar la función que acote lo más posible pero estando siempre 100% seguros de que el resultado que obtuvimos es efectivamente mayor o igual al máximo posible.\nPara este problema voy a definir las dos funciones de acotamiento, llamemos a(c) a la función que nos da el máximo posible que se puede obtener estando en el nodo **c**y b(c) a la función que nos da el mínimo asegurado que tenemos también al estar en el nodo c. El demostrar que ambas funciones son válidas queda como tarea para el alumno.\nLo primero que tenemos que hacer es ordenar las tarjetas de acuerdo a la relación U/P, es decir, cuantos puntos nos dan por cada peso gastado. Como queremos obtener el máximo puntaje por nuestro dinero obviamente son mejores las tarjetas que nos dan muchos puntos por peso comparadas con las tarjetas que nos dan pocos puntos por cada peso gastado. OJO: esto no implica que la solución correcta deba tomar siempre las mejores tarjetas, únicamente quiere decir que comparadas individualmente, para nuestro objetivo son mejores las tarjetas que dan más puntos por peso.\nUna vez que tengamos todas las tarjetas ordenadas en base a este criterio, iremos decidiendo si las tomamos o no, en ese respectivo orden. Para cada nodo, nuestras funciones de acotamiento estarán definidas de la siguiente manera:\nb(c): Para calcular la cota mínima asegurada del nodo c vamos tomando las tarjetas que aún no hemos utilizado según el ordenamiento mientras aún tengamos dinero, en el momento en el que no tengamos más dinero para comprar ahi nos detenemos. Ese es el mínimo que seguro podemos obtener.\n_**a(c): **_Para calcular la cota alta, hacemos el mismo procedimiento que en b (o mejor tomamos el resultado de b para no recalcular) y con la primera tarjeta que no pudimos tomamos su relacion U/P y la multiplicamos por el dinero que aún tenemos disponible y lo sumamos a b. Así obtenemos el máximo posible que se puede lograr en el subárbol del nodo c. La operación que efectuamos al final fue la de utilizar el dinero que aún tenemos disponible para comprar un “pedazo” de la mejor tarjeta aún queda, obviamente esto no es posible ya que no podemos comprar pedazos de tarjeta, sin embargo nos sirve para calcular el máximo posible. Demostrar que b es válida es trivial, sin embargo queda para el lector demostrar que a es una cota que siempre dará un número mayor o igual al máximo posible que se puede obtener por ese camino.\nObviamente una vez que tengamos las funciones de acotamiento, podemos hacer nuestra búsqueda almacenando cual es el mejor mínimo asegurado que hemos obtenido hasta el momento y eliminando todas las ramas cuyo máximo asegurado es menor o igual que éste.\n**_Detalles de implementación: _**Para la implementación queda un último detalle que resolver, y este es como vamos a buscar? Como casi siempre tenemos dos opciones, la primera es la de la búsqueda en profundidad, para la cual se implementa una rutina recursiva y no se requiere de mantener arreglos de memoria externos. Y la segunda es una búsqueda por amplitud, para la cual requieres de una cola que te permita almacenar los estados proximos a ser evaluados.\nSi optamos por la búsqueda en profundidad, hay un detalle de implementación muy sútil que puede ser de gran ayuda. Supongan que modelamos el árbol de búsqueda como el que se muestra en la figura de arriba. Y supongan que nuestro algoritmo de búsqueda revisa primero la rama izquierda, de ser asi, la cota mínima asegurada y la cota máxima del hijo de la izquierda es exactamente igual a la de su padre, por lo que bajariamos un nivel en la búsqueda sin obtener ninguna información nueva, si, en cambio, revisamos primero el hijo de la derecha, entonces estaríamos obteniendo nuevas cotas con información probablemente últil.\nSi se opta por la búsqueda en amplitud, se tiene una ventaja, y esta es que la cola se puede sustituir por un monticulo de modo que se priorice la búsqueda según el nodo que tiene el mejor mínimo asegurado. Sin embargo aunque esto podría efectivamente reducir la búsqueda bastante no estamos seguros del tamaño que puede llegar a tener la cola y requeririamos que al llenarse la cola el programa pudiera cambiar a una técnica de búsqueda en profundidad, lo cual haría el código más enredado. Sin embargo si se desea llegar a límites aún mas grandes, esta sería la opción a seguir. Implementación: "},"title":"Solución a \"Colección\""},"/posts/solucion-a-comesolo/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 8 Autor: lhchavez Fuente: Félix\nEste problema es especial porque es el primero en omegaUp de solo salida! Usualmente lo que debes esperar cuando te enfrentes con uno de esos problemas es que sea un problema NP que no tiene una solución rápida, y usualmente te pedirán que te aproximes lo más posible a la solución óptima. Esto significa que te vas a tener que valer de técnicas ad-hoc y heurísticas para sacar puntos.\nLa solución del problema es bastante sencilla de explicar: haz una búsqueda en profundidad intentando todos los posibles movimientos por fuerza bruta hasta que te salga una solución aceptable e imprímela. El problema es que esta estrategia es $latex O(n!)$, y como $latex n$ puede valer hasta 30x30, puedes esperar que el programa corra varios milenios antes de encontrar la solución óptima. Hay tres trucos (en orden de importancia) para obtener una solución decente en un tiempo razonable:\nNo repetir estados. No “clavarse” con soluciones que parece que son muy buenas, pero en realidad llevan a callejones sin salida. Encontrar una manera de darle prioridad a los estados que tengan más probabilidad de llegar a una solución buena. La estrategia que yo personalmente seguí fue que cada que encontraba un nuevo estado, obtenía su hash (que resultaba en un entero de 64 bits) y verificaba si no lo había visitado usando una tabla de hash*. Si no la había visitado, encontraba todos los estados vecinos (todos los tableros que resultaban de hacer un movimiento válido) y los guardaba en una fila de acuerdo a la cantidad de puntos (entre más puntos, más adelante en la fila). Luego, elegía aleatoriamente un estado de la fila dándole prioridad a los que estaban más adelante (pues son los que tienen mayor probabilidad de llegar a una buena solución), lo cual también me evitaba seguir un único camino donde me podría atorar. Repetí eso hasta que se me terminó la memoria de la computadora e imprimí la mejor solución.\nA continuación, el pseudocódigo de la solución:\nclass Estado: int puntos = 0 bool\\[N\\]\\[N\\] tablero Estado padre = null def \\_\\_init\\_\\_(Estado p): puntos = p.puntos tablero = p.tablero padre = p def hash(): # Puedes usar cualquier algoritmo que genere un entero de 64 bits # a partir de tablero y puntos. Este es el más sencillo. hash = puntos for i in range(0, N): hash = ((hash \u003c\u003c 7) | (hash \u003e\u003e 53)) ^ tablero\\[i\\] return hash def siguientes(queue\\[300\\] colas): # Para todas las celdas (i, j) del tablero... for i in range(0, N): for j in range(0, N): # Si la celda tiene una pieza... if tablero\\[i\\]\\[j\\]: # Para todos los vecinos contiguos (i+k, j+l)... for k in range(-1, 2): for l in range(-1, 2): # Asegúrate que se haya movido \\_algo\\_. if k == 0 \u0026\u0026 l == 0: continue # Y que pueda brincar dentro del tablero. if j + 2 \\* l \u003c 0 or j + 2 \\* l \u003e= N: continue # Y que haya brincado una pieza. if not tablero\\[i + k\\]\\[j + l\\]: continue # Y que el lugar a donde brinca esté desocupado. if tablero\\[i + 2 \\* k\\]\\[j + 2 \\* l\\]: continue hijo = new Estado(this) # Aumenta la puntuación del hijo hijo.puntos++ # Borra la ficha original y la \"comida\". hijo.tablero\\[i\\]\\[j\\] = hijo.tablero\\[i + k\\]\\[j + l\\] = \\\\ False # Agrega la ficha en su posición final. hijo.tablero\\[i + 2 \\* k\\]\\[j + 2 \\* l\\] = True # Agrégala a la cola correspondiente. colas\\[hijo.puntos\\].push(hijo) def elige\\_estado(): # Número aleatorio entre 0 y 1. r = (random() / (float)RAND\\_MAX) # El índice de la última cola que estuvo llena. ultimolleno = -1 # La cola que se está considerando. x = 0 # Elige la cola con mayores puntos que no esté vacía como # primera opción. for i in range(0, N): if not colas\\[i\\].vacio(): x = i # La primer cola tiene probabilidad de 31% de ser elegida. # La segunda cola tiene probabilidad de 21%, la tercera 14%, # la cuarta 10% y así sucesivamente. while x \u003e= 0: if not colas\\[x\\].vacio(): ultimolleno = x x-- r \\*= 1.45 if r \u003e= 1 and ultimolleno != -1 break if ultimolleno == -1: return Null return colas\\[lastfull\\].pop() queue\\[300\\] colas hashtable estados\\_visitados \\# lee el estado original colas\\[0\\].push(estado\\_original) Estado mejor = estado\\_original while no\\_se\\_haya\\_terminado\\_la\\_memoria(): Estado s = elige\\_estado() # Si ya no hay más estados por visitar, # encontramos la respuesta óptima en algún punto. if s == Null: break # Actualiza |mejor| si hay una respuesta mejor. if mejor.puntos \u003c s.puntos: mejor = s # Repetir estados es malo. if s.hash() in estados\\_visitados: continue estados\\_visitados.add(s.hash()) # Agrega todos los vecinos. s.siguiente(colas) \\# A partir de este punto, |mejor| contiene la mejor solución. Podemos # saber qué movimiento se hizo para llegar a él comparando las # diferencias entre el tablero de |mejor.padre| y |mejor|. Ya solo es # cuestión de imprimir el resultado y listo. \\* Aquí mucha gente se va a quejar porque solo guardar el hash abre la puerta a que haya dos estados que puede tener hasta 900 bits que tengan el mismo hash de 64 bits (por el [principio del palomar](http://es.wikipedia.org/wiki/Principio_del_palomar)) y esté considerando que ya se visitó un estado que en realidad es nuevo. Si haces las cuentas, la probabilidad de colisión es negligible: la cantidad de estados que podía visitar en mi computadora (27 millones) es significativamente más pequeña que el número de estados necesarios para que la probabilidad de colisión sea de 1% ($latex \\\\approx 10^{135}$, por la [paradoja del cumpleaños](http://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os)). "},"title":"Solución a \"Comesolo\""},"/posts/solucion-a-contrasena-binaria/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Problemset 7 Autor: Orlando Isay Mendoza Garcia Fuente: Christian Adan Hernández Sánchez\nPodemos ayudarnos de la imagen para comprender mejor esta explicación:\nimg1 En ella aparecen de forma descendente a la izquierda los números pares comenzando desde el dos, y su representación binaria a la derecha. En la parte superior aparece el valor de cada cifra en decimal.\nTomando en cuenta el límite del problema, sabemos que si sumamos $latex B(i)$ para cada par menor o igual a $latex N$, en el peor de los casos tendríamos que realizar 500,000,000,000,000 veces la función. Aún si lograramos calcularla en una operación nuestro programa excedería el tiempo límite.\nEn cambio, haciendo cálculos notamos que: $latex 2^{50} \\approx 1,000,000,000,000,000$. Lo cual significa que a lo más habrán 50 columnas en la tabla (ya que en la forma binaria cada cifra representa una potencia de 2).\nDado que sabemos que en una suma el orden de las cantidades a sumar no importa, podemos determinar que es lo mismo sumar los valores de forma horizontal, tanto como de forma vertical. Sumando los valores de las columnas solo tomaría 50 operaciones. La columna 1 podemos ignorarla ya que al ser pares los números de la lista ninguno contendrá un 1 en la última cifra.\nObservando la siguiente imagen, vemos que la columna $latex C$ se forman grupos de tamaño $latex C$ (por ejemplo, en la columna 4 se forman grupos de cuatro elementos),que contienen una la mitad de $latex 1$s y la otra de $latex 0$s. También podemos ver que en la columna 2 no hay $latex 0$s antes del primer grupo, en columna 4 hay un 0, en la que sigue hay 2, luego 4,etc (área en color gris). Podemos notar que ese espacio aumenta en base a potencias del dos.\nimg2 Teniendo el número $latex N$ habrán $latex N / 2$ números en la lista. Para calcular la cantidad de grupos completos que se forman en cada columna dividimos $latex N$ menos el espacio lleno de ceros en esa columna, entre el número de la columna en el que estemos; a su vez, esta cantidad la multiplicamos por, el número de la columna entre dos. Sin embargo, puede que nos falten de contabilizar los $latex 1$s que pudieran estar en un grupo que no se completo. Esto se arregla sumando a lo anterior, el mínimo entre el resto de la división anterior y, el número de la columna entre dos.\fCódigo:"},"title":"Solución a \"Contraseña Binaria\""},"/posts/solucion-a-crucero/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 4 Autor: Saúl Germán Gutiérrez Calderón Fuente: USACO Enero 2009 Gold\nComo se puede notar, al trazar la ruta óptima del crucero se está desperdiciando mucho espacio, y daría lo mismo si expandiésemos la isla para que no se desperdiciara espacio entre la ruta y la orilla de ésta.\nimage002 image004 Si supiéramos cual es la ruta óptima del crucero para expandir la isla bastaría con hacer un Flood Fill para rellenar los espacios con agua que quedan dentro de la ruta.\nResulta que el flood fill e puede hacer aun sin conocer cuál sería la ruta óptima. Si nos ponemos a hacer todos los tipos de celdas adyacentes a la celda actual en un flood fill, nos toparemos con que solo hay 2 que permiten que la isla crezca y 1 que evita que se expanda. El resto de las celdas adyacentes no nos dice nada acerca de si tenemos que poner algo ahí o no (de momento).\nSi se pone un pedazo de isla nuevo en el centro de las figura de abajo, entonces la cosa peligrosa tendría que ser rodeada de alguna manera para poder pasar, lo cual nos llevaría a tomar una ruta mas larga. Por ello, no es una buena idea poner un pedazo de isla ahí.\nimage005 Si es como la de la figura de abajo,\nimage006 ambos caminos tienen la misma longitud. Por ello, se puede poner un pedazo de isla ahí y esto nos simplifica el problema.\nimage007 image008 La ruta óptima no puede pasar por el cuadro del centro ya que esto sería un desperdicio de tiempo, por lo cual podemos expandir la tierra ahí.\nimage009 Entonces, sólo hay que hacer todas las expansiones de tierra hasta que ya no se pueda más y después de esto se puede hacer una mano derecha para buscar la orilla de la isla que al mismo tiempo será la ruta óptima."},"title":"Solución a \"Crucero\""},"/posts/solucion-a-cueva/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 4 Autor: Ethan Jiménez Vargas\nDespués de comprender el problema podemos deducir dos cosas:\nLos N puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán N-1 aristas y siempre hay un camino entre cualquier par de nodos. Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las Q preguntas, ¿el nodo A es un ancestro del nodo B?”, de modo que necesitamos encontrar una manera óptima de saberlo. Subtarea 1. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si A es ancestro de B, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo A encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo B, si existe un camino del nodo A al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo A es el mismo nodo B, en ambos casos la respuesta es 0.\nComplejidad de la solución: O(NQ)\nSubtarea 2. Es notable que esta vez el número de preguntas es mucho mayor, por ello la solución anterior tardaría demasiado. Cambiemos nuestra estrategia, esta vez realicemos una búsqueda en profundidad desde el nodo 1 hasta los demás N nodos, llevando una lista L de los nodos que forman parte del camino desde el nodo 1 hasta el nodo K, incluyendo los nodos 1 y K, esto puede lograrse mediante recursividad.\nLa tabla ancestro[K][M] nos permitirá saber si el nodo M es un ancestro del nodo K, dándonos cuenta que todos los ancestros de K se encuentran en la lista L cuando la búsqueda en profundidad llega al nodo K, podemos llenar la tabla ancestro[K][M] durante la búsqueda en profundidad. Con la tabla anterior es fácil responder las preguntas, pues la respuesta depende de ancestro[B][A].\nComplejidad de la solución: O(N2+Q)\nSubtarea 3. Para obtener los puntos de esta subtarea podemos utilizar cualquier algoritmo para resolver el clásico problema del ancestro común de dos nodos en un árbol, puesto que la respuesta es 1 si el ancestro común entre los nodos A y B es el nodo A. Este problema ya ha sido estudiado ampliamente y tiene diversas formas de ser resuelto con complejidad O(NlogN), en el foro de tutoriales de TopCoder podemos encontrar un buen artículo con algunos de los algoritmos que pueden ser utilizados:\nTopCoder Lowest Common Ancestor\nEl algoritmo que utiliza programación dinámica es el más recomendado, puesto que se puede responder a las Q preguntas en un tiempo constante.\nComplejidad de la solución: O(NlogN+Q)\nSubtarea 4. Para empezar, notemos que la solución anterior no funciona para este conjunto de puntos porque utiliza demasiada memoria, el simple hecho de almacenar los nodos y las aristas ocupa bastante espacio en memoria (aproximadamente 100Mb) y una solución para la subtarea 3 requeriría al menos 50Mb más, por lo tanto no es posible completar la subtarea 4 con una solución como la anterior, para obtener los 100 puntos en este problema necesitamos una idea mucho más creativa.\nRenombremos todos los nodos del árbol enumerandolos del 1 al N siguiendo el orden establecido por el recorrido en postorden del árbol comenzando por el nodo 1, después, para cada nodo, con su respectivo número Y, hay que obtener el menor número presente en el subárbol con raíz en el nodo Y, denotemos este número menor como X, con los números X y Y definimos entonces un intervalo cerrado [X,Y] que nos representa que en el subárbol con raíz en el nodo Y se contienen todos los nodos cuyo número se encuentra en el intervalo [X,Y]. Podemos interpretar esta información de una manera más conveniente, un nodo con número Y es ancestro de un nodo con número K si X ≤ K ≤ Y, lo cual nos permitirá responder las preguntas planteadas.\nEs recomendable que el olímpico experimente y se convenza que la propiedad del intervalo [X,Y] es siempre correcta debido a que el recorrido en postorden establecerá que el nodo con el número X, que establece la cota inferior del intervalo, siempre será una hoja del subárbol y el nodo con valor Y, que establece la cota superior del intervalo, siempre será la raíz del subárbol, cualquier otro valor fuera del intervalo estará excluido del subárbol con raíz en el nodo Y.\nComplejidad de la solución: O(N+Q)"},"title":"Solución a \"Cueva\""},"/posts/solucion-a-dp-generica/":{"data":{"":"","análisis-1#Análisis 1":"","análisis-2#Análisis 2":"","análisis-3#Análisis 3":"","análisis-adicional#Análisis adicional:":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 13 Autor: Freddy Román Cepeda Fuente: Project Euler\nPodemos tratar este problema de varias maneras distintas, 3 de las cuales discutiré en esta solución.\nAnálisis 1 Primero, una idea que hubiera obtenido 50 puntos.\nPodemos observar que el problema es equivalente a encontrar de cuántas maneras se le puede asignar un número $latex n_i$ del conjunto $latex \\{0,1,2\\}$ a cada potencia de 2 tal que $latex \\sum_{i=0}^{\\infty} n_i 2^i = x$. Esto también es equivalente a encontrar cuántos números $latex a$ y $latex b$ hay tales que $latex a + b = x$ y no haya ningún bit encendido en $latex b$ que no esté encendido en $latex a$.\nConsideremos la expansión binaria de $latex a = \\sum_{i=0}^{\\infty} a_i 2^i$ y $latex b = \\sum_{i=0}^{\\infty} b_i 2^i$ , donde cada $latex a_i$ y $latex b_i$ es 1 o 0. Al sumar $latex a + b = \\sum_{i=0}^{\\infty} (a_i + b_i) 2^i$ tenemos que $latex 0 \\le n_i = a_i + b_i \\le 2$, como se necesita. Para contar solamente una vez cada configuración distinta de la secuencia $latex n$, añadimos la restricción de que cualquier $latex b_i$ puede ser 1 sólo si $latex a_i$ también lo es.\nSubtarea 1Para esta subtarea es suficiente probar todas las $latex a$ y $latex b$ posibles, revisando con un loop para cada bit si la condición sobre $latex b$ se cumple. Este algoritmo corre en tiempo $latex O(N^2 \\log N)$.\nSubtarea 2Para esta subtarea podemos hacer una observación sencilla: a cada $latex a$ sólo le puede corresponder una $latex b$, igual a $latex x - a$, lo que reduce la complejidad en tiempo del algoritmo a $latex O(N \\log N)$.\nSubtarea 3Podemos comprobar si $latex b$ cumple la condición en tiempo constante utilizando operaciones de bits. Si ~a \u0026 b es igual a 0, $latex b$ no tiene ningún bit encendido que $latex a$ no tenga encendido. Ahora tenemos un algoritmo lineal. Desafortunadamente, ya no podemos mejorar nuestra solución fácilmente continuando con esta idea.\nEl siguiente código implementa esta solución:\nAnálisis 2 Podemos hacer programación dinámica de forma top-down. En ésta, contamos la cantidad de maneras de escribir $latex x$ como pide el problema incluyendo o no cada una de las potencias distintas.\nConsideremos la función $latex f(n,p)$, que cuenta de cuántas maneras podemos escribir $latex n$ utilizando potencias de 2 menores o iguales a $latex p$ no más de 2 veces cada una. Es evidente que la respuesta se encontraría evaluando $latex f(x,63)$.\nSabemos que $latex f(n,p) = 0$ si $latex n$ es negativo o si $latex p$ es negativo. Del mismo modo, $latex f(n,p) = 1$ si $latex n = 0$. De lo contrario, es igual a la suma de $latex f(n,p-1)$, $latex f(n-2^p,p-1)$ y $latex f(n-2^{p+1},p-1)$, que corresponden a poner 0, 1, o 2 veces la potencia $latex 2^p$.\nSubtarea 1Aplicando directamente el análisis anterior, la subtarea 1 queda resuelta.\nSubtarea 2Varios de estos estados se repiten, así que convendría memorizarlos. Utilizando un contenedor como std::map, la solución se vuelve lo suficientemente rápida para resolver esta subtarea.\nSubtarea 3Podemos determinar en algunos casos rápidamente si la función se evaluará a 0. Sabemos que $latex \\sum_{i=0}^{k} 2^i = 2^{k+1} - 1$. Entonces, el número más grande que podemos escribir sólo usando potencias de 2 menores o iguales a $latex p$ a lo más dos veces es $latex 2\\sum_{i=0}^{p} 2^p = 2 (2^{p+1} - 1) = 2^{p+2} - 2$. Por lo tanto, $latex f(n,p) = 0$ si $latex n \u003e 2^{p+2} - 2$.\nEsa optimización por sí misma (sin memorización), resuelve la subtarea 3.\nSubtarea 4Combinando las ideas de las dos subtareas anteriores, el algoritmo es lo suficientemente rápido para resolver todos los casos. Específicamente, la cantidad de estados que no podemos determinar como no viables instantáneamente es proporcional a $latex \\log x$, y cada estado lo podemos evaluar en tiempo $latex O(\\log \\log x)$ por nuestro std::map, dándonos una complejidad total de $latex O(\\log x \\log \\log x)$. Esta cota puede quedar más clara después de describir la tercera solución.\nEl siguiente código implementa esta solución:\nAnálisis 3 Esta solución es equivalente a la anterior, pero no precisa de un std::map.\nConsideremos la función $latex n(k)$, que definimos como el número que obtenemos tomando los bits $latex 0..k$ de $latex x$. En otras palabras, si $latex x = \\sum_{i=0}^{\\infty} x_i 2^i$ donde $latex x_i$ es el $latex i$-ésimo bit de $latex x$, $latex n(k) = \\sum_{i=0}^k x_i 2^i$. Ahora, definimos la función $latex g(i,r)$, que cuenta de cuántas maneras se puede escribir el número $latex n(i) + r2^i$, utilizando potencias de 2 menores o iguales a $latex i$ a lo más 2 veces. La respuesta, por lo tanto, se obtendría evaluando $latex g(63,0)$.\nAhora, sabemos que $latex g(i,r) = 1$ si $latex i \u003c 0$ y $latex r = 0$, porque podemos escribir sólo de una manera 0. Recordando que $latex x_i$ es el $latex i$-ésimo bit de $latex x$, podemos decir que $latex g(i,r)$ cuenta la cantidad de formas que se puede escribir el número $latex (r+x_i)2^i + n(i-1)$. De ahora en adelante, por conveniencia, $latex t = r + x_i$.\nUsando esto, podemos definir $latex g(i,r)$ recursivamente:\n$latex g(i,r) = \\begin{cases} 1 \u0026 \\text{si } i \u003c 0 \\text{ y } r = 0 \\\\ \\sum_{k=0}^{min(t,2)}g(i-1,2(t-k)) \u0026 \\text{de lo contrario} \\end{cases}$\nEn otras palabras, si tenemos que poner $latex t$ veces la potencia $latex i$, podemos elegir ponerla hasta $latex min(t,2)$ veces, y contar las maneras de escribir el resto usando potencias de 2 menores a $latex p$. Pero como dejamos $latex t-k$ veces la potencia $latex i$ sin poner, es igual a poner $latex 2(t-k)$ veces la potencia $latex i-1$.\nLa siguiente observación es que si $latex t$ es mayor a 3, $latex g(i,r) = 0$ porque $latex 2\\sum_{k=0}^{i} 2^k \u003c 4 \\times 2^{i}$. Entonces, sólo nos interesan los casos en los que $latex 0 \\le t \\le 3$. En total, sólo hay 4 valores posibles para $latex t$ en los que $latex g(i,r)$ no es 0: 0, 1, 2, y 3. Enumerémoslos:\n$latex g(i,r) = \\begin{cases} g(i-1,0) \u0026 \\text{si } t = 0 \\\\ g(i-1,2) + g(i-1,0) \u0026 \\text{si } t = 1 \\\\ g(i-1,4) + g(i-1,2) + g(i-1,0) \u0026 \\text{si } t = 2 \\\\ g(i-1,6) + g(i-1,4) + g(i-1,2) \u0026 \\text{si } t = 3 \\end{cases}$\nPero $latex g(i,r) = 0$ si $latex t \u003e 3$, y como $latex t \\ge r$, nos quedamos con:\n$latex g(i,r) = \\begin{cases} g(i-1,0) \u0026 \\text{si } t = 0 \\\\ g(i-1,2) + g(i-1,0) \u0026 \\text{si } t = 1 \\\\ g(i-1,2) + g(i-1,0) \u0026 \\text{si } t = 2 \\\\ g(i-1,2) \u0026 \\text{si } t = 3 \\end{cases}$\nTomando en cuenta que $latex r$ sólo puede ser 0 o 2, y $latex x_i$ sólo 0 o 1:\n$latex (g(i,0),g(i,2)) = \\begin{cases} (g(i-1,0),g(i-1,2)+g(i-1,0)) \u0026 \\text{si } x_i = 0 \\\\ (g(i-1,2)+g(i-1,0),g(i-1,2)) \u0026 \\text{si } x_i = 1 \\end{cases}$\nEl siguiente código implementa esta solución, que corre en tiempo $latex O(\\log n)$ y espacio constante:\nComo podemos observar, esta solución considera los mismos estados que la anterior, sólo que aquí evitamos computarlos, mientras que la otra los descarta inmediatamente.\nConsideraciones Varios competidores no consideraron que $latex x$ no cabe en un entero signado de 64 bits. Si bien la respuesta cabe en uno, en los límites del problema se especifica que $latex x \u003c 2^{64}$.\nAnálisis adicional: Diego Roque escribió una solución distinta, la cual detallaré a continuación.\nConsideremos la función $latex f(x)$ como la define el problema: la cantidad de maneras de escribir $latex x$ como una suma de potencias no negativas de 2 sin usar cada una más de 2 veces.\nEnfoquémonos en la paridad de $latex x$ (es decir, el último bit de $latex x$). Si $latex x$ es impar, necesariamente tenemos que poner una vez la potencia $latex 2^0$, porque las otras dos opciones: ponerla 0 veces o ponerla 2 veces cambiarían la paridad de $latex x$. Por lo tanto, $latex f(x) = f(\\frac{x-1}{2})$ si $latex x$ es impar. En cambio, si es par, podemos elegir poner la potencia $latex 2^0$ 0 o 2 veces, lo que nos deja con $latex f(x) = f(\\frac{x}{2}) + f(\\frac{x}{2}-1)$. Sólo falta definir los casos base: $latex f(0) = f(1) = 1$.\nAquí está su código que implementa esta solución, que corre en tiempo $latex O(\\log^2 x \\log \\log^2 x):$","consideraciones#Consideraciones":"","subtarea-1#Subtarea 1":"","subtarea-1-1#Subtarea 1":"","subtarea-2#Subtarea 2":"","subtarea-2-1#Subtarea 2":"","subtarea-3#Subtarea 3":"","subtarea-3-1#Subtarea 3":"","subtarea-4#Subtarea 4":""},"title":"Solución a \"DP Genérica\""},"/posts/solucion-a-el-artista-lento/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 2** Autor: **Christian Hernández\nLo primero de lo que debemos darnos cuenta es de que como los pedazos son de dimensiones enteras y se colocan en dimensiones enteras, podemos “pensar” el problema de manera que en lugar de pegar rectángulos de Mi x Ni, estamos pegando Mi x Ni de 1 x 1 (Ejemplo: Si tuvieramos que pegar un rectángulo de 4 x 3, podemos pensarlo como pegar 12 rectangulos de 1 x 1). Podemos pensar lo mismo de los rectángulos adhesivos.\nSi pensamos el problema sin rectángulos adhesivos, podríamos resolverlo teniendo en un arreglo matricial el color que se encuentra hasta arriba de cada rectángulo de 1 x 1 que tiene la cartulina.\nSi tomamos la misma idea pero ahora teniendo en cuenta que existen rectángulos adhesivos, nos encontramos con el problema de que si rasgamos un cuadro necesitamos recordar el color la capa de papel que se encontraba debajo de la capa “visible”, y además podemos rasgar tantas veces como capas de papel hemos puesto. Con esto tenemos que necesitamos guardar un número de valores igual al número de capas que hemos puesto. Además tenemos que tener en cuenta el orden en el que fuimos poniendo las capas; esto es la última capa que pusimos debe de recordarse primero que la primera que pusimos, o en otras palabras: El primero que entras es el último que sale, así como el el último que entra es el primero que sale. Ese comportamiento lo encontramos en la estructura de datos Pila (Si no conoces la estructura de datos, puedes consultarla acá).\nA continuación se encuentra la implementación de una estrúctura Pila que nos serviría para este problema:\nstruct Pila{ char arreglo[2002]; short int posActual; //Devuelve si la pila esta vacia bool estaVacia(){ return posActual == 0; } //inserta un elemento en cima de la pila void push(char valor){ posActual++; arreglo[posActual] = valor; } //quita el elemento de la cima de la pila y lo devuelve char pop(){ char valor = 0; if(!estaVacia()){ valor = arreglo[posActual]; posActual--; } return valor; } //devuelve el valor del elemento de la cima de la pila char top(){ return arreglo[posActual]; } }; Es importante notar que esta es una implementación estática de una Pila (Siempre ocupa el mismo espacio en memoria sin importar el número de elementos, además de que el número de elementos máximo ya está definido). Como se ve, se han utilizado char para guardar los valores, ya que el valor de los colores llega hasta 100, por lo que un char es más que suficiente.\nEntonces teniendo pilas para recordar todas nuestras capas de papel en orden, lo que podemos hacer es hacer un arreglo matricial de pilas para resolver nuestro problema.\nBásicamente, cada que agreguemos un rectágulo de papel a nuestra cartulina lo que tenemos que hacer es, para cada rectángulo de 1 x 1 que abarca, agregar el color a la pila en su posición en la matriz. Si se trata de un rectángulo adhesivo, hacemos justo lo contrario, sacamos un valor de la pilas correspondientes.\nSólo nos queda resolver el problema del grosor de la cartulina. Debido a que necesitamos desgarrala G veces con un rectángulo adhesivo, podemos pensar que se tratan de G capas de papel del color de la cartulina. Entonces, se reduce a inicializar nuestro arreglo pilas agregando G capas del color de la cartulina.\nLa complejidad de agregar una capa de papel a la cartulina es de O(M x N) (ya que una sola capa puede abarcar toda la cartulina), la misma aplica para usar un rectángulo adhesivo. Entonces la complejidad de agregar todas las capas quedaría O(M x N x K) donde K es el número de rectángulos por pegar. Inicializar la cartulina tendría una complejidad O(M x N x G) donde G es el grosor. Dejándonos con una complejidad final de O(M x N x (K + G)) que es suficientemente buena como para funcionar con los límites de tiempo establecidos.\nLa complejidad en memoria es igual de O(M x N x (K + G)), ya que se tienen que guardar las (K + G) capas de papel en la matriz de M x N."},"title":"Solución a \"El Artista Lento\""},"/posts/solucion-a-el-collar-de-perlas/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 10** Autor: **Félix Rafael Horta Cuadrilla\nEn una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.\nPara resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero i en cualquier lista representa al enano i.\nDurante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.\nEn algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.\nProblema\nEscribe un programa que ayude a los enanos verdes a obtener el diamante, sabiendo de antemano las listas de todos los enanos. Puedes asumir que los enanos rojos juegan de manera optima. Se garantiza que siempre habra una forma en la que los enanos verdes puedan ganar si juegan optimamente.\nEntrada\nLa primer linea contiene la longitud L del collar, el numero N de enanos y el numero F que representa el enano que empieza con el collar.\nLa segunda linea contiene L caracteres (seguidos, es decir, NO hay espacios entre ellos) que representan el collar, estos caracteres pueden ser una letra B que significa que es una perla blanca, una letra N que significa que es una perla negra o una D que indica que es el diamante. Solo habra un diamante y este siempre estara al final del collar.\nLas siguientes N lineas describen a los enanos y sus listas. Cada linea esta formada por un numero C que representa el color del enano (0 si es verde y 1 si es rojo) seguido por la longitud LN de la lista negra y de LN numeros, representando cada uno de los numeros en la lista negra del enano. Finalmente, en la misma linea, el numero LB que indica la longitud de la lista blanca del enano y de LB numeros indicando los elementos de dicha lista.\nLímites\n1 \u003c= L \u003c= 1000\n1 \u003c= N \u003c= 1000\nInteracción\nEste problema es interactivo y deberas escribir una funcion llamada juega() que lea de pantalla el problema los datos de entrada y se cominique con tres funciones en una libreria.\nLas tres funciones con las que hay que interactuar son las siguientes:\nvoid pasaCollar(int enano);\nQue sirve para que cuando uno de los enanos verdes posea el collar, tu programa mande el collar al enano especificado como parametro. Llamar a pasaCollar cuando no le corresponde o pasar el collar a un enano que no este en la lista correspondiente resultara en 0 puntos en ese caso.\nint recibeCollar();\nQue sirve para que cuando uno de los enanos rojos posea el collar, tu programa llame a esta funcion para saber a que enano paso el collar el evaluador. Llamar a esta funcion cuando no le corresponde el turno a un enano rojo resultara en 0 puntos en ese caso.\nvoid termina();\nDebe ser llamada una vez cuando en el collar solo quede el diamante. Si se llama en otro momento o si se llama y el collar esta en posesion de un enano rojo obtendras cero puntos en ese caso. Solo recibiras puntos si llamas a la funcion termina() cuando el collar este en posesion de un enano verde y el collar solo posea al diamante.\nEjemplo\nEntrada\n6 4 2\nNBBNND\n0 1 2 1 4\n0 2 1 3 1 1\n1 1 4 1 4\n1 2 2 3 1 1\nSalida\npasaCollar(1)\npasaCollar(4)\nrecibeCollar() -\u003e 1\npasaCollar(2)\npasaCollar(1)\ntermina()\nCompilación\nSe proporcionan plantillas para facilitar la codificación del problema, de esa forma sólo necesitas codificar el archivo perlas.c/perlas.cpp/perlas.pas. Las plantillas son solo para facilitar la codificación y las pruebas, no se garantiza que se evaluará con las mismas.\nUtilizando la plantilla proporcionada, puedes compilar este programa correctamente en C++ de la siguiente forma:\ng++ main.cpp perlas.cpp -o perlas\nEn C, se hace de la siguiente forma:\ng++ main.c perlas.c -o perlas\nMientras que para Pascal:\nfpc main.pas\nDe la misma forma, las opciones de compilación pueden ser diferentes en la evaluación, sin embargo, si tu programa compila con las plantillas, también debería de hacerlo en el evaluador.\nDescarga las plantillas aquí .\nSolución\nUna manera sencilla de tratar de ganar en este juego, es hacer una búsqueda sobre las listas de los enanos verdes y siempre pasar el collar sobre los enanos verdes, lo cual resolvería un par de casos. Sin embargo, en la mayor parte de los casos, es necesario pasar el collar a un enano rojo que eventualmente lo regresará a un enano verde. Y este es precisamente el problema, saber cuándo pasar a un enano rojo y a qué enano rojo, y como se necesita de la interacción de los enanos rojos para llegar a la solución, un gran problema se presenta.\nAunque este problema podría resolverse fácilmente con una búsqueda memorizada haciendo las llamadas a las funciones durante la búsqueda, no puede hacerse de esta forma porque cuando se hace una búsqueda se requiere poder ir hacia adelante y hacia atrás en el árbol de búsqueda, y como se necesita de la interacción de los enanos rojos, se tiene que lograr la solución en la primera pasada.\nPor lo tanto hay que calcular todas las posibles tiradas antes de jugar, considerando las mejores tiradas de los enanos rojos. De esta forma, una vez que se tiene una jugada para ganar el juego para cualquier estado posible, se puede jugar teniendo seguro el triunfo.\nAhora, aunque sabemos que no se puede resolver con una búsqueda, sí podemos utilizar un árbol de búsqueda para resolver el problema, pero ¿cómo tomar en cuenta las elecciones de los enanos rojos?, la respuesta a esto es jugar para ambos equipos y usar el mismo cósigo para ello, eligendo siempre la mejor opción para el color de enano en cada turno, es decir, cuando la búsqueda esté sobre un enano rojo, hay que elegir la opción que haga que los enanos rojos ganen, y cuando la búsqueda esté sobre un enano verde, hay que elegir la opción que haga ganar a los enanos verdes.\nEs evidente que cuando las hojas del árbol terminan en un enano verde, se gana el juego (esos estados son estados ganadores), y cuando termina en un enano rojo el juego se pierde (esos estados son estados perdedores), eso es fácil, lo difícil son los siguientes niveles.\nTomando en cuenta esto necesitamos etiquetar todos los estados como estados ganadores o estados perdedores, debido a que ya sabemos qué son los estados hojas, podemos deducir qué son los estados anteriores a las hojas de la siguiente forma: Si el estado pertenece a un enano verde, nos basta con que UN y solo UN enano en su lista lleve a un estado ganador, ya que como enanos verdes podemos controlar a quien le pasamos el collar, por lo que basta con que el estado pueda llevar a un estado ganador para que también sea un estado ganador. Si el enano verde NO lleva a ningún estado ganador, entonces ese estado NO es un estado ganador, por que no importa a quien se lo pases, siempre perderás.\nPensando de esta misma forma, si el estado pertenece a un enano rojo, necesitamos que TODOS los estados a los que conduzca sean estados ganadores, por que si hay solo un estado perdedor, los enanos rojos, que juegan con la mejor estrategia, siempre eligirán ese estado.\nDe esta forma, es posible que haya enanos verdes a los que quieras evitar, y enanos rojos a los que quieras pasarle el collar.\nEntonces, para resolver el problema, hay que pasar por todos los estados y marcarlos como estados ganadores o estados perdedores con la técnica que más te guste, ya sea programación dinámica o búsqueda memorizada, pero hay que hacerlo antes de jugar. Una vez teniendo precalculado cuáles son los estados ganadores y perdedores, solo hay que hacer las llamadas de los enanos verdes siempre hacia estados ganadores.\nDESCARGAR ARCHIVOS Y SOLUCIÓN"},"title":"Solución a \"El collar de perlas\""},"/posts/solucion-a-jardinero/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Problemset 6 Autor: Saúl Germán Gutiérrez Calderón Fuente: Saúl Germán Gutiérrez Calderón (recopilado de los ACM-ICPC World Finals 2010, problema I)\nEn este problema, una búsqueda exhaustiva con podas bastaba para que corriera en tiempo.\nLa búsqueda podía tener como estado al renglón y a la columna en la que se estaban, más las casillas por las que ya se había pasado más el numero de la siguiente casilla a esconderse que se necesitaba.\nLas podas que se utilizaron en la solución oficial fueron las siguientes (otras podas podrían también conseguir 100 puntos):\nQue pasara el tiempo en el que se debería llegar a un escondite. Que se pasara por un escondite cuando no se debía. Que no fuera capaz de llegar al siguiente escondite a tiempo. Que el camino que se llevaba volviera imposible una ruta válida. Si la ruta dejaba a algunas posiciones “encerradas” o dividía al mundo en dos, entonces la ruta actual no llevaba a ningún recorrido valido. Esto se podía checar haciendo una búsqueda en profundidad o en amplitud desde alguna posición no visitada (la posición (0,1) es bastante conveniente porque siempre estará libre). Aquí está el código de la solución:"},"title":"Solución a \"Jardinero\""},"/posts/solucion-a-k-arbol/":{"data":{"subcaso-110-puntos#Subcaso 1(10 puntos)":"","subcaso-220-puntos#Subcaso 2(20 puntos)":"","subcaso-320-puntos#Subcaso 3(20 puntos)":"","subcaso-450-puntos#Subcaso 4(50 puntos)":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 5 **Autor: **Saul de Nova Caballero\nEn pocas palabras el problema es, dado un árbol que se puede colorear, encuentra la menor solución satisfaciendo las restricciones dadas sobre los colores. Este problema es un caso particular de Graph Coloring(en español coloración de grafos), en donde el grafo es un árbol.\nSubcaso 1(10 puntos)Para el primer subcaso era posible hacer una búsqueda en profunidad sobre todos los nodos, encontrando la menor solución. Para guardar el árbol, era posible utilizar una matriz que guardara todos los colores posibles y entonces ver si era posible una solución con el menor color posible. La solución de este caso era trivial si se usaba una búsqueda exhaustiva.\nSubcaso 2(20 puntos)Para el segundo subcaso era necesario una mejor estrategia. Para este caso, era necesaria la observación de que todos los colores de los nodos solo dependen de su padre y de sus hijos. Otra observación importante era que para los nodos del árbol, excepto las hojas, había que procesar a sus hijos menores.Procesar implica checar que colores puede tener un nodo. Por lo que para lograr los puntos en este subcaso era necesario procesar los nodos hijos, luego sus padres y asi sucesivamente. Es decir para procesar, un nodo primero hay que procesar a todos sus hijos.\nLa forma de procesar a un nodo es la siguiente. Por cada nodo se compara con su padre y al momento de comparar, lo que se busca es que por cada color del nodo, el padre no tenga un color que lo elimine como opción. Es decir tengo el siguiente caso\nNodo -\u003e Rojo, Verde, Azul\nPadre -\u003e Rojo, Verde\nPor cada color del nodo, el padre puede elegir un color distinto. Por ejemplo, si el Nodo es Rojo, el padre puede ser Verde. Si el nodo es Verde, el padre puede ser Rojo y si el nodo es Azul, puedes elegir el Rojo o el Verde. Sin embargo, para el siguiente caso\nNodo -\u003e Rojo, Verde, Azul\nPadre -\u003e Rojo\nEl padre del nodo solo puede ser Rojo, por lo que para que las condiciones del problema se cumplan, el Nodo no puede ser Rojo. En este caso actualizamos la tabla de valores posibles del Nodo. Y queda como\nNodo -\u003e Verde, Azul\nPadre -\u003e Rojo\nLo anterior se hace para cada par de nodos desde los nodos hoja hasta la raíz. Procesandolos de menor a mayor da la mejor solución\nSubcaso 3(20 puntos)Para obtener los puntos del subcaso 3 era posible simplemente ver por cada nodo procesarlo comenzando en la raíz, ya que en este caso el grafo en basicamente una gran línea. Utilizando la técnica descrita en el subcaso 2 por cada nodo se obtenía una solución a este subcaso\nSubcaso 4(50 puntos)Para los puntos del cuarto caso era necesario “linearizar” el grafo, esto simplemente significa que los nodos mas arriba van a tener menor prioridad que los nodos de abajo, es decir el nodo raíz tendría valor 0 mientras que sus hijos tendrían valores más altos. Por ejemplo para un caso asi:\n0 -\u003e 1 -\u003e 4\n-\u003e 2\n-\u003e 3\nEl nodo 0 es la raíz del árbol, el nodo 1 y 3 son hijos de 0 y los nodos 2 y 4 son hijos de 1, el arbol se linearizaría de la siguiente manera:\n0 -\u003e 1, 1 -\u003e 2, 3 -\u003e 3, 4 -\u003e 4, 2 -\u003e 5\nAhora lo que es necesario hacer es por cada nodo de mayor prioridad a los de menor prioridad es necesario hacer la técnica explicada en el subcaso 2.Tomando en cuenta otra observación. Que solo es necesario procesar los nodos que solo tengan un color. Es decir si el nodo 0 tiene posibilidad de ser Rojo, Azul o Verde, no es necesario procesarlo. Sin embargo si un nodo solo puede ser azul, hay que eliminar esa posiblidad tanto de su padre como de sus hijos.\nImagen obtenida de http://aima.cs.berkeley.edu/newchap05.pdf\n1 // karbol100.cpp 2 // By Saul de Nova Caballero 3 4 //Librerias de la standard template library de c++(stl) 5 #include \u003calgorithm\u003e 6 #include \u003ccassert\u003e 7 #include \u003ccstdio\u003e 8 #include \u003ccstdlib\u003e 9 #include \u003ccstring\u003e 10 #include \u003ciostream\u003e 11 #include \u003clist\u003e 12 #include \u003cutility\u003e 13 14 using namespace std; 15 16 //Iterador sobre estructuras de datos. En este caso listas de la stl 17 #define TR(container, it) \\\\ 18 for(typeof(container.begin()) it = container.begin() ; it != container.end() ; ++it) 19 20 //Definicion de un par de la stl 21 typedef pair\u003cint, int\\\u003e pii; 22 23 //Constantes del programa 24 const int MAXN = 10002; 25 const int MAXM = 502; 26 const int MAXMEM = 2\\*MAXN; 27 28 //Clase para definir los hijos del arbol 29 //Es una lista con todos los hijos de cada nodo 30 class Graph { 31 public : 32 void addNode(int node, int value) { 33 nodes\\[node\\].push\\_back(value); 34 } 35 list\u003cint\\\u003e nodes\\[MAXN\\]; 36 }; 37 38 //Clase para cola de las busquedas en amplitud 39 //Es de tipo generica 40 template\u003cclass T\u003e 41 class Queue { 42 public : 43 Queue() { init(); } 44 void init() { p1 = 0; p2 = 1; } 45 void push(T val) { memory\\[++p1\\] = val; } 46 T front() { return memory\\[p2\\]; } 47 void pop() { p2++; } 48 bool empty() { return (p1 \u003c p2); } 49 50 private : 51 int p1, p2; 52 T memory\\[MAXMEM\\]; 53 }; 54 55 //Definicion de todas las variables del programa 56 int N, M, C, //Variables dadas 57 allowedColorsSize\\[MAXN\\], //La cantidad de colores posibles por nodo 58 parents\\[MAXN\\], //El padre de cada nodo 59 colorAssigned\\[MAXN\\]; //El color que le asigne al final al nodo 60 bool allowedColors\\[MAXN\\]\\[MAXM\\]; //Una matriz con todos los colores posibles por cada nodo 61 list\u003cint\\\u003e nodesOrder; //Una lista ordenada de mayor a menor por la profundidad de cada nodo 62 Graph tree; //Mi arbol 63 Queue\u003cpii\u003e searchDepth; //Una cola para la busqueda 64 65 //Regresa el color valido por cada nodo permitiendo que un nodo no sea de un color 66 int validColor(int node, int constraint = -1) { 67 for(int i = 0; i \u003c M; ++i) { 68 if(allowedColors\\[node\\]\\[i\\] \u0026\u0026 constraint != i) { 69 return i; 70 } 71 } 72 return -1; 73 } 74 75 //Funcion para la lectura de todas las variables y la inicializacion de las estructuras 76 //Los asserts son para probar que el codigo es correcto 77 /\\*Guarda en allowedColors los posibles colores por nodo en una matriz\\*/ 78 void read() { 79 int node, prohibited; 80 scanf(\"%d%d\", \u0026N, \u0026M); 81 assert(1 \u003c= N \u0026\u0026 N \u003c= MAXN-2); 82 allowedColorsSize\\[0\\] = M; 83 memset(allowedColors, true, sizeof(allowedColors)); 84 for(int k = 1; k \u003c N; ++k) { 85 scanf(\"%d\", \u0026node); 86 assert(0 \u003c= node \u0026\u0026 node \u003c N); 87 parents\\[k\\] = node; 88 tree.addNode(node, k); 89 allowedColorsSize\\[k\\] = M; 90 } 91 scanf(\"%d\", \u0026C); 92 for(int k = 0; k \u003c C; ++k) { 93 scanf(\"%d%d\", \u0026node, \u0026prohibited); 94 assert(0 \u003c= node \u0026\u0026 node \u003c N \u0026\u0026 0 \u003c= prohibited \u0026\u0026 prohibited \u003c M); 95 if(allowedColors\\[node\\]\\[prohibited\\]) { //Checa que los nodos no se repitan ya que se pueden repetir 96 allowedColors\\[node\\]\\[prohibited\\] = false; 97 allowedColorsSize\\[node\\] --; 98 } 99 } 100 } 101 102 /\\*Una busqueda en amplitud para \"linearizar el árbol\"\\*/ 103 void orderNodes() { 104 searchDepth.push(make\\_pair(0, 0)); 105 while(!searchDepth.empty()) { 106 pii value = searchDepth.front(); searchDepth.pop(); 107 nodesOrder.push\\_front(value.first); 108 TR(tree.nodes\\[value.first\\], it) { 109 searchDepth.push(make\\_pair(\\*it, value.second + 1)); 110 } 111 } 112 } 113 114 /\\*Checa por cada nodo de mayor a menor en la linearizacion, los colores posibles por nodo que solo tiene un color posible\\*/ 115 void enforceArc() { 116 TR(nodesOrder, it) { 117 int currNode = \\*it; 118 int parent = parents\\[\\*it\\]; 119 if(currNode != 0) { 120 if(allowedColorsSize\\[currNode\\] == 1 || allowedColorsSize\\[parent\\] == 1) { 121 if(allowedColorsSize\\[parent\\] == 1) { 122 swap(currNode, parent); 123 } 124 int color = validColor(currNode); 125 //printf(\"%d %d %d\\\\n\", currNode, parent, color); 126 if(allowedColors\\[parent\\]\\[color\\]) { 127 allowedColors\\[parent\\]\\[color\\] = false; 128 allowedColorsSize\\[parent\\] --; 129 } 130 } 131 } 132 //Si no hay colores posibles, no se puede resolver el mapa 133 if(allowedColorsSize\\[currNode\\] \u003c= 0) { 134 printf(\"-1\\\\n\"); 135 exit(0); 136 } 137 } 138 //Checa de nuevo si alguno de los colores no puede ser 139 for(int k = 0; k \u003c N; ++k) { 140 if(allowedColorsSize\\[k\\] == 0) { 141 printf(\"-1\\\\n\"); 142 exit(0); 143 } 144 } 145 } 146 147 //Hace un ciclo checando el menor color posible por nodo e imprime los colores menores 148 void findSolution() { 149 colorAssigned\\[0\\] = -1; 150 list\u003cint\\\u003e::iterator it = nodesOrder.end(); 151 do { 152 it --; 153 assert(0 \u003c= \\*it \u0026\u0026 \\*it \u003c N); 154 int color = validColor(\\*it); 155 if(colorAssigned\\[parents\\[\\*it\\]\\] == color) { 156 color = validColor(\\*it, color); 157 } 158 assert(0 \u003c= color \u0026\u0026 color \u003c M); 159 colorAssigned\\[\\*it\\] = color; 160 } while(it != nodesOrder.begin()) ; 161 162 for(int k = 0; k \u003c N; ++k) { 163 printf(\"%d\\\\n\", colorAssigned\\[k\\]); 164 } 165 } 166 167 int main() { 168 read(); 169 orderNodes(); 170 enforceArc(); 171 findSolution(); 172 return 0; 173 } "},"title":"Solución a \"K-Arbol\""},"/posts/solucion-a-la-venganza-de-silvio/":{"data":{"":"","consideraciones#Consideraciones":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 1 Autor: Freddy Román Cepeda Fuente: Freddy\nEste problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.\nSubtarea 1 Para obtener el primer grupo de puntos, sólo basta calcular $latex N^M$ multiplicando a $latex N$ por sí mismo $latex M$ veces, teniendo cuidado de que no haya overflow.\nSubtarea 2 Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar exponenciación binaria.\nSabemos que $latex x^0 = 1$, que $latex (x^n)^2 = x^{2n}$, y que $latex x * x^{n-1} = x^n$ para toda $latex x$ y $latex n$, por lo que podemos escribir la siguiente relación:\n$latex \\text{potencia}(N,M) = \\begin{cases} 1 \u0026 \\text{si } M = 0 \\\\ (potencia(N,M/2))^2 \u0026 \\text{si } M \\text{ es par} \\\\ N * (potencia(N,(M-1)/2))^2 \u0026 \\text{de lo contrario} \\end{cases}$\nAplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $latex O(log M)$, ya que en cada paso $latex M$ se reduce a la mitad.\nSubtarea 3 El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $latex M$. Para ello requerimos una observación adicional. Dividir entre $latex 2$ en base $latex 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.\nPodemos aprovechar esta observación guardando $latex M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $latex A$ es el arreglo donde guardamos los bits de $latex M$, está $latex 0$-indexado, tiene $latex k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $latex potencia2(N,k-1)$, donde $latex potencia2$ es:\n$latex \\text{potencia2}(N,i) = \\begin{cases} 1 \u0026 \\text{si } i \u003c 0 \\\\ (potencia2(N,i-1))^2 \u0026 \\text{si } A[i] = 0 \\\\ N * (potencia2(N,i-1))^2 \u0026 \\text{de lo contrario} \\end{cases}$\nSubtarea 4 El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.\nPor conveniencia, definamos $latex f(i)$ como el número que se obtiene tomando los elementos $latex [0..i]$ del arreglo $latex A$, y $latex f(-1) = 0$. Recordando que multiplicar por $latex 2$ en base $latex 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $latex f(i) = 2f(i-1) + A[i]$.\nAhora, es simple notar que $latex potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $latex potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.\nPor lo tanto, podemos escribir un ciclo en vez de utilizar recursión.\nEste algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.\nAquí está la implementación del algoritmo anterior:\nConsideraciones Hay que tener cuidado de que no haya overflow. Cuando un entero de $latex k$ bits se eleva al cuadrado, puede ahora tener a lo más $latex 2k$ bits. Como $latex m$ puede tener hasta $latex 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.\nTambién, varios competidores no consideraron el caso en el que se pide calcular $latex N^0 \\pmod 1$.","subtarea-1#Subtarea 1":"","subtarea-2#Subtarea 2":"","subtarea-3#Subtarea 3":"","subtarea-4#Subtarea 4":""},"title":"Solución a \"La Venganza de Silvio\""},"/posts/solucion-a-las-cartas-del-dr-lira/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 1 Autor: Joemmanuel Ponce Galindo Fuente: Topcoder\nBásicamente lo que nos pide el problema es encontrar el número de cartas que son distintas entre la configuración que es dada como entrada y una configuración donde las cartas estén alternadas.\nCómo se explica en el problema, sólo hay 2 estados posibles en los que una carta puede estar: negro (B) y blanco (W). En otras palabras, la observación clave para resolver el problema es darse cuenta que sólo existen 2 configuraciones que cumplen con las reglas que necesita Dr. Lira: Una configuración donde la primer carta es W, la siguiente B, la siguiente W y así sucesivamente. La otra configuración posible es donde las cartas empiezan con B, forzando la siguiente carta a ser W y esta a su vez forzando la siguiente carta a ser B.\nContar el número de caracteres diferentes entre una cadena y otra sólo requiere de un ciclo, por lo que la complejidad es lineal con respecto al tamaño de la cadena. Lo único que tenemos que hacer es entonces comparar la cadena dada como entrada con las configuraciones BWBW.. y WBWB…, contar el número de diferencias y dar como salida el mínimo de estos números."},"title":"Solución a Las Cartas del Dr. Lira"},"/posts/solucion-a-los-bloques-de-link/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 8 **Autor: **Alain Acevedo Mejía\nEs claro que no es posible probar todas las sucesiones posibles de movimientos de los bloques para encontrar la solución (a excepción de casos muy simples). El número de tales sucesiones puede ser infinito en caso de que se puedan formar ciclos de movimientos (lo cual sucede en muchos de lo casos de prueba), y aún en casos donde el número sea finito puede suceder que no se tenga tiempo para probarlos todos.\nUna primera observación crucial es que, en el estado del mapa, solo nos interesa saber donde están los bloques de hielo en cada paso, es decir, su ubicación es lo que determina lo que nos interesa del estado. No nos interesan los pasos previos que los llevaron a su posición, solo que sea el número mínimo posible. Tenemos un problema que puede ser resuelto realizando una búsqueda en amplitud.\n¿Cuántos estados es posible alcanzar? El mapa es a lo más de 40x40 espacios y las orillas siempre están bloqueadas, así que realmente tenemos 38x38=1444 espacios a los que quizá es posible llevar a los bloques. Tenemos dos bloques de hielo, así que hay (1444x1443)/2=1,041,846 formas de colocarlos en el mapa (hemos considerado aquí ya el hecho de que son indistinguibles). Para fines de la búsqueda el número que hemos calculado es en realidad una cota superior muy mala (mala en el sentido de que la cota superior mínima es muy inferior, es decir, calculamos “de más”), pues por la forma en que se mueven los bloques es claro que aún en el peor de los casos posibles la cantidad de estados a los que se puede acceder es mucho menor (¿cuál es el peor de los casos?). Es posible entonces emplear una búsqueda en amplitud común para resolver el problema, el espacio de búsqueda no es muy grande y es claro que podemos recorrerlo por completo.\nPara representar los estados requerimos tener la posición de ambos bloques, y nada más. Podemos emplear una arreglo de bool’s (boolean’s en pascal) de cuatro dimensiones para marcar los estados a los que se ha accedido. Para la cola, en el código que se anexa más abajo, empleamos un arreglo de dos dimensiones (una matriz) donde además de guardar la posición de los bloques de los estados guardamos la cantidad de movimientos realizados para llegar a cada estado. Para ver a que estados podemos llegar desde un estado dado basta con ver en que direcciones es posible mover los bloques y a qué posición llegarán.\nPara optimizar la búsqueda podemos hacer dos observaciones. La primera es que con nuestra representación de los estados podríamos llegar dos veces al mismo estado, ya que los dos bloques de hielo son para nuestros fines iguales. En el código de abajo es por ello que al llegar a un estado nuevo se marcan dos valores en el arreglo de bools como verdaderos, pues ambos representan en realidad el mismo estado.\nOtra observación es que para averiguar eficientemente a que estados se puede llegar desde un estado dado podemos precalcular, antes de realizar la búsqueda, para cada espacio vacío o con bloque de hielo, cuál es la posición del espacio bloqueado (con numeral # o con el botón A) más cercano en cada dirección. Así solo habrá que comparar esa posición con la del otro bloque de hielo para ver a dónde llegará el bloque tras su movimiento. Esto puede mejorar el tiempo de ejecución para un caso dado, aunque no siempre es así. En este problema para obtener los 100 puntos no hacen falta optimizaciones de este tipo, aunque es bueno tener este tipo de ideas en mente para problemas más complejos.\nEl siguiente código resuelve el problema:"},"title":"Solución a \"Los Bloques de Link\""},"/posts/solucion-a-los-callejones-de-guanajuato/":{"data":{"":"Problema: Los Callejones de Guanajuato.\nEn este problema se nos está pidiendo que, dado un grafo conexo no dirigido, encontrar un camino tal que pasemos por todas las aristas.\nEsta es una aplicación directa de un problema conocido de grafos, aunque no es tan común como otros problemas, estoy hablando de los ciclos Eulerianos.\nLa teoría nos dice que un grafo tendrá un camino euleriano si y sólo sí el grado de todos sus nodos menos dos es par; es decir, solo dos de sus nodos tienen un número impar de aristas saliendo de él, mientras que todos los demás tienen un número par de aristas.\nEsto es fácil de imaginar si nos ponemos a pensar que todo camino que entre a un nodo por una arista debe de tener otra arista por donde salir, a excepción claro del nodo inicial y el nodo final, que sólamente interactúan con el camino una vez.\nEs posible visitar un nodo más de una vez, pero por cada vez que entremos, tenemos que salir una vez, manteniendo su grado par. También es posible visitar el nodo inicio y fin más de una vez, pero por cada vez extra que entremos a estos nodos, tendremos que salir, manteniendo su grado impar.\nTambién es posible crear un ciclo euleriano (que a diferencia de un camino, empieza y termina en el mismo nodo) si todos los nodos del grafo tienen grado par.\nDe nuevo imaginemos un poco: en un grafo con un ciclo de euler podemos agregar una arista más entre nodo inicio y fin; ahora todos los nodos tienen grado par, y el camino de euler se volvió un ciclo.\nEn ningún otro caso se puede formar un camino o ciclo de eurler. En los grafos siguientes, se puede apreciar que cada uno tiene más de dos nodos con un grado impar y por lo tanto, no habrá ningún camino o ciclo de euler, no importa cuanto lo intentes.\nLo primero que viene a mente luego de leer esta teroría es que aunque es trivial saber si existe o no camino, ¿cómo lo vamos a encontrar si un grafo tiene ciclos? ¿cómo saber qué arista tomar para que al llegar al nodo final, hayamos pasado por todos?\nVeremos que este algoritmo es también muy fácil.\nImaginemos el siguiente grafo, en forma de casita, que es muy popular para este problema, tan popular, que hasta en las primarias se ve (aunque claro, a esa edad no se nos decía lo que estábamos haciendo).\nLo primero que hay que hacer es, usando un algoritmo de búsqueda en profundidad, encontramos un camino, el que sea, entre los nodos inicio y fin, se pueden repetir nodos, pero no aristas.\nAhora, si todos las aristas ya fueron visitadas, entonces ya terminamos, pero si no es así (lo cual es lo más probable), hay que buscar un nodo cualquiera, dentro del camino.\nSiempre que haya un nodo sin visitar, este va a tener al menos dos aristas disponibles (pues ya se explicó que siempre tendrán grado par), por lo tanto, ahora hay que hacer una segunda búsqueda, esta vez empezando desde el nodo con aristas disponibles, sin pasar por una arista que ya hemos visitado.\nSi el grafo tiene un camino de Euler, eventualmente vamos a regresar al nodo del que partimos. Siempre. Esto es verdad debido a que, como no nos quedan aristas con grado impar, una de las aristas en ese nodo debe de formar un ciclo con otra de las aristas que salen de ese nodo. Si no hubiera ciclo sería porque el camino termina abruptamente en un nodo, lo cual sería imposible porque esto significaría que ese nodo al final tendría grado impar, y ya usamos nuestros dos nodos impar.\nSi seguimos este algoritmo para todos los nodos que aún tengan aristas sin visitar, eventualmente visitaremos todas, lo único que hay que hacer ahora es tomar las aristas en el orden correcto para hacer las llamadas a la función.\nEn el caso en que todos los nodos tengan grado par, se sigue exactamente el mismo algoritmo, con la diferencia de que el nodo inicio y el nodo fin son el mismo.\nComo nota cultural, existe un problema similar, el cual en vez de visitar todos las aristas, te pide visitar todos los nodos. Este problema se llama Camino Hamiltoniano, y a diferencia de el camino de euler, este problema es NP completo, lo cual significa que no existe una solución que resuelva el problema en tiempo polinomial."},"title":"Solución a \"Los Callejones de Guanajuato\""},"/posts/solucion-a-mapas-de-bits/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 12 Autor: Jorge Alberto González Martínez Fuente: Jorge Alberto González Martínez\nEn el problema se describen dos formas de representar un mapa de bits.\nLa forma bidimensional es simplemente utilizar una matriz para representar los bits. La forma por descomposición consiste en agrupar los bits similares y solo escribir el valor de los bits similares. En caso de que no sean similares todos los bits en un mapa de bits dado, se procede a dividir en cuatro secciones, imprimir la letra D y procesar cada uno de los cuartos de la misma manera, tal como se lee en la descripción del problema.\nLa solución a este problema consistía en programar el método descrito. Este método inherentemente está basado en la técnica de divide y vencerás.\nA continuación, un pseudo-código que muestra la forma de llevar a cabo la transformación de un mapa de bits bidimensional a la forma reducida:\nReduceMapa(mapaDeBits) Si todos los elementos en mapaDeBits son iguales Imprime el valor y termina Si no Imprime D ReduceMapa(mapaDeBits.superiorIzquierdo) ReduceMapa(mapaDeBits.superiorDerecho) ReduceMapa(mapaDeBits.inferiorIzquierdo) ReduceMapa(mapaDeBits.inferiorDerecho) El método para hacer la transformación inversa es muy parecido, sólo que para imprimir la equivalencia hay que comenzar con un mapa de bits bidimensional que nos sirva de variable auxiliar para hacer la conversión. Esta variable auxiliar se puede declarar de manera global y, cuando el método recursivo termine, simplemente imprimir su contenido:\nAmplificaMapa(mapaDeBits, sección) Si mapaDeBits comienza con un valor Rellenar sección del mapa bidimensional con el valor Si no AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.superiorIzquierda) AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.superiorDerecha) AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.inferiorIzquierda) AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.inferiorDerecha) La primera vez que se llama a la función AmplificaMapa se debe entregar la representación de la forma por descomposición del mapa de bits en la variable mapaDeBits y la sección que se entrega inicialmente es todo el mapa de bits. Esto puede ser manejado por filas y columnas.\nA continuación se muestra una implementación en C++ que resuelve el problema. Nótese cómo se maneja la sección sobre la que se está trabajando con cuatro variables: tl_row, tl_col, br_row, br_col. El nombre de las variables proviene de top-left row, top-left colum, bottom-right row y bottom-right colum respectivamente. Representan los índices (fila,columa) de las esquinas superior izquierda e inferior derecha."},"title":"Solución a \"Mapas de bits\""},"/posts/solucion-a-mario-reloaded/":{"data":{"":"","idea#Idea":"","implementacion#Implementacion":"","observaciones#Observaciones":"","tarea#Tarea":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 8 **Autor: **Pavel Herrera Dominguez)\nObservaciones Lo primero es ver como se modelan los estados del problema sin pensar en que Mario puede tomar los atajos, únicamente pensar en las llaves, claramente existen $latex n\\times2^m$ estados, pues no importa el orden en que se toman las llaves solo las llaves que se tienen al llegar a cada puerta. A partir de aquí nos referiremos como estado a la puerta y las llaves que trae Mario.\nLa segunda observación es ver como afecta llegar a una puerta con cierto juego de llaves, osea a cada estado. Cada vez que visitamos un estado todos los estados ya visitados que tienen el mismo juego de llaves se actualiza instantáneamente. Esto se puede entender como si únicamente el juego de llaves definiera el estado, lo que nos lleva a pensar que el problema es saber que puertas pertenecen a qué juego de llaves.\nDe la observación anterior podemos pensar que si mantenemos una lista de puertas ya visitadas para cada juego de llaves, cuando algún estado (puerta, juego de llaves) se visita con un menor tiempo, todas las puertas alcanzadas con ese juego de llaves deben ser actualizadas y sus respectivos vecinos.\nIdea La idea es hacer una especie de búsqueda en amplitud la cual tome en cuenta las observaciones anteriores. Esto es una búsqueda que visite los estados (puerta, llave) y conserve una lista de las puertas alcanzables con cada juego de llaves.\nImplementacion Tarea Pensar si es posible hacer la búsqueda sin usar los estados (puerta, juego de llaves)."},"title":"Solución a \"Mario Reloaded\""},"/posts/solucion-a-metro/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 12 **Autor: **Alain Acevedo Mejía\nEl problema en cuestión se reduce a encontrar un árbol de expansión mínima. La solución es una aplicación directa de alguno de los algoritmos existentes para ello (bien implementada), por lo que hablaré brevemente sobre una de las posibilidades y daré referencias donde puedan encontrar información más detallada.\nPara encontrar el costo mínimo de unir todas las estaciones debemos encontrar el árbol de expansión mínima de la gráfica en cuestión (es decir, una subgráfica conexa que una todos los vértices de la gráfica original y cuyo peso (la suma de los costos de todas sus aristas) sea el mínimo posible (siempre es un árbol)). Para ello una opción es usar el algoritmo de Kruskal: Ordenamos las aristas por su peso y vamos agregando cada arista de peso mínimo que no cree un ciclo en la gráfica. Hacemos esto hasta haber conectado todos los vértices de nuestra gráfica. Por la cantidad de aristas que tenemos requerimos ordenar eficientemente y verificar si las aristas forman un ciclo o no eficientemente en cada paso, de lo contrario el programa no correrá en tiempo.\nPara verificar si se forma o no un ciclo agregando una determinada arista empleamos el algoritmo conocido como Union Find, que se explica ampliamente en las secciones 16.7, 16.8 y 16.9 del libro Problemas y Algoritmos de Luis E. Vargas Azcona. Es importante mencionar que para obtener los 100 puntos en el problema es necesario implementar las optimizaciones que se mencionan (y aunque no fuera así no está de más que las conozcan).\nAdemás del libro de Luis E. Vargas, que recomiendo ampliamente, sugiero la página de Pier Guillen http://pier.guillen.com.mx/ , que en -\u003eAlgorithms -\u003e10. Gráficas -\u003e10.6 Árboles Mínimos Generadores desarrolla el tema en cuestión. Y claro, no está de más que consulten el tema en el libro Introduction to Algorithms de Thomas H. Cormen, que en la tercera edición trabaja el tema en el capítulo VI. Graph Algorithms -\u003e23 Minimum Spanning Trees.\nEl siguiente código resuelve el problema:"},"title":"Solución a \"Metro\""},"/posts/solucion-a-minecraft/":{"data":{"":"","para-los-100-puntos#Para los 100 puntos":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 5 **Autor: **Enrique Lira Vargas\nEste problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.\nPara los primeros 50 puntos Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.\nPara los 75 puntos Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.\nPara los 100 puntos Esta solución era para aquellos que supieran hacer una búsqueda utilizando una cola de prioridad. La idea es que al sacar un elemento de la cola siempre nos dé aquel al que se puede llegar con la menor cantidad de movimientos. Este procedimiento es idéntico a una búsqueda en amplitud solo que se utiliza una cola de prioridad. En la solución hago uso de un montículo como cola de prioridad.","para-los-75-puntos#Para los 75 puntos":"","para-los-primeros-50-puntos#Para los primeros 50 puntos":""},"title":"Solución a \"Minecraft\""},"/posts/solucion-a-mocha-hojas/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 17 Autor: Freddy Román Cepeda Fuente: Alberto José Ramírez Valadez\nPara simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.\nConsideremos el caso de un árbol con un solo nivel. Ya que sólo podemos restarle a los pesos de las hojas, evidentemente el peso máximo del árbol se alcanza cuando se emparejan todas las hojas al peso de la hoja con peso mínimo.\nAhora, consideremos un árbol con dos niveles. Si la raíz tiene $latex k$ hijos, para cada hijo $latex i$ sea $latex h_i$ el subárbol de $latex i$, $latex b_i$ el número de hojas de $latex h_i$, y $latex c_i$ el peso del árbol obtenido de realizar el procedimiento del párrafo anterior a $latex h_i$. Si todas las $latex c_i$ son iguales, entonces nuestro árbol está balanceado. De lo contrario, debemos restar aún más para poder balancearlo. Sin embargo, también necesitamos que cada $latex h_i$ continúe estando balanceado. La única manera que le podemos restar peso a $latex h_i$ sería restarle la misma cantidad de peso a cada una de sus hojas. Entonces, a cada $latex h_i$ sólo podemos restarle peso en múltiplos de $latex b_i$. Como queremos maximizar el peso del árbol resultante, necesitamos encontrar el número más grande $latex x$ tal que a todos los $latex c_i$ les podamos restar un múltiplo de su respectivo $latex b_i$ para obtener $latex x$. Notemos también que $latex c_i$ es un múltiplo de $latex b_i$ porque los nodos internos del árbol no tienen peso. Si $latex m$ es el mínimo común múltiplo de todos los $latex b_i$, entonces $latex x$ también es un múltiplo de $latex m$. Entonces, el máximo $latex x$ posible es igual al múltiplo de $latex m$ más grande que sea menor o igual a todos los $latex c_i$. Por lo tanto, el valor máximo obtenible del árbol completo es igual a $latex kx$. Por último, si tuviéramos que restarle más peso a este árbol pero mantenerlo balanceado, es evidente que lo menos que podemos restar para mantenerlo balanceado es $latex km$, y si seguimos restando $latex km$ continuará balanceado.\nDe esta observación podemos obtener la solución para cualquier árbol. Reusando la notación del párrafo anterior, $latex k$ es la cantidad de hijos de la raíz, $latex h_i$ el subárbol del $latex i$ésimo hijo, y $latex c_i$ el peso del árbol obtenido de realizar recursivamente el procedimiento de éste párrafo a $latex h_i$ (o el del anterior si $latex h_i$ tiene 2 niveles). Ahora $latex b_i$ es igual a lo mínimo que le podemos restar a $latex h_i$ y que continúe balanceado. El análisis del párrafo anterior también es correcto para la nueva definición de $latex b_i$ y $latex c_i$.\nEl código siguiente implementa esta solución:"},"title":"Solución a \"Mocha Hojas\""},"/posts/solucion-a-numeros-libres/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Problemset 1 Autor: Freddy Román Cepeda Fuente: Edgar Augusto Santiago Nieves\nPara resolver este problema hacía falta tener en mente la definición de square-free. Como tanto $latex a$ y $latex b$ no son divisibles por el cuadrado de un primo, la única manera de que su producto deje de ser square-free sería que ambos compartieran un factor primo.\nPara obtener todos los puntos de la primer subtarea bastaba con computar $latex a \\times b$ e iterar sobre todos los números menores a ese producto y revisar si es divisible por el cuadrado de alguno de ellos.\nPara obtener los puntos de la segunda subtarea era suficiente iterar hasta $latex \\max(\\sqrt{a}, \\sqrt{b})$, para factorizar a $latex a$ y $latex b$.\nPor último, para obtener el resto de los puntos bastaba notar que si $latex a$ y $latex b$ comparten un factor primo, entonces su máximo común divisor es distinto de 1.\nEl siguiente código implementa esta solución:"},"title":"Solución a \"Números Libres\""},"/posts/solucion-a-panoramas/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 17 Autor: Miguel Ángel Covarrubias Fuente: Miguel Ángel Covarrubias\nEl problema es un Steiner tree problem (un MST pero donde sólo hay que conectar un subconjunto de nodos) pero con costo por nodo en vez de por arista. El grafo de los panoramas es un árbol más un ciclo. Para un árbol una solución es poner como raíz a $latex s_1$ y para cada $latex s_i$ marcar los nodos en su camino hacia la raíz. Se puede usar DP o recursión para calcular el mínimo numero de vertices que conectan todos los nodos interesantes y pasan por la raíz para cada subárbol.\n$latex \\mathrm{dp}_r=\\mathrm{interesante}(r)\\ \\mathrm{si}\\ \\Sigma_h\\mathrm{dp}_h=0$ $latex \\mathrm{dp}_r = \\Sigma_h\\mathrm{dp}_h+1\\ \\mathrm{si}\\ \\Sigma_c\\mathrm{dp}_h\u003e0$\n$latex h$ es un hijo de $latex r$. La arista extra $latex (u,v)$ en el ciclo $latex c$ permite usar otros caminos a lo largo de $latex c$. Tales caminos deben conectar todos los nodos en $latex c$ que tengan nodos interesantes en su árbol después de quitar las aristas del ciclo $latex E-c$. Etiquetemos tales nodos con un uno y los demás nodos del $latex c$ con un cero. Para $latex E-(u,v)$ el ciclo sólo no cubre los últimos ceros. Para encontrar la solución sólo basta encontrar la secuencia de ceros más grande. En el siguiente diagrama, la arista que falta es $latex (u,v)$. La DP sólo no usa el último cero, pero es mejor no usar los dos ceros que están adyacentes.\n0 1 / \\\\ 1 0 \\\\ / 1-0 Este código implementa la solución."},"title":"Solución a \"Panoramas\""},"/posts/solucion-a-planetas/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Problemset 4 Autor: Freddy Román Cepeda Fuente: Edgar Augusto Santiago Nieves\nLa observación principal de este problema es que siempre hay $latex N-1$ lugares estables para el meteorito, y que cada uno de éstos se encuentra entre parejas consecutivas de planetas. Primero notemos que ningún lugar estable puede estar más a izquierda que todos los planetas, ya que la fuerza neta sobre éste lo haría moverse a la derecha. Por la misma razón, no pueden haber lugares estables después del último planeta hacia la derecha.\nAhora, para ver que siempre hay un lugar estable entre cualquier pareja consecutiva de planetas hay que analizar la función que describe la fuerza entre el meteorito y el planeta: $latex \\frac{1}{\\left | X_i - M \\right |}$. Supongamos que el meteorito está entre los planetas $latex i$ e $latex i+1$. Cuando $latex M \\approx X_i$ la fuerza que atrae al meteorito hacia el planeta $latex i$ es suficientemente grande para forzar al meteorito a moverse a la izquierda sin importar la fuerza de los planetas que se encuentren a la derecha (nota que el denominador se hace muy pequeño). Lo mismo ocurre con el planeta $latex i+1$ cuando el meteorito está muy cerca de él. Pero esto quiere decir que existe un único punto $latex p$ entre los dos planetas en el que la fuerza neta sobre el meteorito es 0. (Este argumento se puede formalizar utilizando cálculo.)\nAdemás, es sencillo observar que el meteorito se movería a la izquierda si estuviera entre el planeta $latex i$ y el punto $latex p$, y a la derecha si estuviera entre el punto $latex p$ y el planeta $latex i+1$. Por lo tanto, podemos hacer una búsqueda binaria para encontrar el punto $latex p$ para cada pareja de planetas consecutivos.\nComo hay $latex N-1$ parejas y calcular la fuerza neta sobre el meteorito en algún punto arbitrario toma tiempo $latex O(N)$, la complejidad total de este algoritmo es $latex O(N^2 I)$ donde $latex I$ es la cantidad de iteraciones que realice la búsqueda binaria. También hay que ordenar los planetas, ya que la descripción del problema no asegura que vendrán ordenados. Por lo tanto, la solución final tiene complejidad $latex O(N \\lg N + N^2 I)$.\nEl siguiente código implementa esta solución:"},"title":"Solución a \"Planetas\""},"/posts/solucion-a-poema-equino/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Problemset 5 Autor: Freddy Román Cepeda Fuente: Edgar Augusto Santiago Nieves, Freddy Román Cepeda\nLos límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $latex (\\text{poema},\\text{fila caballo}_1,\\text{columna caballo}_1,\\text{fila caballo}_2,\\text{columna caballo}_2)$, solamente hay $latex 100 \\times (4 \\times 10)^2 = 160,000$ estados distintos.\nAdemás, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.\nVarios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!\nLa siguiente solución implementa las simplificaciones descritas anteriormente."},"title":"Solución a \"Poema Equino\""},"/posts/solucion-a-problema/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 10 **Autor: **Hugo Dueñas\nPrimero, dado una secuencia $latex A$ denotaremos por $latex s(A)$ a la suma de los elementos de A. Entonces podemos replantear el problema como: Dada una secuencia $latex S$ debemos de econtrar una subsecuencia $latex A$ de $latex S$ tal que $latex s(A) - (s(S) - s(A))$ sea la minima posible.\nAhora, como $latex s(A) - (s(S) - s(A)) = 2 \\times s(A) - s(S)$, entonces tenemos que minimizar $latex 2 \\times s(A) - s(S)$ que es lo mismo que minimizar $latex s(A) - s(S)/2$. O sea, debemos de encontrar una subsecuencia $latex A$ cuya suma esté lo más cercana a la mitad de la suma de $latex S$, en particular podemos restringir nuestra búsqueda a las subsecuencias cuya suma sea menor o igual a $latex s(S)/2$.\nSe plantea para este problema una solución de tipo Programación Dinámcia que corre sobre los elementos de la secuencia $latex S$ y considera todas las posibles diferentes sumas de subsecuencias cuyos elementos tienen índices menores o iguales al actual y cuya suma no excede $latex s(S)/2$. Se tendrán entonces $latex n \\times s(S)/2$ posibles estados y cada uno podrá ser procesado en tiempo constante ya que solo hay dos trancisiones posibles para cada estado: Se toma el elemento actual dentro de la subsecuencia o no. Por lo tanto la solución tendrá una complejidad temporal de $latex O (n \\times s(S))$.\nA continación se lista una implementación en C++ de la solución:"},"title":"Solución a \"Problema\""},"/posts/solucion-a-quimicos/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 6 Autor: Luis Héctor Chávez (lhchavez) Fuente: Ethan Jiménez Vargas\nÉste es un problema que tiene una solución elegante y determinística pero requiere algoritmos avanzados bastante complicados. Lo bueno es que es posible aproximar a la solución utilizando fuerza bruta mediante backtracking.\nEl problema nos pide encontrar una manera de asignar sustancias a los tubos y después mezclarlas con las dos operaciones disponibles (suma y diferencia absoluta) para terminar con un acomodo homogéneo de sustancias: la diferencia entre el tubo con más cantidad y con menos cantidad de sustancia debe ser lo más pequeña posible. Una manera de hacerlo es proponer un intervalo $latex [a,b]$ y ver si es posible asignar sustancias y aparear los tubos de manera que la cantidad de sustancia resultante de la mezcla en todos los tubos esté contenido dentro del intervalo. Para acelerar el proceso, puedes elegir los intervalos haciendo una búsqueda binaria de acuerdo a su ancho $latex b-a$, porque a fin de cuentas lo que nos pide el problema es precisamente el ancho mínimo. Para cada intervalo propuesto $latex [a,b]$, podemos hacer un grafo con $latex 2N$ nodos (uno para cada tubo), agregando un arco entre dos nodos $latex A$ y $latex B$ si $latex A+B\\in[a,b]$ ó $latex |A-B|\\in[a,b]$. Después, buscamos un apareamiento máximo en el grafo: buscamos el conjunto de arcos con cardinalidad máxima tal que cada nodo tenga a lo más un arco incidente. Esto se puede encontrar con el algoritmo de Edmonds (también conocido como el Blossom algorithm por la forma de los ciclos de longitud impar) en tiempo $latex O(|2N|^4)$, lo cual encontraría todas las soluciones en solo un par de segundos.\nLamentablemente la implementación del algoritmo de Edmonds es bastante complicada. Como este es un problema de solo-salida y todo se vale, en vez de hacer el intento por implementarlo, utilicé la librería Boost de C++ que ya tiene muchísimos algoritmos de grafos ya implementados.\nAhora, si no se te ocurre usar el algoritmo de Edmonds o no tienes acceso a Boost, aún así puedes obtener una cantidad decente de puntos usando una heurística: podemos intentar hacer un apareamiento máximo usando fuerza bruta, rindiéndonos si el problema suena muy complicado y asumimos que no existe un apareamiento. Una fuerza bruta naïve con un contador que se decrementa cada vez que se llama la función de búsqueda es más que suficiente. Haciendo un par de modificaciones al algoritmo anterior nos da una solución que nos da el 80% de los casos bien:\nClaro que si te quieres ver greedy, puedes subirle al número de intentos, pero posiblemente no haya suficiente tiempo en el concurso para que termine. Si llegas a utilizar estas técnicas “impuras”, asegúrate primero de obtener cualquier solución que te de puntos antes de subirle para encontrar mejores respuestas."},"title":"Solución a \"Químicos\""},"/posts/solucion-a-splatoon/":{"data":{"":"Problema: Splatoon.\nEste problema pide llevar a un inkling desde el inicio de una calle hasta el final siguiendo sus reglas de movimiento.\nIgnoremos por un momento el hecho de que los inklings pueden pintar el piso y con ello alterar la calle en donde se realiza la carrera. Si los inklings no tuvieran esta habilidad, se puede hacer un algoritmo de fuerza bruta intentando todas las operaciones posibles, es decir, hacer una búsqueda en amplitud para encontrar el camino más corto, en donde el estado está representado únicamente por la posición en donde se encuentre el inkling.\nRecuerda que en las búsquedas es importante marcar visitados para que la complejidad del algoritmo no se vuelva exponencial.\nPara cada posición, se tienen dos posibles operaciones, saltar, o caminar, ambas toman 1 segundo y la distancia a la que se llega depende directamente del color sobre el que se está parado. El movimiento de saltar es muy fácil pues solo hay una casilla donde se puede caer, pero el movimiento de avanzar difiere cada vez pues depende directamente del color de las siguientes casillas.\nEs posible hacer un ciclo para ver hasta donde puedes llegar avanzando desde la casilla en donde estás, y agregar a la búsqueda el lugar más lejano a donde puedas llegar. Sin embargo, si únicamente registramos la última casilla a donde se puede llegar, casos como el siguiente se nos escaparán:\nEn la solución superior, primero se avanza todo lo que se puede en la pintura naranja hasta llegar a la casilla azul, de ahi ya sea saltando o avanzando únicamente se puede llegar a la casilla blanca, y de ahí, no importa lo que hagas, te tomará dos segundos llegar al final.\nEn cambio, en la solución inferior, se avanza solo 3 casillas en la pintura naranja, lo cual es 1 casilla menos del máximo, de ahí se hace un salto el cual nos deja de nuevo en pintura naranja, desde donde podemos llegar caminando hasta el final en un total de tan solo 3 segundos, 1 segundo menos que la solución anterior.\nPor lo tanto, no es suficiente visitar la distancia máxima, también hace falta visitar la distancia máxima - 1. Si intentamos hacer cosas similares con otro color de pintura, o más deteniéndonos todavía más atrás del máximo, no hay realmente ninguna ventaja, por lo que el caso presentado anteriormente es el único caso especial.\nUna búsqueda en amplitud bien hecha que considere este caso sacará 30 puntos, una que no considere este caso sacará únicamente 5 puntos. Da perfectamente en tiempo y memoria porque a lo más tendremos un total de 1000 estados. Sin embargo, la parte interesante de este problema es que los inklings son capaces de alterar el estado de la calle usando la pintura que traen en su tanque para poder recorrer más rápido la calle, utilizando hasta D disparos de tinta.\nEn este caso, necesitamos agregar una segunda dimensión al estado de nuestra búsqueda, ahora no sólamente es suficiente con guardar el lugar en donde estamos, sino que es necesario guardar también cuanta tinta queda en el tanque. En este caso, agregamos una operación más, la cual es pintar, la cual cuesta 0 segundos, nos avanza 0 casillas y nos quita una unidad D de pintura.\nSi hacemos esto, nuestro espacio de búsqueda crece del N que era en la solución de 30 puntos, a N x D, lo cual es 1000 x 1000 y aún da en tiempo y memoria.\nNo obstante, la operación de pintar altera el mapa, por lo que si no guardamos también en el estado que las casillas siguientes ahora son de otro color, pintar no servirá de nada. Podríamos agregar una dimensión más a la búsqueda para considerar este caso, pero esto solo le agregaría complejidad innecesaria a la búsqueda.\nLa clave está en que pintar toma 0 segundos, por lo que podemos convertir la operación de pintar en una operación compuesta, que sea pintar y avanzar.\nPintar y avanzar toma 1 segundo, y nos permite avanzar 4 casillas hacia adelante siempre, por lo que hacer una operación de pintar y avanzar nos lleva del estado (i, d) al estado (i + 4, d - 1) con un costo de 1 segundo.\nEl detalle con esta solución, es que estamos ignorando de nuevo el caso especial explicado en la solución de 30 puntos, por lo que si se nos olvida que es posible ahorrarnos un segundo en ciertas ocasiones, sacaremos entre 35 y 90 puntos dependiendo de la implementación.\nPara sacar los 100 puntos, es necesario agregar una operación más, la cual es pintar, avanzar y saltar, la cual nos lleva del estado (i, d), al estado (i + 6, d - 1) con un costo de 2 segundos. Y como esta operación toma 2 segundos en vez de tan solo 1, no es suficiente con utilizar una cola común y corriente para hacer la búsqueda en amplitud, sino que es necesario utilizar una estructura de datos más avanzada, como una cola de prioridad o un montículo que nos ayude a ordenar los estados y elegir siempre con el tiempo más pequeño."},"title":"Solución a \"Splatoon\""},"/posts/solucion-a-suma-manhattan/":{"data":{"":"Concurso: Preselectivo para la IOI 2015, Etapa 1, Problemset 1 Autor: Freddy Román Cepeda Fuente: Freddy Román Cepeda\nEste problema requería manipular con cuidado la expresión que había que computar. Recordemos que nos piden computar\n$latex \\sum_{0 \\leq i \u003c j \u003c N} manhattan(S_i,S_j).$\nPara resolver la primer subtarea bastaba con iterar sobre todas las parejas de puntos y calcular su distancia. Esto corre en tiempo cuadrático y no es suficiente para obtener todos los puntos.\nLa siguiente subtarea era una pista: se puede computar la distancia Manhattan de dos puntos considerando por separado sus coordenadas en $latex x$ y $latex y$. Ahora nos preocuparemos por calcular la siguiente expresión:\n$latex \\sum_{0 \\leq i \u003c j \u003c N} |a_i - a_j|.$\nDonde $latex a$ son las coordenadas en $latex x$ o $latex y$. El problema está en el valor absoluto. La manera más sencilla de deshacernos de él es ordenar la secuencia $latex a$, de tal manera que $latex a_i \\leq a_j$. Entonces tenemos:\n$latex \\sum_{0 \\leq i \u003c j \u003c N} |a_i - a_j| = \\sum_{0 \\leq i \u003c j \u003c N} |a_j - a_i| = \\sum_{0 \\leq i \u003c j \u003c N} a_j - a_i.$\nLa primer igualdad es verdadera porque $latex |x| = |-x|$ para cualquier $latex x$. La segunda es porque como ahora $latex a$ está ordenado, como $latex a_j \\geq a_i \\implies a_j - a_i \\geq 0$, el valor absoluto no hace nada.\nPodemos entonces separar la suma en dos términos:\n$latex \\sum_{0 \\leq i \u003c j \u003c N} a_j - \\sum_{0 \\leq i \u003c j \u003c N} a_i.$\nAnalicemos el primer término. Estamos sumando sobre todas las $latex j$ tantas veces haya una $latex i$ menor que ella. Eso quiere decir que cada $latex a_j$ la vamos a sumar $latex j$ veces (nota que $latex a_0$ la sumamos $latex 0$ veces).\nEl segundo término nos dice que sumaremos todas las $latex a_i$ tantas veces haya una $latex j$ mayor a ella. Eso quiere decir que cada $latex a_i$ la vamos a sumar $latex N-i-1$ veces (nota que $latex a_{N-1}$ la sumamos $latex 0$ veces).\nJuntando esas ideas, entonces tenemos:\n$latex \\sum_{j = 0}^{N-1} j \\cdot a_j - \\sum_{i = 0}^{N-1} (N - i - 1) \\cdot a_i$\n$latex = \\sum_{i = 0}^{N-1} i \\cdot a_i - \\sum_{i = 0}^{N-1} (N - i - 1) \\cdot a_i.$\n$latex = \\sum_{i = 0}^{N-1} (i - (N - i - 1)) \\cdot a_i.$\n$latex = \\sum_{i = 0}^{N-1} (2i - N + 1) \\cdot a_i.$\nY con eso terminamos: ahora tenemos una expresión que podemos computar fácilmente en tiempo lineal. Hay que tener cuidado al computar esto: La primera observación es que hay que estar tomando módulo después de cada operación porque en cualquier momento puede haber un overflow. Algunos competidores obtuvieron 60 puntos en este problema por no tomar esto en cuenta. La segunda observación es que el término $latex (2i - N + 1) \\cdot a_i$ no necesariamente cabe en un entero signado de 32 bits – hacía falta utilizar enteros de 64 bits para realizar este cálculo.\nAquí está mi código que implementa la solución anterior."},"title":"Solución a \"Suma Manhattan\""},"/posts/solucion-a-super-nieves-bros/":{"data":{"":"**Concurso: **Preselectivo para la IOI 2014, Etapa 1, Problemset 6 Fuente: Topcoder\nEste problema es una adaptación del problema ArcadeManao que apareció en el SRM 576 (Abril 2013) de Topcoder. Los detalles de la solución explicada la pueden en el respectivo Match Summary.\nLa idea general de este problema es muy sencilla: En base a los límites, la primera observación es que el mapa no es muy grande y en el peor caso, la escalera más alta es de tamaño 50. Hay que notar que no nos piden la ruta más corta para capturar la moneda, más bien cuál es el menor tamaño con el que podemos llegar.\nLa idea principal es ir probando los tamaños de escalera, empezando desde 0 hasta 50, y para cada tamaño probar si es posible llegar a la moneda o no. Si empezamos probando los tamaños de menor a mayor, la primer escalera que lo logré será el resultado.\nPara probar que se puede llegar a la moneda, se puede usar búsqueda en amplitud o búsqueda en profundidad. Dado que el tamaño del mapa es relativamente pequeño, es posible usar búsqueda en profundidad y pararla en cuanto “pisemos” la moneda (de nuevo, no nos interesa saber si la ruta que la búsqueda siguió para dar con la moneda fue la menor de todas las posibles, con llegar a ella basta).\nEste par de observaciones son suficiente para resolver el problema. Si el lector quiere más reto, hay otra observación que permitiría reducir el número de búsquedas que hay que hacer de 50 a 6…\nEsta es la solución de charlyhlms usando búsqueda en profundidad.\nEsta es la solución de spleensarethebest usando búsqueda en amplitud y optimizando la cantidad de pruebas de tamaños de escaleras que hay que hacer."},"title":"Solución a \"Super Nieves Bros\""},"/posts/solucion-a-teclado-roto/":{"data":{"":"Concurso: Preselectivo para la IOI 2013, Etapa 1, Examen 2** Autor: **Jorge Alberto González Martínez\nLos temas para el examen donde apareció este problema eran pilas, colas y búsqueda binaria. Después de haber estudiado los temas, es buena idea combinar la teoría aprendida.\nEl problema del teclado roto describe una serie de operaciones en las que es necesaria una estructura en la que sea posible agregar elementos por ambos lados (izquierda y derecha). La descripción del problema muestra las restricciones, que no superan los 100, 000 elementos, por lo que es posible hacer un arreglo estático de caracteres de ese tamaño.\nEn el caso de mi solución, para que sea más clara la inserción, también utilizo memoria auxiliar para guardar las palabras que se van a insertar en la estructura de datos.\nEn el código que se muestra abajo se describe la forma en la que se implementa y opera la estructura mencionada anteriormente:"},"title":"Solución a \"Teclado Roto\""},"/posts/solucion-a-temblor/":{"data":{"":"Problema: Temblor\nPrimero que nada, tratemos de entender qué es lo que se nos pide, pues es un problema poco tradicional: Dado un mapa de a lo más 4x4, hay que dar una serie de instrucciones que, sin importar en donde te encuentres en el mapa, logre llevarte a una salida; esta secuencia además, debe de ser la más pequeña posible.\nEste es el caso de ejemplo:\nLa solución correcta es ONNEE, pues con esas instrucciones, podemos salir no importando en que lugar estemos (el lugar inicial está marcado con un punto rojo):\nEn el caso 1, las instrucciones ONN no hacen nada pues hay paredes, y las instrucciones EE nos sacan del mapa. En el caso 2, ONN no hacen nada de nuevo y la primera E nos saca del mapa (la última E ya no importa). En el caso 3, O no hace nada, pues hay pared, N nos sube un lugar, la segunda N no hace nada, y EE nos saca del mapa. El caso 4, O nos lleva a la izquierda, donde se vuelve el mismo caso que el caso 3. En el caso 5, O no hace nada, y NN nos lleva al caso 1. Y finalmente, en el caso 6, O nos lleva al caso 5 y de ahí podemos salir. Es mucho más fácil ver la solución si vemos a todos los olímpicos moverse al mismo tiempo:\nEsto ejemplifica dos cosas: en primer lugar, el camino no debe de ser óptimo para cada uno, sino para todos en general, por ejemplo, el punto que inicia en la esquina superior derecha (cerca de la salida), podría salir yendo hacia la derecha, y saliendo en un único movimiento, pero si lo primero que hacemos es un “este”, estaremos complicando más las cosas para el resto de los olímpicos atrapados. En segundo lugar, puede haber más de un olímpico en un mismo lugar, y una vez que hay dos olímpicos en un mismo lugar, no importa realmente cuántos hay, sino que hay al menos 1 olímpico en ese lugar:\nO bien, si lo vemos como unos y ceros:\nDonde 1 significa hay al menos un olímpico ahí y 0 significa no hay ningún olímpico ahí.\nPor lo tanto podemos concluir que nuestra tarea es convertir un tablero lleno de 1’s en un tablero lleno de 0’s.\nA estas alturas, ya tenemos lo suficiente como para hacer una búsqueda en amplitud sobre el problema. Los estados de nuestro espacio de búsqueda están representados por un mapa de NxM lleno de 1’s y 0’s y las transiciones entre un estado y otro son las operaciones Norte, Sur, Este y Oeste.\nNuestro árbol de búsqueda empezaría más o menos así:\nSolo tendríamos que hacer una búsqueda en amplitud hasta llegar al mapa con puros ceros y reconstruir la solución para resolver el problema.\nSin embargo, representar un mapa entero como un estado puede ser algo problemático, pues podemos tener hasta 16 casillas. Como puede haber un total de 2^16 estados, eso quiere decir que tendremos un arreglo de 17 dimensiones y estaremos usando 2^32 casillas de enteros, lo cual es completamente absurdo, pues aunque nos cupiera en memoria, dudo mucho que un compilador soporte tantas dimensiones y mucho menos que vaya a ser fácil manipularlas.\nLo que nos tenemos que dar cuenta es que como nuestro estado son únicamente 1’s y 0’s podemos olvidarnos de la representación del arreglo, pues podemos convertir cada estado en un número binario. Por ejemplo, a continuación presentamos diferentes mapas y su representación binaria: Esto simplifica muchísimo nuestro espacio de búsqueda, ya que en vez de necesitar dieciséis enteros para representar un estado, ahora solo necesitamos 1, donde cada bit del estado representa una casilla del mapa.\nLa pregunta que nos tenemos que hacer ahora es si es posible representar todos los estados con nuestra representación numérica, y la respuesta es que sí, pues solo son hasta 16 casillas en el mapa, o lo que es igual a 16 bits, y sabemos que un entero en la mayoría de los lenguajes modernos soporta hasta 32 bits, por lo tanto nos alcanza y nos sobra para representar todos los enteros.\nLa siguiente pregunta que nos tenemos que hacer es si nos va a alcanzar la memoria. Y la respuesta también es sí, pues tenemos hasta 2^16 estados, lo cual es alrededor de 65,000 casillas, cada una de ellas puede guardar ya sea la operación que se hizo para llegar a ella, o el estado del que se llegó, ¡o incluso se pueden guardar ambas cosas! Pues solo necesitamos 16 bits para representar el estado de donde vienes y otros 2 para representar la operación que hiciste. Pero la implementación del problema ya se la dejamos a los competidores. En todo caso, necesitamos únicamente 65,000 enteros lo cual cabe en menos de 300 KB.\nDe esta forma, nuestro árbol de búsqueda se transforma, y se vuelve más fácil de manipular:\nUna vez hecha la conversión con bits, esto se vuelve una búsqueda en amplitud común y corriente desde un número con NxM bits prendidos, hasta 0. Una búsqueda así debe de ser fácil de hacer para cualquier competidor."},"title":"Solución a \"Temblor\""},"/posts/solucion-a-ubongo-3d/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 8 Autor: Miguel Covarrubias Fuente: Miguel Covarrubias\nLa solución pone piezas de manera recursiva mientras quepan en el tablero y no se empalmen.\nresuelve(pieza) si pieza \u003e P regresa “Si” para cada rotación de la pieza para cada casilla g del tablero para cada cubo c de la pieza si al poner c sobre g, la pieza queda dentro de los primeros 2 niveles del tablero y no se empalma con otra pieza ya puesta entonces marca las posiciones de los cubos de la pieza como ocupados resuelve(pieza + 1) desmarca los cubos de la pieza Para rotar una pieza se puede rotar por $latex 0^o$, $latex 90^o$, $latex 180^o$ o $latex 270^o$ alrededor de cada eje. El número de operaciones es aproximadamente (número de rotaciones * número de casillas del tablero * número de cubos de una pieza)$latex ^3 \\le (24 * 7 * 5)^3 \u003c 600,000,000$. En los casos de prueba y en el juego todas las soluciones tocan la base del tablero, si no fuera así, solo hay que duplicar el 7 a 14. Para checar si una pieza se puede poner en cierta posición se pueden usar mascaras de bits para los niveles del tablero y para las posiciones ocupadas. Para poner la última pieza se puede comparar todas las rotaciones de los cubos no ocupados contra la última pieza y la complejidad cubica de la solución se reduce a cuadrática."},"title":"Solución a \"Ubongo 3D\""},"/posts/solucion-alternativa-a-decepcion/":{"data":{"":"Concurso: Preselectivo para la IOI 2014, Etapa 1, Problemset 8 Autor: Freddy Román Cepeda Fuente: Ethan Jiménez Vargas\nEsta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $latex O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.\nPodemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $latex f(n,m)$ cuenta de cuántas maneras se pueden poner $latex n$ torres de tal manera de que sólo $latex m$ se pueden ver de un lado, la respuesta que queremos es $latex \\sum_{i=0}^{N-1} ({N-1 \\choose i} * f(i,F-1) * f(N-i-1,B-1))$.\nEn otras palabras, esta expresión es la suma de las maneras de cumplir las condiciones originales del problema colocando la torre más alta en la posición $latex i$. Es decir, hay $latex {N-1 \\choose i}$ maneras de distribuir el resto de las torres a la izquierda o derecha de la torre más alta (porque la única cosa que importa es el orden relativo de las torres y todas las alturas son distintas), las cuales multiplicamos por las maneras de hacer que se cumpla la condición sobre el lado izquierdo y lo mismo con el lado derecho.\nAhora, para computar $latex f$, podemos reusar la misma observación. Cuando colocamos la torre más alta en el índice $latex i$, cualquier torre que pongamos después de $latex i$ ya no se podrá ver. Del lado visible, necesitamos reordenar las torres restantes de tal manera que sólo se puedan ver $latex m-1$. Además, podemos reordenar el lado oculto de la manera que queramos. Con esto tenemos que\n$latex f(0,0) = 1$ $latex f(n,m) = \\begin{cases} 0 \u0026 \\text{si } m \u003e n\\\\ \\sum_{i=0}^{n-1}({n-1 \\choose i} * f(i,m-1) * (n-i-1)!) \u0026 \\text{de lo contrario} \\end{cases}$\ncon lo que resolvemos el problema en tiempo $latex O(N^3)$ y memoria $latex O(N^2)$.\nEsto se puede mejorar aún más observando que $latex f(n,m)$ está computando los números de Stirling de primera clase, para los cuales hay una recurrencia que se puede utilizar para calcularlos en tiempo $latex O(N^2)$.\nLos números de Stirling de primera clase cuentan las permutaciones de $latex n$ elementos con $latex m$ ciclos. Considere una permutación con $latex m$ ciclos de los $latex n$ edificios. Cada ciclo debe tener un elemento máximo. Además podemos ordenar los ciclos entre sí por su elemento mayor. De esta manera, tenemos $latex m$ edificios visibles. Ya que estamos contando todas las permutaciones con $latex m$ ciclos, cada posible ordenamiento con $latex m$ edificios visibles será considerada. Esto se debe a que cada ciclo tiene únicamente un ordenamiento en el cual sólo uno de sus elementos es visible: el que comienza con el edificio más grande.\nAquí está el código que implementa esta solución."},"title":"Solución alternativa a \"Decepción\""},"/posts/solucion-de-el-concierto-de-dr-lira/":{"data":{"":"**Concurso: **Preselectivo para la IOI 2014, Etapa 1, Problemset 13 Fuente: Topcoder\nEl Concierto de Dr. Lira es una adaptación al problema Changing Sounds que apareció en el SRM 366 (2007, ya llovió) en TopCoder. La solución explicada la pueden encontrar en el Match Summary (necesitan registrarse en omegaUp para verlo).\nLes dejo la implementación de spleensarethebest como un muy bien ejemplo de solución a este problema. Cualquier duda, déjenos un comentario."},"title":"Solución de \"El Concierto de Dr. Lira\""},"/posts/soluciones-a-liga-omegaup-fase-1/":{"data":{"":"","problema-ahttpsomegaupcomarenaproblemrango-simple#\u003ca href=\"https://omegaup.com/arena/problem/Rango-simple\"\u003eProblema A\u003c/a\u003e":"","problema-bhttpsomegaupcomarenaproblema-contar-lapices#\u003ca href=\"https://omegaup.com/arena/problem/A-contar-lapices\"\u003eProblema B\u003c/a\u003e":"","problema-chttpsomegaupcomarenaproblemnofib#\u003ca href=\"https://omegaup.com/arena/problem/nofib\"\u003eProblema C\u003c/a\u003e":"","problema-dhttpsomegaupcomarenaproblemposicion-fibonacci#\u003ca href=\"https://omegaup.com/arena/problem/Posicion-Fibonacci\"\u003eProblema D\u003c/a\u003e":"","problema-ehttpsomegaupcomarenaproblemestacion#\u003ca href=\"https://omegaup.com/arena/problem/estacion\"\u003eProblema E\u003c/a\u003e":"","problema-fhttpsomegaupcomarenaproblemtu-y-tu-futuro#\u003ca href=\"https://omegaup.com/arena/problem/Tu-y-tu-Futuro\"\u003eProblema F\u003c/a\u003e":"","problema-ghttpsomegaupcomarenaproblemkarel-y-los-quebrados#\u003ca href=\"https://omegaup.com/arena/problem/Karel-y-los-quebrados\"\u003eProblema G\u003c/a\u003e":"Problema A Para este problema, consideramos un arreglo de ocurrencias $O$ sobre los elementos del arreglo. De modo que la respuesta está dada por\n$\\sum\\limits_{i=A}^B O_{i}$\nProblema B Si consideramos el mismo arreglo de ocurrencias $O$ sobre los elementos del arreglo, la respuesta está dada por $O_k$.\nProblema C Podemos generar todos los elementos de la secuencia de Fibonacci hasta $30000$, y guardarlos en un mapa $M$, de modo que $M_k = 1$ si $k$ es un elemento de Fibonnaci, y $M_k = 0$ en caso contrario. Generamos la respuesta simplemente iterando desde $i = 4$ hasta $i = N - 1$, e imprimimos $i$ si $M_i = 0$.\nProblema D La clave para este problema, es usar variables que no provoquen un desbordamiento, por ejemplo, unsigned long long. Luego, es conocido que la serie de Fibonacci crece rápidamente, lo suficiente, como para generar la secuencia con todos sus elementos menores o iguales a $N$, guardando por cada uno su respectiva posición en ella. Por lo tanto, basta con checar si $N$ es un elemento, e imprimir su posición. En caso de no serlo, imprimimos $-1$.\nProblema E Este tipo de problema es conocido como straight-forward. Podemos guardar las estaciones de radio, y checar cuál estación es la mas cercana a la frecuencia dada, con una simple resta. En caso de haber dos estaciones con la misma distancia, la respuesta es la mayor. Solo debemos cuidar que la frecuencia esté dentro del rango permitido.\nProblema F En este problema lo que tenemos es un grafo dirigido acíclico con aristas pesadas (intuitivamente, es un árbol, sin la propiedad de que cualquier par de nodos estan conectados por un único camino). Los vértices son los eventos temporales, las aristas son dirigidas de $p_i$ a $i$, y su peso es $d_i$. Además, cada vértice contiene un valor extra $r_i$. Un grafo que podemos asociar al primer caso de ejemplo es el siguiente.\nSean $v_1$ y $v_k$ dos vértices distintos, tales que $v_1$ es ancestro de $v_k$. Es decir, existe un camino $v_1 \\rightarrow v_2 \\rightarrow \\ldots \\rightarrow v_k$ en el grafo. Definimos $S(v_1, v_k)$ como\n$\\sum\\limits_{i=1}^{k - 1} d_{v_i}$\nEs decir, la suma de los pesos en las aristas del camino. De modo que el problema se convierte en: Para cada vertice $v$, contar cuántos vértices $u$ en su “subárbol” $\\;$ existen tales que\n$r_u - S(v, u) \\geq 0 $\nPorque esto siginifica que tenemos suficientes segundos para viajar por el tiempo desde $u$ hasta $v$.\nConsideremos un arreglo $E$, donde la entrada $E_v$ guarda cuántos descendientes $u$ de $v$ satisfacen\n$r_u - S(v, u) \\geq 0 $\nPero\n$r_u - S(p_v, u) \u003c 0 $\nDonde $p_v$ es el padre de $v$. Si $v = 0$, entonces no hace falta considerar a su padre, puesto que no podemos viajar por el tiempo a algún ancestro de $0$ (ya que ni siquiera existe alguno).\nEn otras palabras, $E_v$ guarda cuántos descendientes de $v$ llegan a lo mas al vértice $v$.\nTambién consideremos un arreglo $D$, donde la entrada $D_v$ guarda cuántos descendientes $u$ de $v$ satisfacen\n$ r_u - S(v, u) \u003c 0 $\nEs decir, $D_v$ guarda cuántos descendientes de $v$ no pueden llegar al vertice $v$.\nY además mantengamos un arreglo $T$, donde la entrada $T_v$ guarda el tamaño del “subárbol” de $v$ (incluyendo a $v$). En otras palabras, cuántos descendientes tiene $v$ en total mas el mismo.\nPor lo tanto, la respuesta final para el vértice $v$ está dada por\n$(T_v - 1) - \\sum\\limits_{v \\rightarrow u} (E_u + D_u)$\ndonde $u$ es un hijo directo de $v$. Ya que esto calcula cuántos descendientes de $v$ si pueden llegar a $v$.\nPara el cálculo de nuestros arreglos, hacemos una dfs sobre el “árbol” (partiendo del vertice 0). Para cada vértice $u$, hacemos una búsqueda binaria sobre un arreglo que mantenga la suma acumulada de los costos sobre las aristas que forman parte del camino de $0$ a $u$, que nos devuelva el máximo ancestro $v$ al que podemos llegar desde $u$. Lo que nos dice que $E_v$ actualiza su valor a $E_v + 1$ (inicialmente, $E_1 = E_2 = \\ldots = E_n = 0$). Esto se puede hacer usando un arreglo global. La idea es añadir la suma acumulada, luego explorar recursivamente el subárbol de $u$, y luego quitar la suma acumulada que añadimos. Esto es particularmente sencillo si usamos un vector de la STL para el arreglo global.\nEl arreglo $T$ se calcula facilmente en la misma dfs, ya que\n$T_v = 1 + \\sum\\limits_{v \\rightarrow u} (T_u)$\nAhora podemos generar $D$, al estilo de programacion dinámica usando $E$. Notemos que\n$D_v = \\sum\\limits_{v \\rightarrow u} (E_ u + D_u)$\nLo que se puede hacer en la misma DFS.\nPor lo tanto, nuestro algoritmo tiene complejidad $O(Nlog(N))$.\nProblema G Primero reescribamos la expresión dada como\n$k = \\dfrac{xy}{x + y}$\nDe donde podemos despejar $y$ como\n$y = \\dfrac{xk}{x - k}$\nSin perdida de generalidad, supongamos $x \\leq y$, entonces se tiene\n$x \\leq \\dfrac{xk}{x - k}$\n$x^2 \\leq 2xk$\n$x \\leq 2k$\nPor lo tanto, podemos iterar $x$ desde $1$ hasta $2k$, obtenemos $y$, y verificamos que $k = \\dfrac{xy}{x + y}, y \u003e 0$.\nGuardamos las parejas que satisfazcan dichas condiciones y las imprimimos en el orden requerido, cuidando no repetir alguna respuesta.\nLo que nos deja con un algoritmo de complejidad $O(k)$.\nUna solución alternativa es la siguiente:\nTe puedes dar cuenta que $x, y \u003e k$, entonces el problema se convierte a buscar $a$ y $b$ que cumplan\n$\\dfrac{1}{k} = \\dfrac{1}{k + a} + \\dfrac{1}{k + b}$\ncon $a,b \u003e 0$. Si simplificas la igualdad llegas a que $k^2 = ab$, así que todo se reduce a encontrar las parejas de divisores $a, b$ de $k^2$. Lo que deja también un algoritmo de complejidad $O(k)$.\nNota: Agradezco a José Tapia y a Carlos Galeana por su colaboración en el problema $G$."},"title":"Soluciones de la Fase 1 de la Liga de Programación omegaUp"},"/posts/soluciones-a-liga-omegaup-fase-2/":{"data":{"":" Problema A Las siguientes observaciones son claves para resolver el problema.\nSi $p \\leq n$, entonces $(w$ % $p) \u003c n$. Así que el máximo residuo posible es $n - 1$. Si $w$ satisface la condición del enunciado, entonces hay $n - 1$ diferentes residuos, luego los residuos son un subconjunto de $n - 1$ elementos, de la colección $\\lbrace 0, 1, \\ldots , n - 1\\rbrace$. El mínimo común múltiplo de $1, 2, \\ldots , n$ es mayor o igual al producto de los primos menores o iguales a $ n$. El producto de los primos menores o iguales a $50$ es mayor a $10^{18}$ Veamos el caso donde $0$ no forma parte de los residuos. De 1, vemos que\n$w$ % $n = n - 1$\n$w$ % $n - 1 = n - 2$\n$\\ldots$\n$w$ % $2= 1$ .\nEntonces $w + 1$ es un común múltiplo de $2, 3, 4, \\ldots, n$.\n$(*)$ Luego, de la observación 3 vemos que\n$mcm(2, 3, 4, \\ldots, n) \\geq P_n$\nDonde $P_n$ es el producto de los primos menores o iguales a $n$.\n$(*)$ Pero $P_{50} \u003e 10^{18}$. Así que si $w + 1$ es un común múltiplo de $2, 3, 4, \\ldots, n$ entonces $n \\leq 50$.\nAhora el caso donde $0$ sí forma parte de los residuos. Se sigue que existe $1 \u003c k \\leq n$ tal que $w$ % $k = 0$. Con la misma lógica, de 1, vemos qué\n$w$ % $k - 1 = k - 2$\n$\\ldots$\n$w$ % $2= 1$ .\nCon ayuda de $(*)$, vemos que $k \\leq 50$. ¿Cuál es el orden de los residuos mayores a $k$?. Para esto, consideremos el mismo orden que usamos en el caso donde $0$ no forma parte de los residuos.\nEl residuo $k - 1$ que originalmente pertenecía a $k$ tiene dos direcciones: ser el residuo de un numero mayor que $k$, o $k - 1$ es el residuo que queda descartado.\nSea $M - 1$ el residuo que queda descartado, entonces $w + 1$ debe ser común múltiplo de $n, n - 1, n - 2, \\ldots , M + 1$, y para esto,\n$(w + 1) \\geq n * (n - 1) * (n - 2) * \\ldots * (M + 1)$\nLo cual sería imposible si $n - M \\geq 50$.\nAhora, si no descartamos los residuos de $k + 1, \\ldots , k + 50$, entonces $w + 1 \\geq (k + 1) * \\ldots * (k + 50)$ lo cual sería de nuevo imposible.\nPor lo tanto, $M + 50 \u003e n$ y $M - 50 \u003c 1$.\nDe modo que, si $n \u003e 100$, la respuesta es “No”. El problema ahora se limíta a $n \\leq 100$ y $w \\leq 10^{18}$.\nPara éste problema, podemos guardar todos los residuos de $w$ con los números menores o iguales a $n$ en una estructura que nos maneje operaciones básicas de conjuntos, como un set. Usando el set, la respuesta es “Si”, si el tamaño del set después de añadir los residuos es $n - 1$, y “No” en caso contrario.\nProblema B Tratemos cada query de manera independientemente, y nos tomamos $a_1, a_2, \\ldots, a_k$ como los puntos dados en la query.\nEl problema es equivalente a encontrar un círculo con el menor radio $r$ posible, tal que todos los puntos de la query están dentro de él. La respuesta sería el radio $r$.\nÉl cuál es un problema equivalente a encontrar el menor radio $r$ tal que existe al menos un punto contenido en cada círculo con centro $a_1, a_2, \\ldots a_n$ y radio $r$.\nSi dicho punto $p$ existe, entonces existe al menos un par de círculos que se intersecten en algun punto $T$. Por supuesto, la distancia de $p$ a $T$ es menor o igual a $r$.\nPor lo tanto, la respuesta puede ser encontrada con una búsqueda binaria.\nFíjamos el radio $r$, el cual mandamos a la búsqueda binaria. Enumeramos los $k$ círculos. Encontramos y enumeramos las intersecciones para cada par de círculos. Para cada intersección, recorremos cada centro. Si hay un centro $a_i$que tiene una distancia menor o igual a $r$ entonces el menor radio que buscamos sí es menor o igual a $r$. El costo de cada chequeo en la búsqueda binaria es $O(k^3)$. Y la búsqueda binaria tiene un costo de aproximádamente $50$ operaciones. Pero precalculando las soluciones, de 4, para todos los $l$ puntos antes de contestar las preguntas, reducimos el costo del chequeo a $O(k^2)$, lo cual ya es suficiente para resolver el problema.\nProblema C Lo que buscamos, es la cantidad de subconjuntos tales que su $\\\u0026$ es igual a $0$. Esta cantidad puede verse como la cantidad de subconjuntos totales, menos la cantidad de subconjuntos tales que su $\\\u0026$ es diferente de $0$. Ahora, esta cantidad puede verse como la cantidad de subconjuntos cuyo $\\\u0026$ tienen exactamente un bit prendido, más la cantidad de subconjuntos cuyo $\\\u0026$ tienen exactamente dos bits prendidos, $\\ldots$, más la cantidad de subconjuntos cuyo $\\\u0026$ tienen exactamente $20$ bits prendidos (esto ya que $10^6 \\leq 2^{20}$).\nPara esto usaremos el principio de inclusión - exclusión. De modo que la cantidad que buscamos esta dada por\n$S_ 0 - S_1 + S_2 - S_3 + \\ldots + S_{20}$\nDonde $S_i$ nos dice cuantos subconjuntos tienen un and con al menos $i$ bits prendidos.\nAhora, $S_i$ puede ser calculado con la ayuda de una SOS (Sum Over Subsets) DP.\nPara esto, sea $mask$ alguna máscara de bits en $[1, 2^{20}]$, y definamos $m$ como el and de algún subconjunto del arreglo, tal que $mask \\\u0026 m = mask$. Es decir, $mask$ es una submáscara de $m$. Entonces, DP[mask] nos dice cuántas diferentes $m$ existen. (dos $m$ se consideran diferentes, si las posiciones de los elementos en el arreglo que la componen no son todas iguales). Está DP puede calcularse de la siguiente manera.\nLos casos base los formamos añadiendo la cantidad de ocurrencias de $x$ en el arreglo, a $DP[x]$. Fíjamos $bit \\in [1, 20]$, de izquierda a derecha. Para cada mask en $[0, 2^{20}]$, tal que mask tiene el $bit$-ésimo bit apagado (mas formalmente, $mask \\\u0026 (1 « bit) = 0$ ) se hace la transición DP[mask | (1 « bit)] += DP[mask]. De modo que $S_i = 2^{DP[m]}$, para cada $m$ una máscara con al menos $i$ bits prendidos.\nProblema D Sean $p_1, p_2, \\ldots, p_m$ las posiciones de la cadena en donde hay un $1$.\nDefinimos $r$ cómo la posición donde yace la rana, y $b$ como la cantidad de brincos que ha dado hasta el momento. Inicialmente, $r = p_1$ y $b = 0$. La respuesta puede encontrarse mediante siguiente algoritmo.\nEncontrar $j$ tal que $p_j - r \\leq k$ y $p_{j + 1} \u003e k$\nHacemos\n$b = b + 1$ y $r = p_j$\nRepetimos mientras $r \\neq p_m$.\nLa respuesta final es $b$. El algoritmo se puede implementar con complejidad lineal usando la técnica de two pointers (usando $r$ y $j$ como los pointers).\nProblema E Rescatando la cantidad de ocurrencias para cada vocal (no hay que olvidarse de contar las mayúsculas) mientras recorremos la cadena, estamos listos para imprimir las tres respuestas. Las cuales son\n**(a) ** Tamaño de la cadena.\n(b) Suma de las ocurrencias de cada vocal.\n(c) Imprimir la cadena de derecha a izquierda.\nProblema F Salvemos los dos vectores dados $a_1, a_2, \\ldots , a_n$ y $b_1, b_2, \\ldots , b_n$, y generemos un nuevo vector $c_1 = (a_1 + b_1), \\ldots, c_n = (a_n + b_n)$. La solucion es imprimir $c_1, c_2, \\ldots, c_n$."},"title":"Soluciones de la Fase 2 de la Liga de Programación omegaUp"},"/posts/soluciones-de-problemas-en-omegaup/":{"data":{"":"","para-los-autores-de-problemas#Para los autores de problemas":"En este post queremos describirles cómo ver soluciones a los problemas en omegaUp. Para los autores de problemas también daremos algunos detalles sobre como agregar las soluciones a sus problemas.\nEn la vista de problema, en la parte superior podemos ver dos pestañas, Problema y Ver Solución.\nSi ya resolviste el problema y quieres comparar tu solución con la solución oficial, al dar click en la pestaña de Ver Solución, verás el botón de Ver Solución con el icono de un candado abierto.\nY así verás la solución.\nPor otro lado, si no has resuelto el problema el proceso para ver las soluciones será distinto.\nPrimero intenta resolverlo. Tienes la posibilidad de visualizar hasta cinco soluciones diarias. Cada vista a una solución restará una unidad de tu límite diario. Si decides ver la solución a un problema, esta quedará desbloqueada de forma permanente y no se descontará del límite diario al visualizarla. El límite de visualizaciones diarias se reestablecerá todos los días a la misma hora. Si ves la solución sin antes resolver el problema, éste no te dará puntos en el ranking. Puedes ver las visualizaciones que tienes disponibles en la pestaña de Ver Solución. Verás un mensaje como el de la imagen.\nPara los autores de problemas Si quieres incluir las soluciones a tus problemas debes añadir una nueva carpeta /solutions al archivo zip del problema. Dentro de la carpeta se debe agregar el archivo markdown con la solución. Las soluciones se pueden editar desde la plataforma, tal como las descripciones del problema.\nMas información aquí."},"title":"Soluciones de problemas en omegaUp"},"/posts/summary-of-mathematical-background-for-computer-science/":{"data":{"":"Directamente del twitter feed de Computer Science (@CompSciFact) aquí hay una excelente recopilación de las matemáticas que son comunmente requeridas en ciencias computacionales:\nhttp://www.jfsowa.com/logic/math.htm"},"title":"Summary of mathematical background for Computer Science"},"/posts/todos-los-videos-del-curso-de-introduccion-a-c/":{"data":{"":"Actualización 10/04/20: El curso ha terminado y este post incluye los 11 videos.\nComo parte de la iniciativa #QuédateEnCasaConOmegaUp estuvimos impartiendo un curso de Introducción a C++ en vivo a través de Facebook Live.\nEl material del curso está disponible de forma abierta y gratuita en la plataforma de omegaUp y puedes acceder en este enlace (https://omegaup.com/course/introduccion_a_cpp) para ver el material y resolver los ejercicios en línea.\nAquí te dejamos un enlace a todos los videos y estaremos actualizando este post con cada video nuevo en la serie:\nQueremos agradecer especialmente a nuestro usuario OrlandoIsay del Instituto Tecnológico Superior del Sur de Guanajuato (ITSUR) por impartir este excelente curso."},"title":"Todos los videos del curso de Introducción la Programación con C++"},"/posts/trucos-cool/":{"data":{"":"Después de un rato de investigación y experimentación, por fin me tomo el tiempo para escribir este post y presentarles algunos trucos que, considero, podrían ayudarles a simplificarse la vida cuando programen y, obviamente, a ser mucho más cool.\n¿Cansado de importar librerías como asíatico en TopCoder? ¡Aquí está la solución!\nMuchas veces es nefasto encontrar varios (sino es que miles) errores al compilar a causa de librerías que hemos olvidado incluir. Existe una librería que, al incluirla, agrega todas las librerías estándar de C++ a nuestro código, ¡incluso las de la STL!\n¿Que clase de brujería es esta? Seguramente se estarán preguntando. Muy sencillo, solo necesitan escribir la siguiente línea de codigo: #include \u003cbits/stdc++.h\u003e\n_(Actualización) _Gracias a el comentario de lhchavez por remarcar el hecho de que esta línea funciona únicamente con el compilador gcc. Pese a esto, gran parte de los evaluadores actualmente usan gcc, por lo que podemos confiar en su uso, al menos en omegaUp. En caso de que la librería anterior no siga siendo soportada por omegaUp, les informaremos oportunamente.\n¡Mi mami dice que cin/cout es malo y no debo juntarme con ellos!\nSi no me equivoco, durante mucho tiempo se ha tratado a scanf y printf como el pan de cada día para la entrada y salida en los concursos de programación, al menos en México. Mientras tanto, se satanizó a cin y cout por ser lentos (o especiales, como dice mi mami) para realizar entrada y salida eficiente.\nSin embargo esto siempre fue un mito, los métodos cin/cout son incluso más eficientes que scanf/printf, solo había que descubrir el por que no lo notamos.\nResulta que cin/cout son muy buenos amigos de scanf/printf. Como son tan buenos amigos, al realizar la lectura y salida no querían alejarse demasiado, por lo que cin/cout tenía que sincronizarse para estar siempre a la par de scanf/printf.\nPara no hacer el cuento largo, hay una forma de desactivar la opción de sincronización entre cin/cout y scanf/printf, solo es necesario incluir al inicio del main:\nstd::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); Con esto podemos usar cin y cout sin temor a obtener TLE por lectura lenta, ¡Yaaay!\n¿Y eso es todo? ¿Ya puedo disfrutar de cin y cout?\nCasi. Antes de cantar victoria hay un último detalle para evitar los TLE. Gracias a un último experimento, encontramos que cuando se presentaban outputs muy grandes, cin/cout optimizado seguía lanzando TLE cuando scanf/printf no.\n¡Tranquilos! También es posible evitar este error. El problema se presentaba porque comúnmente usaríamos lo siguiente: cout \u003c\u003c numero \u003c\u003c endl. Sucede que endl, además de imprimir un salto de línea, hace flush en el flujo de salida, lo cual es considerablemente costoso al imprimir muchas líneas y entorpece el rendimiento.\nPara que la salida sea eficiente, recomendamos que uses el salto de línea literal \"\\n\".\nCon los dos trucos anteriores, la eficiencia de cin/cout mejora generalmente un 5-10% los resultados obtenidos por scanf/printf. Bastante cool, ¿no?\nAunque el objetivo original no es ganar unas cuantas centésimas de segundo en eficiencia, sino dar la oportunidad a aquellos olímpicos que no manejan scanf/printf para seguir usando cin/cout sin enfrentarse a más complicaciones.\nFinalmente les dejó un ejemplo de cómo usar todo lo anterior en un código de C++. Espero que algo de esto les pueda ayudar en el futuro. Les deseo lo mejor :)\n#include \u003cbits/stdc++.h\u003e #define optimizar_io do { std::ios_base::sync_with_stdio(false); std::cin.tie(nullptr); } while(false)` int main(){ optimizar_io; int a, b; std::cin \u003e\u003e a \u003e\u003e b; std::cout \u003c\u003c a + b \u003c\u003c \"\\n\"; return 0; } "},"title":"Trucos para ser más cool"},"/posts/ya-mostramos-los-mejores-envios-con-ac-en-los-problemas/":{"data":{"":"A partir de hoy, si visitas un problema de la lista (fuera de concurso), verás que hasta abajo mostramos una tabla con los 10 usuarios junto con sus mejores envíos aceptados, ordenados por qué tan rápido terminaron. Intenta que cuando resuelvas un problema, tu nombre aparezca en esa tabla para tener todo el honor y gloria!\nMejores Envíos "},"title":"Ya mostramos los mejores envíos con AC en los problemas"},"/posts/ya-pueden-filtrar-los-problemas-por-tags/":{"data":{"":"Si van a la lista de problemas, podrán notar que algunos tienen tags! Si hacen click en alguno, filtrarán la lista de problemas para que únicamente se muestren los problemas con ese tag. Si están buscando problemas de Karel, este cambio los va a hacer muy felices."},"title":"Ya pueden filtrar los problemas por Tags"},"/posts/ya-pueden-hacer-sus-envios-usando-ruby/":{"data":{"":"Bueno, según la plataforma ya podían hacerlo desde hace mucho. Pero como nadie lo había intentado, no descubrimos que había un bug que hacía que todos los envíos dieran JE. Disfruten usar el nuevo lenguaje!"},"title":"Ya pueden hacer sus envíos usando Ruby"},"/posts/yeah-science-bch-entre-mas-omegaup-mejores-resultados/":{"data":{"":"Del 1 al 6 de Mayo pasados, se llevó a cabo la Olimpiada Mexicana de Informática 2014 en Pachuca, Hidalgo. Más de 100 participantes de toda la república concursaron y omegaUp fue la plataforma de evaluación oficial (el examen del Día 1 lo puedes encontrar aquí y el de el Día 2 aquí).\nPor primera vez, durante el periodo 2013-2014 varios Estados, como Morelos, Chihuahua y Guanajuato empezaron a promover omegaUp entre sus olímpicos y usar nuestra plataforma para correr sus concursos locales estatales.\nDentro de los resultados, la estadística que más nos llamó la atención en omegaUp fue la tabla de posiciones por Estado. Minutos antes de la OMI 2014, ya habíamos predicho el Top 10 de Estados basados en las visitas a omegaUp.com durante los 6 meses anteriores a la OMI:\nPredicciones omegaUp para la OMI 2014 Los resultados finales por Estado fueron:\nScreen Shot 2014-05-22 at 7.32.50 AM Si bien, el orden no es exactamente el mismo, 9 de los 10 mejores Estados en la OMI también estuvieron dentro del Top 10 de visitas a omegaUp.com. Entendemos que usar más omegaUp no es el único factor para tener buenos resultados en la OMI, pero esta estadística es una buena muestra de que omegaUp funciona!\nYeah, science bitch! Recomendamos a todos los Estados promover omegaUp entre sus alumnos y usarlo para correr sus concursos locales. Entre más temprano en el proceso lo usen, será mejor - tendrán más visitas y la probabilidad de tener un mejor lugar en la OMI será más alta."},"title":"Yeah, science b#$ch!: Entre más omegaUp, mejores resultados"},"/reclutamiento-ingenieria/":{"data":{"quieres-contribuir-al-equipo-de-ingeniería-de-software-de-omegaup#¿Quieres Contribuir al Equipo de Ingeniería de Software de omegaUp?":"¿Quieres Contribuir al Equipo de Ingeniería de Software de omegaUp?Si te apasiona la programación y buscas un proyecto desafiante donde aplicar tus habilidades, omegaUp te ofrece la oportunidad de contribuir al desarrollo de nuestra plataforma educativa. Buscamos personas motivadas y dispuestas a invertir tiempo y esfuerzo en aprender y crecer con nosotros.\n¿Qué es omegaUp?\nomegaUp es una plataforma en línea que ofrece desafíos de programación y aprendizaje para estudiantes de todos los niveles. Nuestra misión es fomentar el desarrollo de habilidades tecnológicas.\n¿Qué Buscamos?\nBuscamos personas con iniciativa y compromiso que deseen contribuir con su talento al desarrollo de nuestra plataforma. La participación en el equipo de ingeniería de omegaUp requiere dedicación y la voluntad de aprender y adaptarse a nuestros procesos. Estamos abiertos a colaborar con personas en cualquier etapa de su carrera profesional en ingeniería de software, desde estudiantes de los primeros semestres hasta profesionistas con años de experiencia.\nEl Proceso de Incorporación:\nHemos establecido un programa de entrenamiento para nuevos voluntarios. Este programa requiere que los candidatos exploren los siguientes recursos y demuestren su capacidad para contribuir:\nDocumentación: La documentación de nuestro código y proceso de desarrollo está disponible en nuestro wiki de GitHub. Este es el punto de partida para cualquier persona interesada. Videotutorial: Un videotutorial sobre cómo instalar el entorno de desarrollo local está disponible aquí. Canal de Discord: El canal #dev_training en nuestro servidor de Discord ofrece un espacio para consultas técnicas. Se puede escribir en inglés o español. “Good First Issues”: Una lista de tareas introductorias está disponible en GitHub: “Good first issues”. “Good Second Issues”: Para aquellos que ya tienen experiencia, hay una lista de tareas más desafiantes: “Good second issues”. El Entrenamiento:\nEl entrenamiento está abierto a cualquier persona que desee participar. No es necesario solicitar permiso.\n¿Cómo Unirse al Equipo?\nPara ser considerado miembro del equipo de ingeniería, se requiere haber revisado la documentación y resuelto 5 “Good first issues” + 5 “Good second issues”. Una vez alcanzado este nivel, los candidatos serán contactados y, si lo desean, se les proporcionará una cuenta de correo @omegaup.com.\n¿Interesado?\nSi estás dispuesto a invertir el tiempo y el esfuerzo necesarios, explora los recursos mencionados y comienza a trabajar. El equipo de omegaUp valora la iniciativa y el compromiso."},"title":"reclutamiento-ingenieria"}}