<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – 2014</title><link>https://blog.omegaup.com/tags/2014/</link><description>Recent content in 2014 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 14 Aug 2014 16:06:31 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/2014/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Contraseña Binaria"</title><link>https://blog.omegaup.com/posts/solucion-a-contrasena-binaria/</link><pubDate>Thu, 14 Aug 2014 16:06:31 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-contrasena-binaria/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P7/#problems/contrasena-binaria" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 7&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:orlandoisay@gmail.com" >Orlando Isay Mendoza Garcia&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="mailto:chadancito@gmail.com" >Christian Adan Hernández Sánchez&lt;/a>&lt;/p>
&lt;p>Podemos ayudarnos de la imagen para comprender mejor esta explicación:&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img1.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img1.png" title="img1" alt="" loading="lazy" />
&lt;figcaption>img1&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>En ella aparecen de forma descendente a la izquierda los números pares comenzando desde el dos, y su representación binaria a la derecha. En la parte superior aparece el valor de cada cifra en decimal.&lt;/p>
&lt;p>Tomando en cuenta el límite del problema, sabemos que si sumamos $latex B(i)$ para cada par menor o igual a $latex N$, en el peor de los casos tendríamos que realizar 500,000,000,000,000 veces la función. Aún si lograramos calcularla en una operación nuestro programa excedería el tiempo límite.&lt;/p>
&lt;p>En cambio, haciendo cálculos notamos que: $latex 2^{50} \approx 1,000,000,000,000,000$. Lo cual significa que a lo más habrán 50 columnas en la tabla (ya que en la forma binaria cada cifra representa una potencia de 2).&lt;/p>
&lt;p>Dado que sabemos que en una suma el orden de las cantidades a sumar no importa, podemos determinar que es lo mismo sumar los valores de forma horizontal, tanto como de forma vertical. Sumando los valores de las columnas solo tomaría 50 operaciones. La columna 1 podemos ignorarla ya que al ser pares los números de la lista ninguno contendrá un 1 en la última cifra.&lt;/p>
&lt;p>Observando la siguiente imagen, vemos que la columna $latex C$ se forman grupos de tamaño $latex C$ (por ejemplo, en la columna 4 se forman grupos de cuatro elementos),que contienen una la mitad de $latex 1$s y la otra de $latex 0$s. También podemos ver que en la columna 2 no hay $latex 0$s antes del primer grupo, en columna 4 hay un 0, en la que sigue hay 2, luego 4,etc (área en color gris). Podemos notar que ese espacio aumenta en base a potencias del dos.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img2.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img2.png" title="img2" alt="" loading="lazy" />
&lt;figcaption>img2&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Teniendo el número $latex N$ habrán $latex N / 2$ números en la lista. Para calcular la cantidad de grupos completos que se forman en cada columna dividimos $latex N$ menos el espacio lleno de ceros en esa columna, entre el número de la columna en el que estemos; a su vez, esta cantidad la multiplicamos por, el número de la columna entre dos. Sin embargo, puede que nos falten de contabilizar los $latex 1$s que pudieran estar en un grupo que no se completo. Esto se arregla sumando a lo anterior, el mínimo entre el resto de la división anterior y, el número de la columna entre dos. &lt;/p>
&lt;p>Código:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/e13fe6f396e2b48755b7.js">&lt;/script></description></item><item><title>Solución a "Poema Equino"</title><link>https://blog.omegaup.com/posts/solucion-a-poema-equino/</link><pubDate>Sun, 27 Jul 2014 07:08:35 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-poema-equino/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P5/#problems/Poema-Equino" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Los límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $latex (\text{poema},\text{fila caballo}_1,\text{columna caballo}_1,\text{fila caballo}_2,\text{columna caballo}_2)$, solamente hay $latex 100 \times (4 \times 10)^2 = 160,000$ estados distintos.&lt;/p>
&lt;p>Además, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.&lt;/p>
&lt;p>Varios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!&lt;/p>
&lt;p>La siguiente solución implementa las simplificaciones descritas anteriormente.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/3f4d3496fe0e3aadd12b.js">&lt;/script></description></item><item><title>Solución a "Carretera"</title><link>https://blog.omegaup.com/posts/solucion-a-carretera/</link><pubDate>Fri, 25 Jul 2014 04:28:19 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-carretera/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1E1/#problems/carretera" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Examen 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Para obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.&lt;/p>
&lt;p>Este código obtiene los primeros 30 puntos:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/94cddcf809bc5a583540.js">&lt;/script>
&lt;p>Para el resto de los puntos: Sea $latex f(t)$ el ancho necesario para la fotografía en el segundo $latex t$. La observación crucial es que $latex f$ es una función unimodal: es decir, existe un punto $latex t_0$ tal que $latex f$ es decreciente a la izquierda de $latex t_0$ y es creciente a la derecha.&lt;/p>
&lt;p>Computar $latex f(t)$ para $latex t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $latex t$, lo cual toma tiempo $latex O(N)$. Como $latex f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $latex O(\lg T)$, donde $latex T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $latex O(N \lg T)$, suficiente para obtener todos los puntos del problema.&lt;/p>
&lt;p>El siguiente código implementa la solución anterior con búsqueda binaria.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/eee062837acde7bcd8ea.js">&lt;/script></description></item></channel></rss>