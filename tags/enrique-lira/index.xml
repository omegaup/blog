<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Enrique Lira on omegaUp blog</title><link>https://blog.omegaup.com/tags/enrique-lira/</link><description>Recent content in Enrique Lira on omegaUp blog</description><generator>Hugo</generator><language>es-mx</language><lastBuildDate>Tue, 08 Jan 2013 17:18:25 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/enrique-lira/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Cambio"</title><link>https://blog.omegaup.com/solucion-a-cambio/</link><pubDate>Tue, 08 Jan 2013 17:18:25 +0000</pubDate><guid>https://blog.omegaup.com/solucion-a-cambio/</guid><description>&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me">Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Lo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.&lt;/p>
&lt;h2 id="solución-de-30-50-puntos">Solución de 30, 50 puntos&lt;/h2>
&lt;p>Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.&lt;/p></description></item><item><title>Solución a "Minecraft"</title><link>https://blog.omegaup.com/solucion-a-minecraft/</link><pubDate>Tue, 08 Jan 2013 17:14:15 +0000</pubDate><guid>https://blog.omegaup.com/solucion-a-minecraft/</guid><description>&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me">Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Este problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.&lt;/p>
&lt;h2 id="para-los-primeros-50-puntos">Para los primeros 50 puntos&lt;/h2>
&lt;p>Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.&lt;/p>
&lt;h2 id="para-los-75-puntos">Para los 75 puntos&lt;/h2>
&lt;p>Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.&lt;/p></description></item></channel></rss>