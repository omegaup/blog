<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Etapa 1</title><link>https://blog.omegaup.com/tags/etapa-1/</link><description>Recent content in Etapa 1 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 14 Aug 2014 16:06:31 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/etapa-1/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Contraseña Binaria"</title><link>https://blog.omegaup.com/solution/solucion-a-contrasena-binaria/</link><pubDate>Thu, 14 Aug 2014 16:06:31 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-contrasena-binaria/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P7/#problems/contrasena-binaria" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 7&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:orlandoisay@gmail.com" >Orlando Isay Mendoza Garcia&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="mailto:chadancito@gmail.com" >Christian Adan Hernández Sánchez&lt;/a>&lt;/p>
&lt;p>Podemos ayudarnos de la imagen para comprender mejor esta explicación:&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img1.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img1.png" title="img1" alt="" loading="lazy" />
&lt;figcaption>img1&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>En ella aparecen de forma descendente a la izquierda los números pares comenzando desde el dos, y su representación binaria a la derecha. En la parte superior aparece el valor de cada cifra en decimal.&lt;/p>
&lt;p>Tomando en cuenta el límite del problema, sabemos que si sumamos $ B(i)$ para cada par menor o igual a $ N$, en el peor de los casos tendríamos que realizar 500,000,000,000,000 veces la función. Aún si lograramos calcularla en una operación nuestro programa excedería el tiempo límite.&lt;/p>
&lt;p>En cambio, haciendo cálculos notamos que: $ 2^{50} \approx 1,000,000,000,000,000$. Lo cual significa que a lo más habrán 50 columnas en la tabla (ya que en la forma binaria cada cifra representa una potencia de 2).&lt;/p>
&lt;p>Dado que sabemos que en una suma el orden de las cantidades a sumar no importa, podemos determinar que es lo mismo sumar los valores de forma horizontal, tanto como de forma vertical. Sumando los valores de las columnas solo tomaría 50 operaciones. La columna 1 podemos ignorarla ya que al ser pares los números de la lista ninguno contendrá un 1 en la última cifra.&lt;/p>
&lt;p>Observando la siguiente imagen, vemos que la columna $ C$ se forman grupos de tamaño $ C$ (por ejemplo, en la columna 4 se forman grupos de cuatro elementos),que contienen una la mitad de $ 1$s y la otra de $ 0$s. También podemos ver que en la columna 2 no hay $ 0$s antes del primer grupo, en columna 4 hay un 0, en la que sigue hay 2, luego 4,etc (área en color gris). Podemos notar que ese espacio aumenta en base a potencias del dos.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img2.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img2.png" title="img2" alt="" loading="lazy" />
&lt;figcaption>img2&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Teniendo el número $ N$ habrán $ N / 2$ números en la lista. Para calcular la cantidad de grupos completos que se forman en cada columna dividimos $ N$ menos el espacio lleno de ceros en esa columna, entre el número de la columna en el que estemos; a su vez, esta cantidad la multiplicamos por, el número de la columna entre dos. Sin embargo, puede que nos falten de contabilizar los $ 1$s que pudieran estar en un grupo que no se completo. Esto se arregla sumando a lo anterior, el mínimo entre el resto de la división anterior y, el número de la columna entre dos. &lt;/p>
&lt;p>Código:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/e13fe6f396e2b48755b7.js">&lt;/script></description></item><item><title>Solución a "Poema Equino"</title><link>https://blog.omegaup.com/solution/solucion-a-poema-equino/</link><pubDate>Sun, 27 Jul 2014 07:08:35 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-poema-equino/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P5/#problems/Poema-Equino" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Los límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $ (\text{poema},\text{fila caballo}_1,\text{columna caballo}_1,\text{fila caballo}_2,\text{columna caballo}_2)$, solamente hay $ 100 \times (4 \times 10)^2 = 160,000$ estados distintos.&lt;/p>
&lt;p>Además, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.&lt;/p>
&lt;p>Varios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!&lt;/p>
&lt;p>La siguiente solución implementa las simplificaciones descritas anteriormente.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/3f4d3496fe0e3aadd12b.js">&lt;/script></description></item><item><title>Solución a "Carretera"</title><link>https://blog.omegaup.com/solution/solucion-a-carretera/</link><pubDate>Fri, 25 Jul 2014 04:28:19 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-carretera/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1E1/#problems/carretera" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Examen 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Para obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.&lt;/p>
&lt;p>Este código obtiene los primeros 30 puntos:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/94cddcf809bc5a583540.js">&lt;/script>
&lt;p>Para el resto de los puntos: Sea $ f(t)$ el ancho necesario para la fotografía en el segundo $ t$. La observación crucial es que $ f$ es una función unimodal: es decir, existe un punto $ t_0$ tal que $ f$ es decreciente a la izquierda de $ t_0$ y es creciente a la derecha.&lt;/p>
&lt;p>Computar $ f(t)$ para $ t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $ t$, lo cual toma tiempo $ O(N)$. Como $ f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $ O(\lg T)$, donde $ T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $ O(N \lg T)$, suficiente para obtener todos los puntos del problema.&lt;/p>
&lt;p>El siguiente código implementa la solución anterior con búsqueda binaria.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/eee062837acde7bcd8ea.js">&lt;/script></description></item><item><title>Solución a "Suma Manhattan"</title><link>https://blog.omegaup.com/solution/solucion-a-suma-manhattan/</link><pubDate>Sat, 21 Jun 2014 14:34:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-suma-manhattan/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P1#problems/Suma-Manhattan" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Este problema requería manipular con cuidado la expresión que había que computar. Recordemos que nos piden computar&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} manhattan(S_i,S_j).$&lt;/p>
&lt;p>Para resolver la primer subtarea bastaba con iterar sobre todas las parejas de puntos y calcular su distancia. Esto corre en tiempo cuadrático y no es suficiente para obtener todos los puntos.&lt;/p>
&lt;p>La siguiente subtarea era una pista: se puede computar la distancia Manhattan de dos puntos considerando por separado sus coordenadas en $ x$ y $ y$. Ahora nos preocuparemos por calcular la siguiente expresión:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j|.$&lt;/p>
&lt;p>Donde $ a$ son las coordenadas en $ x$ o $ y$. El problema está en el valor absoluto. La manera más sencilla de deshacernos de él es ordenar la secuencia $ a$, de tal manera que $ a_i \leq a_j$. Entonces tenemos:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_j - a_i| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - a_i.$&lt;/p>
&lt;p>La primer igualdad es verdadera porque $ |x| = |-x|$ para cualquier $ x$. La segunda es porque como ahora $ a$ está ordenado, como $ a_j \geq a_i \implies a_j - a_i \geq 0$, el valor absoluto no hace nada.&lt;/p>
&lt;p>Podemos entonces separar la suma en dos términos:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_i.$&lt;/p>
&lt;p>Analicemos el primer término. Estamos sumando sobre todas las $ j$ tantas veces haya una $ i$ menor que ella. Eso quiere decir que cada $ a_j$ la vamos a sumar $ j$ veces (nota que $ a_0$ la sumamos $ 0$ veces).&lt;/p>
&lt;p>El segundo término nos dice que sumaremos todas las $ a_i$ tantas veces haya una $ j$ mayor a ella. Eso quiere decir que cada $ a_i$ la vamos a sumar $ N-i-1$ veces (nota que $ a_{N-1}$ la sumamos $ 0$ veces).&lt;/p>
&lt;p>Juntando esas ideas, entonces tenemos:&lt;/p>
&lt;p>$ \sum_{j = 0}^{N-1} j \cdot a_j - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} i \cdot a_i - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i.$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} (i - (N - i - 1)) \cdot a_i.$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} (2i - N + 1) \cdot a_i.$&lt;/p>
&lt;p>Y con eso terminamos: ahora tenemos una expresión que podemos computar fácilmente en tiempo lineal. Hay que tener cuidado al computar esto: La primera observación es que hay que estar tomando módulo después de cada operación porque en cualquier momento puede haber un &lt;em>overflow&lt;/em>. Algunos competidores obtuvieron 60 puntos en este problema por no tomar esto en cuenta. La segunda observación es que el término $ (2i - N + 1) \cdot a_i$ no necesariamente cabe en un entero signado de 32 bits &amp;ndash; hacía falta utilizar enteros de 64 bits para realizar este cálculo.&lt;/p>
&lt;p>Aquí está mi código que implementa la solución anterior.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/0614f2d1added587c2fc.js">&lt;/script></description></item><item><title>Solución a "Químicos"</title><link>https://blog.omegaup.com/solution/solucion-a-quimicos/</link><pubDate>Thu, 23 Jan 2014 03:51:39 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-quimicos/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P6#problems/quimicos" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 6&lt;/a> &lt;strong>Autor:&lt;/strong>  &lt;a href="http://lhchavez.com/" target="_blank" rel="noopener">Luis Héctor Chávez (lhchavez)&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Éste es un problema que tiene una solución elegante y determinística pero requiere algoritmos avanzados bastante complicados. Lo bueno es que es posible aproximar a la solución utilizando fuerza bruta mediante backtracking.&lt;/p>
&lt;p>El problema nos pide encontrar una manera de asignar sustancias a los tubos y después mezclarlas con las dos operaciones disponibles (suma y diferencia absoluta) para terminar con un acomodo homogéneo de sustancias: la diferencia entre el tubo con más cantidad y con menos cantidad de sustancia debe ser lo más pequeña posible. Una manera de hacerlo es proponer un intervalo $ [a,b]$ y ver si es posible asignar sustancias y aparear los tubos de manera que la cantidad de sustancia resultante de la mezcla en todos los tubos esté contenido dentro del intervalo. Para acelerar el proceso, puedes elegir los intervalos haciendo una búsqueda binaria de acuerdo a su ancho $ b-a$, porque a fin de cuentas lo que nos pide el problema es precisamente el ancho mínimo. Para cada intervalo propuesto $ [a,b]$, podemos hacer un grafo con $ 2N$ nodos (uno para cada tubo), agregando un arco entre dos nodos $ A$ y $ B$ si $ A+B\in[a,b]$ ó $ |A-B|\in[a,b]$. Después, buscamos un &lt;a href="http://es.wikipedia.org/wiki/Apareamiento_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">apareamiento máximo&lt;/a> en el grafo: buscamos el conjunto de arcos con cardinalidad máxima tal que cada nodo tenga a lo más un arco incidente. Esto se puede encontrar con el &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Emparejamiento_de_Edmonds" target="_blank" rel="noopener">algoritmo de Edmonds&lt;/a> (también conocido como el Blossom algorithm por la forma de los ciclos de longitud impar) en tiempo $ O(|2N|^4)$, lo cual encontraría todas las soluciones en solo un par de segundos.&lt;/p>
&lt;p>Lamentablemente la implementación del algoritmo de Edmonds es bastante complicada. Como este es un problema de solo-salida y todo se vale, en vez de hacer el intento por implementarlo, utilicé la librería &lt;a href="http://www.boost.org/" target="_blank" rel="noopener">Boost&lt;/a> de C++ que ya tiene muchísimos algoritmos de &lt;a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html" target="_blank" rel="noopener">grafos&lt;/a> ya implementados.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572476.js">&lt;/script>
&lt;p>Ahora, si no se te ocurre usar el algoritmo de Edmonds o no tienes acceso a Boost, aún así puedes obtener una cantidad decente de puntos usando una heurística: podemos &lt;em>intentar&lt;/em> hacer un apareamiento máximo usando fuerza bruta, rindiéndonos si el problema suena muy complicado y asumimos que no existe un apareamiento. Una fuerza bruta naïve con un contador que se decrementa cada vez que se llama la función de búsqueda es más que suficiente. Haciendo un par de modificaciones al algoritmo anterior nos da una solución que nos da el 80% de los casos bien:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572478.js">&lt;/script>
&lt;p>Claro que si te quieres ver greedy, puedes subirle al número de intentos, pero posiblemente no haya suficiente tiempo en el concurso para que termine. Si llegas a utilizar estas técnicas &amp;ldquo;impuras&amp;rdquo;, asegúrate primero de obtener cualquier solución que te de puntos antes de subirle para encontrar mejores respuestas.&lt;/p></description></item><item><title>Solución a "Crucero"</title><link>https://blog.omegaup.com/solution/solucion-a-crucero/</link><pubDate>Thu, 23 Jan 2014 03:41:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-crucero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P4#problems/Crucero" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:saul.g.gutierrez@gmail.com" >Saúl Germán Gutiérrez Calderón&lt;/a> &lt;strong>Fuente&lt;/strong>: USACO Enero 2009 Gold&lt;/p>
&lt;p>Como se puede notar, al trazar la ruta óptima del crucero se está desperdiciando mucho espacio, y daría lo mismo si expandiésemos la isla para que no se desperdiciara espacio entre la ruta y la orilla de ésta.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image002.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image002.jpg" title="image002" alt="" loading="lazy" />
&lt;figcaption>image002&lt;/figcaption>
&lt;/figure>&lt;/a> &lt;a href="https://blog.omegaup.com/images/image004.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image004.jpg" title="image004" alt="" loading="lazy" />
&lt;figcaption>image004&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si supiéramos cual es la ruta óptima del crucero para expandir la isla bastaría con hacer un Flood Fill para rellenar los espacios con agua que quedan dentro de la ruta.&lt;/p>
&lt;p>Resulta que el flood fill e puede hacer aun sin conocer cuál sería la ruta óptima. Si nos ponemos a hacer todos los tipos de celdas adyacentes a la celda actual en un flood fill, nos toparemos con que solo hay 2 que permiten que la isla crezca y 1 que evita que se expanda. El resto de las celdas adyacentes no nos dice nada acerca de si tenemos que poner algo ahí o no (de momento).&lt;/p>
&lt;p>Si se pone un pedazo de isla nuevo en el centro de las figura de abajo, entonces la cosa peligrosa tendría que ser rodeada de alguna manera para poder pasar, lo cual nos llevaría a tomar una ruta mas larga. Por ello, no es una buena idea poner un pedazo de isla ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image005.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image005.png" title="image005" alt="" loading="lazy" />
&lt;figcaption>image005&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si es como la de la figura de abajo,&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image006.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image006.png" title="image006" alt="" loading="lazy" />
&lt;figcaption>image006&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>ambos caminos tienen la misma longitud. Por ello, se puede poner un pedazo de isla ahí y esto nos simplifica el problema.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image007.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image007.png" title="image007" alt="" loading="lazy" />
&lt;figcaption>image007&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;a href="https://blog.omegaup.com/images/image008.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image008.png" title="image008" alt="" loading="lazy" />
&lt;figcaption>image008&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>La ruta óptima no puede pasar por el cuadro del centro ya que esto sería un desperdicio de tiempo, por lo cual podemos expandir la tierra ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image009.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image009.png" title="image009" alt="" loading="lazy" />
&lt;figcaption>image009&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Entonces, sólo hay que hacer todas las expansiones de tierra hasta que ya no se pueda más y después de esto se puede hacer una mano derecha para buscar la orilla de la isla que al mismo tiempo será la ruta óptima.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572582.js">&lt;/script></description></item><item><title>Solución a "Mocha Hojas"</title><link>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</link><pubDate>Sat, 18 Jan 2014 23:25:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Mocha-Hojas" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Alberto José Ramírez Valadez&lt;/p>
&lt;p>Para simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.&lt;/p>
&lt;p>Consideremos el caso de un árbol con un solo nivel. Ya que sólo podemos restarle a los pesos de las hojas, evidentemente el peso máximo del árbol se alcanza cuando se emparejan todas las hojas al peso de la hoja con peso mínimo.&lt;/p>
&lt;p>Ahora, consideremos un árbol con dos niveles. Si la raíz tiene $ k$ hijos, para cada hijo $ i$ sea $ h_i$ el subárbol de $ i$, $ b_i$ el número de hojas de $ h_i$, y $ c_i$ el peso del árbol obtenido de realizar el procedimiento del párrafo anterior a $ h_i$. Si todas las $ c_i$ son iguales, entonces nuestro árbol está balanceado. De lo contrario, debemos restar aún más para poder balancearlo. Sin embargo, también necesitamos que cada $ h_i$ continúe estando balanceado. La única manera que le podemos restar peso a $ h_i$ sería restarle la misma cantidad de peso a cada una de sus hojas. Entonces, a cada $ h_i$ sólo podemos restarle peso en múltiplos de $ b_i$. Como queremos maximizar el peso del árbol resultante, necesitamos encontrar el número más grande $ x$ tal que a todos los $ c_i$ les podamos restar un múltiplo de su respectivo $ b_i$ para obtener $ x$. Notemos también que $ c_i$ es un múltiplo de $ b_i$ porque los nodos internos del árbol no tienen peso. Si $ m$ es el mínimo común múltiplo de todos los $ b_i$, entonces $ x$ también es un múltiplo de $ m$. Entonces, el máximo $ x$ posible es igual al múltiplo de $ m$ más grande que sea menor o igual a todos los $ c_i$. Por lo tanto, el valor máximo obtenible del árbol completo es igual a $ kx$. Por último, si tuviéramos que restarle más peso a este árbol pero mantenerlo balanceado, es evidente que lo menos que podemos restar para mantenerlo balanceado es $ km$, y si seguimos restando $ km$ continuará balanceado.&lt;/p>
&lt;p>De esta observación podemos obtener la solución para cualquier árbol. Reusando la notación del párrafo anterior, $ k$ es la cantidad de hijos de la raíz, $ h_i$ el subárbol del $ i$ésimo hijo, y $ c_i$ el peso del árbol obtenido de realizar recursivamente el procedimiento de éste párrafo a $ h_i$ (o el del anterior si $ h_i$ tiene 2 niveles). Ahora $ b_i$ es igual a lo mínimo que le podemos restar a $ h_i$ y que continúe balanceado. El análisis del párrafo anterior también es correcto para la nueva definición de $ b_i$ y $ c_i$.&lt;/p>
&lt;p>El código siguiente implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8498208.js">&lt;/script></description></item><item><title>Solución alternativa a "Decepción"</title><link>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</link><pubDate>Fri, 17 Jan 2014 02:14:47 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P8#problems/decepcion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Esta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $ O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.&lt;/p>
&lt;p>Podemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $ f(n,m)$ cuenta de cuántas maneras se pueden poner $ n$ torres de tal manera de que sólo $ m$ se pueden ver de un lado, la respuesta que queremos es $ \sum_{i=0}^{N-1} ({N-1 \choose i} * f(i,F-1) * f(N-i-1,B-1))$.&lt;/p>
&lt;p>En otras palabras, esta expresión es la suma de las maneras de cumplir las condiciones originales del problema colocando la torre más alta en la posición $ i$. Es decir, hay $ {N-1 \choose i}$ maneras de distribuir el resto de las torres a la izquierda o derecha de la torre más alta (porque la única cosa que importa es el orden relativo de las torres y todas las alturas son distintas), las cuales multiplicamos por las maneras de hacer que se cumpla la condición sobre el lado izquierdo y lo mismo con el lado derecho.&lt;/p>
&lt;p>Ahora, para computar $ f$, podemos reusar la misma observación. Cuando colocamos la torre más alta en el índice $ i$, cualquier torre que pongamos después de $ i$ ya no se podrá ver. Del lado visible, necesitamos reordenar las torres restantes de tal manera que sólo se puedan ver $ m-1$. Además, podemos reordenar el lado oculto de la manera que queramos. Con esto tenemos que&lt;/p>
&lt;p>$ f(0,0) = 1$ $ f(n,m) = \begin{cases} 0 &amp;amp; \text{si } m &amp;gt; n\\ \sum_{i=0}^{n-1}({n-1 \choose i} * f(i,m-1) * (n-i-1)!) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>con lo que resolvemos el problema en tiempo $ O(N^3)$ y memoria $ O(N^2)$.&lt;/p>
&lt;p>Esto se puede mejorar aún más observando que $ f(n,m)$ está computando los números de Stirling de primera clase, para los cuales hay una recurrencia que se puede utilizar para calcularlos en tiempo $ O(N^2)$.&lt;/p>
&lt;p>Los números de Stirling de primera clase cuentan las permutaciones de $ n$ elementos con $ m$ ciclos. Considere una permutación con $ m$ ciclos de los $ n$ edificios. Cada ciclo debe tener un elemento máximo. Además podemos ordenar los ciclos entre sí por su elemento mayor. De esta manera, tenemos $ m$ edificios visibles. Ya que estamos contando todas las permutaciones con $ m$ ciclos, cada posible ordenamiento con $ m$ edificios visibles será considerada. Esto se debe a que cada ciclo tiene únicamente un ordenamiento en el cual sólo uno de sus elementos es visible: el que comienza con el edificio más grande.&lt;/p>
&lt;p>Aquí está el código que implementa esta solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8467347.js">&lt;/script></description></item><item><title>Solución a "Panoramas"</title><link>https://blog.omegaup.com/solution/solucion-a-panoramas/</link><pubDate>Thu, 16 Jan 2014 17:36:38 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-panoramas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Tour" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Ángel Covarrubias &lt;strong>Fuente&lt;/strong>: Miguel Ángel Covarrubias&lt;/p>
&lt;p>El problema es un Steiner tree problem (un MST pero donde sólo hay que conectar un subconjunto de nodos) pero con costo por nodo en vez de por arista. El grafo de los panoramas es un árbol más un ciclo. Para un árbol una solución es poner como raíz a $ s_1$ y para cada $ s_i$ marcar los nodos en su camino hacia la raíz. Se puede usar DP o recursión para calcular el mínimo numero de vertices que conectan todos los nodos interesantes y pasan por la raíz para cada subárbol.&lt;/p>
&lt;p>$ \mathrm{dp}_r=\mathrm{interesante}(r)\ \mathrm{si}\ \Sigma_h\mathrm{dp}_h=0$ $ \mathrm{dp}_r = \Sigma_h\mathrm{dp}_h+1\ \mathrm{si}\ \Sigma_c\mathrm{dp}_h&amp;gt;0$&lt;/p>
&lt;p>$ h$ es un hijo de $ r$. La arista extra $ (u,v)$ en el ciclo $ c$ permite usar otros caminos a lo largo de $ c$. Tales caminos deben conectar todos los nodos en $ c$ que tengan nodos interesantes en su árbol después de quitar las aristas del ciclo $ E-c$. Etiquetemos tales nodos con un uno y los demás nodos del $ c$ con un cero. Para $ E-(u,v)$ el ciclo sólo no cubre los últimos ceros. Para encontrar la solución sólo basta encontrar la secuencia de ceros más grande. En el siguiente diagrama, la arista que falta es $ (u,v)$. La DP sólo no usa el último cero, pero es mejor no usar los dos ceros que están adyacentes.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">0&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">/&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">\\&lt;/span> &lt;span class="o">/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Este código implementa la solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8468920.js">&lt;/script></description></item><item><title>Solución a "Mapas de bits"</title><link>https://blog.omegaup.com/solution/solucion-a-mapas-de-bits/</link><pubDate>Sun, 06 Oct 2013 22:56:54 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mapas-de-bits/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P12/#problems/Mapas-de-bits" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 12&lt;/a> &lt;strong>Autor:&lt;/strong> Jorge Alberto González Martínez &lt;strong>Fuente&lt;/strong>: Jorge Alberto González Martínez&lt;/p>
&lt;p>En el problema se describen dos formas de representar un mapa de bits.&lt;/p>
&lt;p>La forma bidimensional es simplemente utilizar una matriz para representar los bits. La forma por descomposición consiste en agrupar los bits similares y solo escribir el valor de los bits similares. En caso de que no sean similares todos los bits en un mapa de bits dado, se procede a dividir en cuatro secciones, imprimir la letra D y procesar cada uno de los cuartos de la misma manera, tal como se lee en la descripción del problema.&lt;/p>
&lt;p>La solución a este problema consistía en programar el método descrito. Este método inherentemente está basado en la técnica de divide y vencerás.&lt;/p>
&lt;p>A continuación, un pseudo-código que muestra la forma de llevar a cabo la transformación de un mapa de bits bidimensional a la forma reducida:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">todos&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">elementos&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">mapaDeBits&lt;/span> &lt;span class="n">son&lt;/span> &lt;span class="n">iguales&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Imprime&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">valor&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">termina&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Imprime&lt;/span> &lt;span class="n">D&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorIzquierdo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorDerecho&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorIzquierdo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorDerecho&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>El método para hacer la transformación inversa es muy parecido, sólo que para imprimir la equivalencia hay que comenzar con un mapa de bits bidimensional que nos sirva de variable auxiliar para hacer la conversión. Esta variable auxiliar se puede declarar de manera global y, cuando el método recursivo termine, simplemente imprimir su contenido:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">mapaDeBits&lt;/span> &lt;span class="n">comienza&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">un&lt;/span> &lt;span class="n">valor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Rellenar&lt;/span> &lt;span class="n">sección&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">mapa&lt;/span> &lt;span class="n">bidimensional&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">valor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorIzquierda&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorDerecha&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorIzquierda&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorDerecha&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>La primera vez que se llama a la función AmplificaMapa se debe entregar la representación de la forma por descomposición del mapa de bits en la variable mapaDeBits y la sección que se entrega inicialmente es todo el mapa de bits. Esto puede ser manejado por filas y columnas.&lt;/p>
&lt;p>A continuación se muestra una implementación en C++ que resuelve el problema. Nótese cómo se maneja la sección sobre la que se está trabajando con cuatro variables: &lt;code>tl_row&lt;/code>, &lt;code>tl_col&lt;/code>, &lt;code>br_row&lt;/code>, &lt;code>br_col&lt;/code>. El nombre de las variables proviene de top-left row, top-left colum, bottom-right row y bottom-right colum respectivamente. Representan los índices (fila,columa) de las esquinas superior izquierda e inferior derecha.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860210.js">&lt;/script></description></item><item><title>Solución a "Pista"</title><link>https://blog.omegaup.com/solution/445/</link><pubDate>Sun, 06 Oct 2013 22:48:35 +0000</pubDate><guid>https://blog.omegaup.com/solution/445/</guid><description>
&lt;ul>
&lt;li>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P14#problems/pista" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 14&lt;/a>&lt;/li>
&lt;li>&lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente&lt;/strong>: Codeforces&lt;/li>
&lt;/ul>
&lt;p>Este problema es una ligera modificación del Let&amp;rsquo;s Play Osu! que apareció en la ronda 146 en Codeforces. &lt;a href="http://codeforces.ru/blog/entry/5592" target="_blank" rel="noopener">La solución explicada la pueden encontrar en el editorial.&lt;/a>&lt;/p>
&lt;p>Para $ N \le 10$ se pueden checar todas las $ 2^N$ configuraciones de pistas. Para $ N \le 1000$ funciona una dinámica $ O(N^2)$, donde los estados son (posición, altura/profundidad que se lleva hasta el momento).&lt;/p>
&lt;p>Les dejo la implementación de DiegoRoque como un muy buen ejemplo de una solución a este problema.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860151.js">&lt;/script></description></item><item><title>Solución a "DP Genérica"</title><link>https://blog.omegaup.com/solution/solucion-a-dp-generica/</link><pubDate>Wed, 25 Sep 2013 06:00:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-dp-generica/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P13#problems/DP-Generica" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 13&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Project Euler&lt;/p>
&lt;p>Podemos tratar este problema de varias maneras distintas, 3 de las cuales discutiré en esta solución.&lt;/p>
&lt;h2>Análisis 1
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero, una idea que hubiera obtenido 50 puntos.&lt;/p>
&lt;p>Podemos observar que el problema es equivalente a encontrar de cuántas maneras se le puede asignar un número $ n_i$ del conjunto $ \{0,1,2\}$ a cada potencia de 2 tal que $ \sum_{i=0}^{\infty} n_i 2^i = x$. Esto también es equivalente a encontrar cuántos números $ a$ y $ b$ hay tales que $ a + b = x$ y no haya ningún bit encendido en $ b$ que no esté encendido en $ a$.&lt;/p>
&lt;p>Consideremos la expansión binaria de $ a = \sum_{i=0}^{\infty} a_i 2^i$ y $ b = \sum_{i=0}^{\infty} b_i 2^i$ , donde cada $ a_i$ y $ b_i$ es 1 o 0. Al sumar $ a + b = \sum_{i=0}^{\infty} (a_i + b_i) 2^i$ tenemos que $ 0 \le n_i = a_i + b_i \le 2$, como se necesita. Para contar solamente una vez cada configuración distinta de la secuencia $ n$, añadimos la restricción de que cualquier $ b_i$ puede ser 1 sólo si $ a_i$ también lo es.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Para esta subtarea es suficiente probar todas las $ a$ y $ b$ posibles, revisando con un loop para cada bit si la condición sobre $ b$ se cumple. Este algoritmo corre en tiempo $ O(N^2 \log N)$.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Para esta subtarea podemos hacer una observación sencilla: a cada $ a$ sólo le puede corresponder una $ b$, igual a $ x - a$, lo que reduce la complejidad en tiempo del algoritmo a $ O(N \log N)$.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos comprobar si $ b$ cumple la condición en tiempo constante utilizando operaciones de bits. Si &lt;code>~a &amp;amp; b&lt;/code> es igual a 0, $ b$ no tiene ningún bit encendido que $ a$ no tenga encendido. Ahora tenemos un algoritmo lineal. Desafortunadamente, ya no podemos mejorar nuestra solución fácilmente continuando con esta idea.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702819.js">&lt;/script>
&lt;h2>Análisis 2
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-1">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos hacer programación dinámica de forma &lt;em>top-down&lt;/em>. En ésta, contamos la cantidad de maneras de escribir $ x$ como pide el problema incluyendo o no cada una de las potencias distintas.&lt;/p>
&lt;p>Consideremos la función $ f(n,p)$, que cuenta de cuántas maneras podemos escribir $ n$ utilizando potencias de 2 menores o iguales a $ p$ no más de 2 veces cada una. Es evidente que la respuesta se encontraría evaluando $ f(x,63)$.&lt;/p>
&lt;p>Sabemos que $ f(n,p) = 0$ si $ n$ es negativo o si $ p$ es negativo. Del mismo modo, $ f(n,p) = 1$ si $ n = 0$. De lo contrario, es igual a la suma de $ f(n,p-1)$, $ f(n-2^p,p-1)$ y $ f(n-2^{p+1},p-1)$, que corresponden a poner 0, 1, o 2 veces la potencia $ 2^p$.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Aplicando directamente el análisis anterior, la subtarea 1 queda resuelta.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Varios de estos estados se repiten, así que convendría memorizarlos. Utilizando un contenedor como &lt;code>std::map&lt;/code>, la solución se vuelve lo suficientemente rápida para resolver esta subtarea.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos determinar en algunos casos rápidamente si la función se evaluará a 0. Sabemos que $ \sum_{i=0}^{k} 2^i = 2^{k+1} - 1$. Entonces, el número más grande que podemos escribir sólo usando potencias de 2 menores o iguales a $ p$ a lo más dos veces es $ 2\sum_{i=0}^{p} 2^p = 2 (2^{p+1} - 1) = 2^{p+2} - 2$. Por lo tanto, $ f(n,p) = 0$ si $ n &amp;gt; 2^{p+2} - 2$.&lt;/p>
&lt;p>Esa optimización por sí misma (sin memorización), resuelve la subtarea 3.&lt;/p>
&lt;h1>Subtarea 4&lt;/h1>&lt;p>Combinando las ideas de las dos subtareas anteriores, el algoritmo es lo suficientemente rápido para resolver todos los casos. Específicamente, la cantidad de estados que no podemos determinar como no viables instantáneamente es proporcional a $ \log x$, y cada estado lo podemos evaluar en tiempo $ O(\log \log x)$ por nuestro &lt;code>std::map&lt;/code>, dándonos una complejidad total de $ O(\log x \log \log x)$. Esta cota puede quedar más clara después de describir la tercera solución.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702849.js">&lt;/script>
&lt;h2>Análisis 3
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-2">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución es equivalente a la anterior, pero no precisa de un &lt;code>std::map&lt;/code>.&lt;/p>
&lt;p>Consideremos la función $ n(k)$, que definimos como el número que obtenemos tomando los bits $ 0..k$ de $ x$. En otras palabras, si $ x = \sum_{i=0}^{\infty} x_i 2^i$ donde $ x_i$ es el $ i$-ésimo bit de $ x$, $ n(k) = \sum_{i=0}^k x_i 2^i$. Ahora, definimos la función $ g(i,r)$, que cuenta de cuántas maneras se puede escribir el número $ n(i) + r2^i$, utilizando potencias de 2 menores o iguales a $ i$ a lo más 2 veces. La respuesta, por lo tanto, se obtendría evaluando $ g(63,0)$.&lt;/p>
&lt;p>Ahora, sabemos que $ g(i,r) = 1$ si $ i &amp;lt; 0$ y $ r = 0$, porque podemos escribir sólo de una manera 0. Recordando que $ x_i$ es el $ i$-ésimo bit de $ x$, podemos decir que $ g(i,r)$ cuenta la cantidad de formas que se puede escribir el número $ (r+x_i)2^i + n(i-1)$. De ahora en adelante, por conveniencia, $ t = r + x_i$.&lt;/p>
&lt;p>Usando esto, podemos definir $ g(i,r)$ recursivamente:&lt;/p>
&lt;p>$ g(i,r) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \text{ y } r = 0 \\ \sum_{k=0}^{min(t,2)}g(i-1,2(t-k)) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>En otras palabras, si tenemos que poner $ t$ veces la potencia $ i$, podemos elegir ponerla hasta $ min(t,2)$ veces, y contar las maneras de escribir el resto usando potencias de 2 menores a $ p$. Pero como dejamos $ t-k$ veces la potencia $ i$ sin poner, es igual a poner $ 2(t-k)$ veces la potencia $ i-1$.&lt;/p>
&lt;p>La siguiente observación es que si $ t$ es mayor a 3, $ g(i,r) = 0$ porque $ 2\sum_{k=0}^{i} 2^k &amp;lt; 4 \times 2^{i}$. Entonces, sólo nos interesan los casos en los que $ 0 \le t \le 3$. En total, sólo hay 4 valores posibles para $ t$ en los que $ g(i,r)$ no es 0: 0, 1, 2, y 3. Enumerémoslos:&lt;/p>
&lt;p>$ g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,4) + g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,6) + g(i-1,4) + g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Pero $ g(i,r) = 0$ si $ t &amp;gt; 3$, y como $ t \ge r$, nos quedamos con:&lt;/p>
&lt;p>$ g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Tomando en cuenta que $ r$ sólo puede ser 0 o 2, y $ x_i$ sólo 0 o 1:&lt;/p>
&lt;p>$ (g(i,0),g(i,2)) = \begin{cases} (g(i-1,0),g(i-1,2)+g(i-1,0)) &amp;amp; \text{si } x_i = 0 \\ (g(i-1,2)+g(i-1,0),g(i-1,2)) &amp;amp; \text{si } x_i = 1 \end{cases}$&lt;/p>
&lt;p>El siguiente código implementa esta solución, que corre en tiempo $ O(\log n)$ y espacio constante:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702863.js">&lt;/script>
&lt;p>Como podemos observar, esta solución considera los mismos estados que la anterior, sólo que aquí evitamos computarlos, mientras que la otra los descarta inmediatamente.&lt;/p>
&lt;h2>Consideraciones
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-3">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Varios competidores no consideraron que $ x$ no cabe en un entero signado de 64 bits. Si bien la &lt;em>respuesta&lt;/em> cabe en uno, en los límites del problema se especifica que $ x &amp;lt; 2^{64}$.&lt;/p>
&lt;h2>Análisis adicional:
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-4">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;a href="https://omegaup.com/profile/DiegoRoque" target="_blank" rel="noopener">Diego Roque&lt;/a> escribió una solución distinta, la cual detallaré a continuación.&lt;/p>
&lt;p>Consideremos la función $ f(x)$ como la define el problema: la cantidad de maneras de escribir $ x$ como una suma de potencias no negativas de 2 sin usar cada una más de 2 veces.&lt;/p>
&lt;p>Enfoquémonos en la paridad de $ x$ (es decir, el último bit de $ x$). Si $ x$ es impar, necesariamente tenemos que poner una vez la potencia $ 2^0$, porque las otras dos opciones: ponerla 0 veces o ponerla 2 veces cambiarían la paridad de $ x$. Por lo tanto, $ f(x) = f(\frac{x-1}{2})$ si $ x$ es impar. En cambio, si es par, podemos elegir poner la potencia $ 2^0$ 0 o 2 veces, lo que nos deja con $ f(x) = f(\frac{x}{2}) + f(\frac{x}{2}-1)$. Sólo falta definir los casos base: $ f(0) = f(1) = 1$.&lt;/p>
&lt;p>Aquí está su código que implementa esta solución, que corre en tiempo $ O(\log^2 x \log \log^2 x):$&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702891.js">&lt;/script></description></item><item><title>Solución a "Comesolo"</title><link>https://blog.omegaup.com/solution/solucion-a-comesolo/</link><pubDate>Sat, 14 Sep 2013 05:21:32 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-comesolo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/comesolo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://lhchavez.com" target="_blank" rel="noopener">lhchavez&lt;/a> &lt;strong>Fuente&lt;/strong>: Félix&lt;/p>
&lt;p>Este problema es especial porque es el primero en omegaUp de solo salida! Usualmente lo que debes esperar cuando te enfrentes con uno de esos problemas es que sea un problema NP que no tiene una solución rápida, y usualmente te pedirán que te aproximes lo más posible a la solución óptima. Esto significa que te vas a tener que valer de técnicas ad-hoc y heurísticas para sacar puntos.&lt;/p>
&lt;p>La solución del problema es bastante sencilla de explicar: haz una búsqueda en profundidad intentando todos los posibles movimientos por fuerza bruta hasta que te salga una solución aceptable e imprímela. El problema es que esta estrategia es $ O(n!)$, y como $ n$ puede valer hasta 30x30, puedes esperar que el programa corra varios milenios antes de encontrar la solución óptima. Hay tres trucos (en orden de importancia) para obtener una solución decente en un tiempo razonable:&lt;/p>
&lt;ul>
&lt;li>No repetir estados.&lt;/li>
&lt;li>No &amp;ldquo;clavarse&amp;rdquo; con soluciones que parece que son muy buenas, pero en realidad llevan a callejones sin salida.&lt;/li>
&lt;li>Encontrar una manera de darle prioridad a los estados que tengan más probabilidad de llegar a una solución buena.&lt;/li>
&lt;/ul>
&lt;p>La estrategia que yo personalmente seguí fue que cada que encontraba un nuevo estado, obtenía su &lt;a href="http://es.wikipedia.org/wiki/Funci%C3%B3n_hash" target="_blank" rel="noopener">hash&lt;/a> (que resultaba en un entero de 64 bits) y verificaba si no lo había visitado usando una tabla de hash&lt;a href="#note" >*&lt;/a>. Si no la había visitado, encontraba todos los estados vecinos (todos los tableros que resultaban de hacer un movimiento válido) y los guardaba en una fila de acuerdo a la cantidad de puntos (entre más puntos, más adelante en la fila). Luego, elegía aleatoriamente un estado de la fila dándole prioridad a los que estaban más adelante (pues son los que tienen mayor probabilidad de llegar a una buena solución), lo cual también me evitaba seguir un único camino donde me podría atorar. Repetí eso hasta que se me terminó la memoria de la computadora e imprimí la mejor solución.&lt;/p>
&lt;p>A continuación, el pseudocódigo de la solución:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Estado&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_init&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Estado&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tablero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Puedes usar cualquier algoritmo que genere un entero de 64 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># a partir de tablero y puntos. Este es el más sencillo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">53&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">hash&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">siguientes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todas las celdas (i, j) del tablero...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si la celda tiene una pieza...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todos los vecinos contiguos (i+k, j+l)...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Asegúrate que se haya movido \_algo\_.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que pueda brincar dentro del tablero.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="n">or&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nl">N&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que haya brincado una pieza.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que el lugar a donde brinca esté desocupado.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hijo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Estado&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Aumenta la puntuación del hijo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Borra la ficha original y la &amp;#34;comida&amp;#34;.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega la ficha en su posición final.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrégala a la cola correspondiente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">def&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Número aleatorio entre 0 y 1.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">RAND&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_MAX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># El índice de la última cola que estuvo llena.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La cola que se está considerando.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Elige la cola con mayores puntos que no esté vacía como
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># primera opción.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La primer cola tiene probabilidad de 31% de ser elegida.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># La segunda cola tiene probabilidad de 21%, la tercera 14%,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># la cuarta 10% y así sucesivamente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*=&lt;/span> &lt;span class="mf">1.45&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">lastfull&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">hashtable&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">lee&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">estado&lt;/span> &lt;span class="n">original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Estado&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_se&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_haya&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_terminado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_la&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_memoria&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si ya no hay más estados por visitar,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># encontramos la respuesta óptima en algún punto.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nl">Null&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Actualiza |mejor| si hay una respuesta mejor.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">mejor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">puntos&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Repetir estados es malo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="nl">_visitados&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega todos los vecinos.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">siguiente&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="n">partir&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">este&lt;/span> &lt;span class="n">punto&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">mejor&lt;/span>&lt;span class="o">|&lt;/span> &lt;span class="n">contiene&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="n">solución&lt;/span>&lt;span class="p">.&lt;/span> &lt;span class="n">Podemos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># saber qué movimiento se hizo para llegar a él comparando las
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># diferencias entre el tablero de |mejor.padre| y |mejor|. Ya solo es
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># cuestión de imprimir el resultado y listo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Aquí&lt;/span> &lt;span class="n">mucha&lt;/span> &lt;span class="n">gente&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">va&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">quejar&lt;/span> &lt;span class="n">porque&lt;/span> &lt;span class="n">solo&lt;/span> &lt;span class="n">guardar&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">abre&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">puerta&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">haya&lt;/span> &lt;span class="n">dos&lt;/span> &lt;span class="n">estados&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">puede&lt;/span> &lt;span class="n">tener&lt;/span> &lt;span class="n">hasta&lt;/span> &lt;span class="mi">900&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">tengan&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">mismo&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="mi">64&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">por&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">principio&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">palomar&lt;/span>&lt;span class="p">](&lt;/span>&lt;span class="nl">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="c1">//es.wikipedia.org/wiki/Principio_del_palomar)) y esté considerando que ya se visitó un estado que en realidad es nuevo. Si haces las cuentas, la probabilidad de colisión es negligible: la cantidad de estados que podía visitar en mi computadora (27 millones) es significativamente más pequeña que el número de estados necesarios para que la probabilidad de colisión sea de 1% ($ \\approx 10^{135}$, por la [paradoja del cumpleaños](http://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os)).
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "Colección"</title><link>https://blog.omegaup.com/solution/solucion-a-coleccion/</link><pubDate>Sat, 14 Sep 2013 05:16:07 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-coleccion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/coleccion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> Alexis Cervantes / César Cepeda &lt;strong>Fuente:&lt;/strong> Alexis Cervantes / César Cepeda&lt;/p>
&lt;p>&lt;strong>_Estructura de la solución: _&lt;/strong>¿Qué nos están pidiendo? El problema nos esta pidiendo que encontremos un subconjunto de las tarjetas tal que la suma de todos los puntajes de las tarjetas de ese subconjunto sea la maxima posible, y la suma de sus precios sea menor o igual al dinero con el que cuentas.  En otras palabras lo que se esta buscando es que:&lt;/p>
&lt;p>la suma &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_51.webm" type="video/mp4">
&lt;/video>
sea maxima siempre y cuando &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_52.webm" type="video/mp4">
&lt;/video>
&lt;/p>
&lt;p>donde &lt;em>Xi&lt;/em>** = &lt;strong>{1 si se compró la tarjeta _i&lt;/strong>, **_y 0 si no se compró}&lt;/p>
&lt;p>**_Modelo del espacio de búsqueda como árbol: _**Al final de cuentas, incluso el nombre lo indica, este problema se puede reducir a asignarle a cada tarjeta un 0 ó un 1 dependiendo de si la vamos a comprar o no, por lo que una forma de modelar el espacio de búsqueda sería formar un número binario de &lt;strong>&lt;em>N&lt;/em>&lt;/strong> dígitosy crear todos los valores posibles para dicho número.&lt;/p>
&lt;p>Para formar todos los números, podemos pensar que en el nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> del árbol vamos a decidir si compramos la tarjeta &lt;strong>&lt;em>j&lt;/em>&lt;/strong>, por lo tanto todos los nodos del nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> tendrán dos hijos, uno de ellos indicando que si compramos la tarjeta y el otro indicando que no la compramos.  El árbol de búsqueda queda como se muestra a continuación.&lt;/p>
&lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_53.webm" type="video/mp4">
&lt;/video>
&lt;p>_**Técnica de búsquda a utilizar: **_Dado que tenemos que entregar como resultado el camino con el mayor puntaje de todos , es preciso que revisemos el 100% de los caminos.  &lt;/p>
&lt;p>Una forma de resolver el problema es utilizar búsqued en profundidad, sin embargo el espacio de búsqueda es un árbol binario con &lt;strong>&lt;em>N&lt;/em>&lt;/strong> niveles por tanto de _**2N **_estados.  Para nuestro problema &lt;strong>&lt;em>N=500&lt;/em>&lt;/strong> por lo que el espacio de búsqueda es indescriptiblemente grande, aunque claro que se pueden podar las ramas en las que el precio ya superó a la cantidad de dinero que tenemos, el aplicar la técnica de búsqueda en profundidad en este problema dificilmente alcanzaría para una **_N _**mayor que 24 ó 25.&lt;/p>
&lt;p>Necesitamos por tanto encontrar una poda mucho más agresiva.&lt;/p>
&lt;p>Anteriormente, en el ejemplo de los Tanques, utilizamos la búsqueda en profundidad para encontrar un camino mínimo, por lo tanto, debido a que cada nivel que descendemos el coste aumenta, se podía aplicar la poda de que si obteniamos algún mínimo se podían cortar todas las ramas cuyo coste fuera mayor o igual que el mínimo actual.  Sin embargo al querer encontrar un máximo, esto no es posible, ya que el coste por rama siempre aumenta y lo que queremos es es encontrar el máximo, así que no sabemos si el camino nos va a llevar a algo mejor a menos que lo recorramos todo!&lt;/p>
&lt;p>Pero que pasaría si tuvieramos una función tal que nos permitiera saber cual es el máximo posible que podemos obtener por una cierta rama?  En ese caso, podríamos cortar cualquier rama si supieramos que por ese camino es imposible lograr algo mejor que lo que ya tenemos.&lt;/p>
&lt;p>Esta técnica se conoce como de &amp;ldquo;acotamiento y poda&amp;rdquo;.  La idea es buscar una función que para cada estado del espacio de búsqueda nos de cotas del máximo posible al que se puede llegar por dicho camino y de mínimo seguro que podemos obtener también por ese camino.&lt;/p>
&lt;p>Esta técnica es increíblemente poderosa y conviene que mediten un momento sobre la misma.  Vale la pena hacer notar que no siempre es sencillo encontrar la función de acotamiento correcta.  Ya que una función que de una cota muy alta no nos sirve de mucho, ya que las podas serian pocas, pero una cota incorrecta nos puede hacer que entreguemos resultados incorrectos.  Por lo tanto al utilizar esta técnica, siempre debemos buscar la función que acote lo más posible pero estando siempre 100% seguros de que el resultado que obtuvimos es efectivamente mayor o igual al máximo posible.&lt;/p>
&lt;p>Para este problema voy a definir las dos funciones de acotamiento, llamemos &lt;strong>&lt;em>a(c)&lt;/em>&lt;/strong> a la función que nos da el máximo posible que se puede obtener estando en el nodo **&lt;em>c&lt;/em>**y &lt;em>&lt;strong>b(c)&lt;/strong>&lt;/em> a la función que nos da el mínimo asegurado que tenemos también al estar en el nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  El demostrar que ambas funciones son válidas queda como tarea para el alumno.&lt;/p>
&lt;p>Lo primero que tenemos que hacer es ordenar las tarjetas de acuerdo a la relación &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong>, es decir, cuantos puntos nos dan por cada peso gastado.  Como queremos obtener el máximo puntaje por nuestro dinero obviamente son mejores las tarjetas que nos dan muchos puntos por peso comparadas con las tarjetas que nos dan pocos puntos por cada peso gastado. &lt;em>&lt;strong>OJO: esto no implica que la solución correcta deba tomar siempre las mejores tarjetas, únicamente quiere decir que comparadas individualmente, para nuestro objetivo son mejores las tarjetas que dan más puntos por peso.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Una vez que tengamos todas las tarjetas ordenadas en base a este criterio, iremos decidiendo si las tomamos o no, en ese respectivo orden.  Para cada nodo, nuestras funciones de acotamiento estarán definidas de la siguiente manera:&lt;/p>
&lt;p>&lt;em>&lt;strong>b(c):&lt;/strong>&lt;/em>  Para calcular la cota mínima asegurada del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong> vamos tomando las tarjetas que aún no hemos utilizado según el ordenamiento mientras aún tengamos dinero, en el momento en el que no tengamos más dinero para comprar ahi nos detenemos.  Ese es el mínimo que seguro podemos obtener.&lt;/p>
&lt;p>_**a(c):  **_Para calcular la cota alta, hacemos el mismo procedimiento que en &lt;strong>&lt;em>b&lt;/em>&lt;/strong> (o mejor tomamos el resultado de &lt;strong>&lt;em>b&lt;/em>&lt;/strong> para no recalcular) y con la primera tarjeta que no pudimos tomamos su relacion &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong> y la multiplicamos por el dinero que aún tenemos disponible y lo sumamos a &lt;strong>&lt;em>b&lt;/em>&lt;/strong>.  Así obtenemos el máximo posible que se puede lograr en el subárbol del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  La operación que efectuamos al final fue la de utilizar el dinero que aún tenemos disponible para comprar un &amp;ldquo;pedazo&amp;rdquo; de la mejor tarjeta aún queda, obviamente esto no es posible ya que no podemos comprar pedazos de tarjeta, sin embargo nos sirve para calcular el máximo posible.  &lt;/p>
&lt;p>Demostrar que &lt;strong>&lt;em>b&lt;/em>&lt;/strong> es válida es trivial, sin embargo queda para el lector demostrar que &lt;strong>&lt;em>a&lt;/em>&lt;/strong> es una cota que siempre dará un número mayor o igual al máximo posible que se puede obtener por ese camino.&lt;/p>
&lt;p>Obviamente una vez que tengamos las funciones de acotamiento, podemos hacer nuestra búsqueda almacenando cual es el mejor mínimo asegurado que hemos obtenido hasta el momento y eliminando todas las ramas cuyo máximo asegurado es menor o igual que éste.&lt;/p>
&lt;p>**_Detalles de implementación: _**Para la implementación queda un último detalle que resolver, y este es como vamos a buscar?  Como casi siempre tenemos dos opciones, la primera es la de la búsqueda en profundidad, para la cual se implementa una rutina recursiva y no se requiere de mantener arreglos de memoria externos.  Y la segunda es una búsqueda por amplitud, para la cual requieres de una cola que te permita almacenar los estados proximos a ser evaluados.&lt;/p>
&lt;p>Si optamos por la búsqueda en profundidad, hay un detalle de implementación muy sútil que puede ser de gran ayuda.  Supongan que modelamos el árbol de búsqueda como el que se muestra en la figura de arriba.  Y supongan que nuestro algoritmo de búsqueda revisa primero la rama izquierda, de ser asi, la cota mínima asegurada y la cota máxima del hijo de la izquierda es exactamente igual a la de su padre, por lo que bajariamos un nivel en la búsqueda sin obtener ninguna información nueva, si, en cambio, revisamos primero el hijo de la derecha, entonces estaríamos obteniendo nuevas cotas con información probablemente últil.&lt;/p>
&lt;p>Si se opta por la búsqueda en amplitud, se tiene una ventaja, y esta es que la cola se puede sustituir por un monticulo de modo que se priorice la búsqueda según el nodo que tiene el mejor mínimo asegurado.  Sin embargo aunque esto podría efectivamente reducir la búsqueda bastante no estamos seguros del tamaño que puede llegar a tener la cola y requeririamos que al llenarse la cola el programa pudiera cambiar a una técnica de búsqueda en profundidad, lo cual haría el código más enredado.  Sin embargo si se desea llegar a límites aún mas grandes, esta sería la opción a seguir.  &lt;/p>
&lt;p>&lt;strong>&lt;em>Implementación:&lt;/em>&lt;/strong>  &lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558998.js">&lt;/script></description></item><item><title>Solución a "Ubongo 3D"</title><link>https://blog.omegaup.com/solution/solucion-a-ubongo-3d/</link><pubDate>Sat, 14 Sep 2013 05:04:59 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-ubongo-3d/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/ubongo-3d" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente:&lt;/strong> Miguel Covarrubias&lt;/p>
&lt;p>La solución pone piezas de manera recursiva mientras quepan en el tablero y no se empalmen.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">P&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">regresa&lt;/span> &lt;span class="err">“&lt;/span>&lt;span class="n">Si&lt;/span>&lt;span class="err">”&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">rotación&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">casilla&lt;/span> &lt;span class="n">g&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">cubo&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">al&lt;/span> &lt;span class="n">poner&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">sobre&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">queda&lt;/span> &lt;span class="n">dentro&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">primeros&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="n">niveles&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">empalma&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">otra&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">ya&lt;/span> &lt;span class="n">puesta&lt;/span> &lt;span class="n">entonces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">marca&lt;/span> &lt;span class="n">las&lt;/span> &lt;span class="n">posiciones&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">como&lt;/span> &lt;span class="n">ocupados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">desmarca&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Para rotar una pieza se puede rotar por $ 0^o$, $ 90^o$, $ 180^o$ o $ 270^o$ alrededor de cada eje. El número de operaciones es aproximadamente (número de rotaciones * número de casillas del tablero * número de cubos de una pieza)$ ^3 \le (24 * 7 * 5)^3 &amp;lt; 600,000,000$. En los casos de prueba y en el juego todas las soluciones tocan la base del tablero, si no fuera así, solo hay que duplicar el 7 a 14. Para checar si una pieza se puede poner en cierta posición se pueden usar mascaras de bits para los niveles del tablero y para las posiciones ocupadas. Para poner la última pieza se puede comparar todas las rotaciones de los cubos no ocupados contra la última pieza y la complejidad cubica de la solución se reduce a cuadrática.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558928.js">&lt;/script></description></item><item><title>Solución a "Bloqueo"</title><link>https://blog.omegaup.com/solution/solucion-a-bloqueo/</link><pubDate>Tue, 10 Sep 2013 19:35:59 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-bloqueo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/bloqueo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.cimat.mx/~omar" target="_blank" rel="noopener">Khayyam&lt;/a> &lt;strong>Fuente&lt;/strong>: Khayyam&lt;/p>
&lt;p>La primera observación que hay que hacer es que si todas las carreteras son bidireccionales y entre cada par de ciudades existe exactamente un camino que las conecta (usando una o mas carreteras) entonces la representación gráfica del problema es un árbol: los nodos representan las ciudades y las aristas representan las carreteras. La siguiente figura, muestra el árbol que representa el caso de prueba dado como ejemplo. Los nodos rojos representan las ciudades ocupadas, el esfuerzo necesario para destruir cada carretera se muestra junto a la arista correspondiente. Entonces queremos eliminar un subconjunto de aristas de peso total mínimo de tal forma que los nodos rojos queden separados.&lt;/p>
&lt;p>Caso de ejemplo&lt;/p>
&lt;p>Solución&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example_solution.png" alt="" loading="lazy" />&lt;/p>
&lt;p>En problemas relacionados con árboles, es muy natural tratar de dividir el problema en problemas más pequeños que están dados por los sub-árboles del árbol original. Esto además sugiere usar recursión: &amp;ldquo;para resolver un árbol, primero resolvemos recursivamente sus sub-árboles y luego combinamos las sub-soluciones&amp;rdquo;.&lt;/p>
&lt;p>Comencemos con los casos sencillos. Si hay solamente un nodo (el árbol tiene altura 0), entonces no habrá aristas y el esfuerzo total necesario es cero.&lt;/p>
&lt;p>Consideremos ahora un árbol de altura 1 como el de la siguiente figura. Como la raiz no es roja, basta con eliminar una de las dos aristas: elegimos la que requiera menos esfuerzo.&lt;/p>
&lt;p>Caso sencillo: altura 1&lt;/p>
&lt;p>Solución (suponemos que la arista izquierda requiere menos esfuerzo)&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple0.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple1.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Si la raiz fuera roja, entonces tendríamos que eliminar ambas aristas. Con lo anterior nos damos cuenta de que hay dos casos que debemos considerar:&lt;/p>
&lt;ol>
&lt;li>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/li>
&lt;li>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos: la solución óptima es dejar conectado el nodo rojo asociado a la arista mas costosa.&lt;/li>
&lt;/ol>
&lt;p>Lo anterior se ilustra en la siguiente figura (aquí suponemos que la arista de la derecha es la mas costosa de todas):&lt;/p>
&lt;p>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/p>
&lt;p>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora que tenemos la solución para los casos pequeños, veamos si podemos usar estas soluciones para construir la solución del problema general, como en la siguiente figura.&lt;/p>
&lt;p>Si la raiz es roja y el nodo blanco está conectado&lt;br>
a algun descendiente rojo, la solución ya no es correcta&lt;/p>
&lt;p>Aún si la raiz es blanca, no podemos dejar conectado el nodo blanco&lt;br>
ya que si está conectado con un descendiente rojo, la solución sería incorrecta&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Supongamos que ya tenemos la solución para todos los hijos directos de la raíz, es decir, que ya cortamos de manera óptima las aristas de todos los subárboles, de modo que ningún par de nodos rojos se conectan en el sub-árbol. Usando sólo esta información, ¿podemos construir la solución del problema general?. Desafortunadamente, esto no es suficiente: nos gustaría dejar conectados a los hijos blancos, pero si existe un nodo rojo debajo de ellos, entonces tendríamos que desconectarlo también. Lo que necesitamos saber es precisamente si un hijo blanco está conectado con uno de sus descendientes rojos, de ser así diremos que el nodo blanco es &amp;ldquo;peligroso&amp;rdquo;. Si el nodo blanco está desconectado de todos sus descendientes rojos, entonces diremos que es &amp;ldquo;seguro&amp;rdquo;. Entonces tenemos tres tipos de nodos: ocupados, peligrosos y seguros, que representamos como nodos rojos, amarillos y verdes, respectivamente.Con este nuevo concepto, vemos que tenemos dos tipos de soluciones distintas para una raíz blanca: tenemos soluciones peligrosas y soluciones seguras. Es fácil ver que no existen &amp;ldquo;hojas peligrosas&amp;rdquo;, ya que las hojas están ocupadas (rojas) o son seguras (verdes).&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootOneGreen.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/yellowRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/greenRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Reformulemos nuestra solución con este concepto. Si la raíz es roja, entonces debemos desconectarla de todos sus hijos rojos y de todos sus hijos peligrosos. Esto significa que para cada hijo blanco tenemos dos opciones:&lt;/p>
&lt;ul>
&lt;li>Hacer que el hijo sea seguro (verde) y no cortar la arista que lo une con la raíz (puede ser costoso hacerlo seguro, pero con eso nos ahorramos el costo de separarlo de la raíz)&lt;/li>
&lt;li>Hacer que el hijo sea peligroso (amarillo) y cortar la arista que lo une con la raíz (puede ser barato dejarlo inseguro, pero pagamos al separarlo de la raíz)&lt;/li>
&lt;/ul>
&lt;p>Lo anterior resuelve el caso en que la raíz es roja.&lt;/p>
&lt;p>Ahora, si la raíz no es roja, debemos calcular dos soluciones: la solución segura (dejar la raíz verde) y la solución peligrosa (dejar la raíz amarilla). Notemos que la solución segura es exactamente igual al caso anterior. Por otro lado, para la solución peligrosa, debemos dejar la raíz conectada a exactamente un hijo que sea rojo o peligroso. Para elegir cuál de todos los hijos rojos o peligrosos dejaremos conectado, basta iterar sobre todos los hijos y elegir la mejor opción. El código queda como sigue:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559253.js">&lt;/script></description></item><item><title>Solución a "La Venganza de Silvio"</title><link>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</link><pubDate>Thu, 08 Aug 2013 02:02:51 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/VenganzaDeSilvio" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Freddy&lt;/p>
&lt;p>Este problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.&lt;/p>
&lt;h2>Subtarea 1
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para obtener el primer grupo de puntos, sólo basta calcular $ N^M$ multiplicando a $ N$ por sí mismo $ M$ veces, teniendo cuidado de que no haya overflow.&lt;/p>
&lt;h2>Subtarea 2
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-1">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar &lt;a href="http://es.wikipedia.org/wiki/Exponenciaci%c3%b3n_binaria" target="_blank" rel="noopener">exponenciación binaria&lt;/a>.&lt;/p>
&lt;p>Sabemos que $ x^0 = 1$, que $ (x^n)^2 = x^{2n}$, y que $ x * x^{n-1} = x^n$ para toda $ x$ y $ n$, por lo que podemos escribir la siguiente relación:&lt;/p>
&lt;p>$ \text{potencia}(N,M) = \begin{cases} 1 &amp;amp; \text{si } M = 0 \\ (potencia(N,M/2))^2 &amp;amp; \text{si } M \text{ es par} \\ N * (potencia(N,(M-1)/2))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>Aplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $ O(log M)$, ya que en cada paso $ M$ se reduce a la mitad.&lt;/p>
&lt;h2>Subtarea 3
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-2">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $ M$. Para ello requerimos una observación adicional. Dividir entre $ 2$ en base $ 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.&lt;/p>
&lt;p>Podemos aprovechar esta observación guardando $ M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $ A$ es el arreglo donde guardamos los bits de $ M$, está $ 0$-indexado, tiene $ k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $ potencia2(N,k-1)$, donde $ potencia2$ es:&lt;/p>
&lt;p>$ \text{potencia2}(N,i) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \\ (potencia2(N,i-1))^2 &amp;amp; \text{si } A[i] = 0 \\ N * (potencia2(N,i-1))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;h2>Subtarea 4
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-3">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.&lt;/p>
&lt;p>Por conveniencia, definamos $ f(i)$ como el número que se obtiene tomando los elementos $ [0..i]$ del arreglo $ A$, y $ f(-1) = 0$. Recordando que multiplicar por $ 2$ en base $ 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $ f(i) = 2f(i-1) + A[i]$.&lt;/p>
&lt;p>Ahora, es simple notar que $ potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $ potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.&lt;/p>
&lt;p>Por lo tanto, podemos escribir un ciclo en vez de utilizar recursión.&lt;/p>
&lt;p>Este algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.&lt;/p>
&lt;p>Aquí está la implementación del algoritmo anterior:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559240.js">&lt;/script>
&lt;h2>Consideraciones
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-4">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Hay que tener cuidado de que no haya overflow. Cuando un entero de $ k$ bits se eleva al cuadrado, puede ahora tener a lo más $ 2k$ bits. Como $ m$ puede tener hasta $ 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.&lt;/p>
&lt;p>También, varios competidores no consideraron el caso en el que se pide calcular $ N^0 \pmod 1$.&lt;/p></description></item><item><title>Solución a Las Cartas del Dr. Lira</title><link>https://blog.omegaup.com/solution/solucion-a-las-cartas-del-dr-lira/</link><pubDate>Mon, 29 Jul 2013 15:26:08 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-las-cartas-del-dr-lira/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/CartasDrLira" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.linkedin.com/in/joemmanuel/" target="_blank" rel="noopener">Joemmanuel Ponce Galindo&lt;/a> &lt;strong>Fuente&lt;/strong>: Topcoder&lt;/p>
&lt;p>Básicamente lo que nos pide el problema es encontrar el número de cartas que son distintas entre la configuración que es dada como entrada y una configuración donde las cartas estén alternadas.&lt;/p>
&lt;p>Cómo se explica en el problema, sólo hay 2 estados posibles en los que una carta puede estar: negro (B) y blanco (W). En otras palabras, la observación clave para resolver el problema es darse cuenta que sólo existen 2 configuraciones que cumplen con las reglas que necesita Dr. Lira: Una configuración donde la primer carta es W, la siguiente B, la siguiente W y así sucesivamente. La otra configuración posible es donde las cartas empiezan con B, forzando la siguiente carta a ser W y esta a su vez forzando la siguiente carta a ser B.&lt;/p>
&lt;p>Contar el número de caracteres diferentes entre una cadena y otra sólo requiere de un ciclo, por lo que la complejidad es lineal con respecto al tamaño de la cadena. Lo único que tenemos que hacer es entonces comparar la cadena dada como entrada con las configuraciones BWBW.. y WBWB&amp;hellip;, contar el número de diferencias y dar como salida el mínimo de estos números.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559228.js">&lt;/script></description></item><item><title>Solución a "Cueva"</title><link>https://blog.omegaup.com/solution/solucion-a-cueva/</link><pubDate>Mon, 14 Jan 2013 16:27:54 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-cueva/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P4" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>Después de comprender el problema podemos deducir dos cosas:&lt;/p>
&lt;ul>
&lt;li>Los &lt;strong>N&lt;/strong> puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán &lt;strong>N-1&lt;/strong> aristas y siempre hay un camino entre cualquier par de nodos.&lt;/li>
&lt;li>Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las &lt;strong>Q&lt;/strong> preguntas, ¿el nodo A es un ancestro del nodo &lt;strong>B&lt;/strong>?”, de modo que necesitamos encontrar una manera óptima de saberlo.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Subtarea 1&lt;/strong>&lt;/em>. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si &lt;strong>A&lt;/strong> es ancestro de &lt;strong>B&lt;/strong>, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo &lt;strong>A&lt;/strong> encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo &lt;strong>B&lt;/strong>, si existe un camino del nodo &lt;strong>A&lt;/strong> al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo &lt;strong>A&lt;/strong> es el mismo nodo &lt;strong>B&lt;/strong>, en ambos casos la respuesta es 0.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NQ)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>&lt;em>Subtarea 2.&lt;/em>&lt;/strong> Es notable que esta vez el número de preguntas es mucho mayor, por ello la solución anterior tardaría demasiado. Cambiemos nuestra estrategia, esta vez realicemos una búsqueda en profundidad desde el nodo 1 hasta los demás &lt;strong>N&lt;/strong> nodos, llevando una lista &lt;strong>L&lt;/strong> de los nodos que forman parte del camino desde el nodo 1 hasta el nodo &lt;strong>K&lt;/strong>, incluyendo los nodos 1 y &lt;strong>K&lt;/strong>, esto puede lograrse mediante recursividad.&lt;/p>
&lt;p>La tabla &lt;strong>ancestro[K][M]&lt;/strong> nos permitirá saber si el nodo &lt;strong>M&lt;/strong> es un ancestro del nodo &lt;strong>K&lt;/strong>, dándonos cuenta que todos los ancestros de &lt;strong>K&lt;/strong> se encuentran en la lista &lt;strong>L&lt;/strong> cuando la búsqueda en profundidad llega al nodo &lt;strong>K&lt;/strong>, podemos llenar la tabla &lt;strong>ancestro[K][M]&lt;/strong> durante la búsqueda en profundidad. Con la tabla anterior es fácil responder las preguntas, pues la respuesta depende de &lt;strong>ancestro[B][A]&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N2+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 3&lt;/strong>&lt;/em>. Para obtener los puntos de esta subtarea podemos utilizar cualquier algoritmo para resolver el clásico problema del ancestro común de dos nodos en un árbol, puesto que la respuesta es 1 si el ancestro común entre los nodos &lt;strong>A&lt;/strong> y &lt;strong>B&lt;/strong> es el nodo &lt;strong>A&lt;/strong>. Este problema ya ha sido estudiado ampliamente y tiene diversas formas de ser resuelto con complejidad &lt;strong>O(NlogN)&lt;/strong>, en el foro de tutoriales de TopCoder podemos encontrar un buen artículo con algunos de los algoritmos que pueden ser utilizados:&lt;/p>
&lt;p>&lt;a href="http://community.topcoder.com/tc?module=Static&amp;amp;d1=tutorials&amp;amp;d2=lowestCommonAncestor" target="_blank" rel="noopener">TopCoder Lowest Common Ancestor&lt;/a>&lt;/p>
&lt;p>El algoritmo que utiliza programación dinámica es el más recomendado, puesto que se puede responder a las &lt;strong>Q&lt;/strong> preguntas en un tiempo constante.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NlogN+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 4&lt;/strong>&lt;/em>. Para empezar, notemos que la solución anterior no funciona para este conjunto de puntos porque utiliza demasiada memoria, el simple hecho de almacenar los nodos y las aristas ocupa bastante espacio en memoria (aproximadamente 100Mb) y una solución para la subtarea 3 requeriría al menos 50Mb más, por lo tanto no es posible completar la subtarea 4 con una solución como la anterior, para obtener los 100 puntos en este problema necesitamos una idea mucho más creativa.&lt;/p>
&lt;p>Renombremos todos los nodos del árbol enumerandolos del 1 al &lt;strong>N&lt;/strong> siguiendo el orden establecido por el recorrido en postorden del árbol comenzando por el nodo 1, después, para cada nodo, con su respectivo número &lt;strong>Y&lt;/strong>, hay que obtener el menor número presente en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>, denotemos este número menor como &lt;strong>X&lt;/strong>, con los números &lt;strong>X&lt;/strong> y &lt;strong>Y&lt;/strong> definimos entonces un intervalo cerrado &lt;strong>[X,Y]&lt;/strong> que nos representa que en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong> se contienen todos los nodos cuyo número se encuentra en el intervalo &lt;strong>[X,Y]&lt;/strong>. Podemos interpretar esta información de una manera más conveniente, un nodo con número &lt;strong>Y&lt;/strong> es ancestro de un nodo con número &lt;strong>K&lt;/strong> si &lt;strong>X ≤ K ≤ Y&lt;/strong>, lo cual nos permitirá responder las preguntas planteadas.&lt;/p>
&lt;p>Es recomendable que el olímpico experimente y se convenza que la propiedad del intervalo &lt;strong>[X,Y]&lt;/strong> es siempre correcta debido a que el recorrido en postorden establecerá que el nodo con el número &lt;strong>X&lt;/strong>, que establece la cota inferior del intervalo, siempre será una hoja del subárbol y el nodo con valor &lt;strong>Y&lt;/strong>, que establece la cota superior del intervalo, siempre será la raíz del subárbol, cualquier otro valor fuera del intervalo estará excluido del subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N+Q)&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>Solución a "Chilly Rapero"</title><link>https://blog.omegaup.com/solution/solucion-a-chilly-rapero/</link><pubDate>Sat, 12 Jan 2013 19:41:11 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-chilly-rapero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>La clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.&lt;/p>
&lt;p>Crear las aristas entre los nodos tiene una complejidad de O(LN2) y la manera más simple de almacenar dichas aristas es mediante una matriz de adyacencia. Ya que tenemos el grafo planteado, buscaremos la manera más rápida de cambiar de palabra entre cualquier par de palabras, esto puede conseguirse usando el algoritmo de &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Floyd-Warshall" target="_blank" rel="noopener">Floyd-Warshall&lt;/a> con una complejidad de O(N3) que es suficiente para el problema.&lt;/p>
&lt;p>Finalmente, para obtener la respuesta sumamos el mínimo número de cambios requeridos entre todos los pares de palabras consecutivas en el rap, este número de cambios fue obtenido mediante el algoritmo de Floyd-Warshall. El número total de cambios lo multiplicamos por 0.2 y será la respuesta para el problema.&lt;/p>
&lt;p>Complejidad de la solución: O(LN2+N3)&lt;/p></description></item><item><title>Solución a "Cambio"</title><link>https://blog.omegaup.com/solution/solucion-a-cambio/</link><pubDate>Tue, 08 Jan 2013 17:18:25 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-cambio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Lo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.&lt;/p>
&lt;h2>Solución de 30, 50 puntos
aliases: [&amp;rsquo;/solucion-a-cambio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-cambio">&lt;/span>
&lt;a href="#aliases-solucion-a-cambio" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.&lt;/p>
&lt;h2>Solución de 100 puntos
aliases: [&amp;rsquo;/solucion-a-cambio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-cambio-1">&lt;/span>
&lt;a href="#aliases-solucion-a-cambio-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Consideremos la solución anterior y tratemos de calcularlo de abajo hacia arriba, habría que crear una función que nos dijera para una cantidad dada y un set de monedas que se pueden usar (para no repetir) nos diga cuantas formas distintas hay de completar dicha cantidad. Si se logra construir dicha función la solución al problema es simple puesto que se reduce a llamar dicha función con la cantidad que nos piden y el set completo de monedas. Lo interesante radica en cómo se compone dicha función, suponiendo que la función funciona hay que tratar de construirla, primero hay que considerar los casos especiales, si la cantidad es cero significa que no hay que hacer nada y entonces hay una forma de lograrlo (es una combinación válida), si la cantidad es mayor a cero hay que sumar las combinaciones de tomar una moneda de la primera denominación disponible con las de dejar de tomar monedas de dicha denominación.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Para calcular las combinaciones de tomar una moneda de dicha denominación se puede usar la función a partir de la cantidad restante (la cantidad buscada menos la denominación de la moneda) y el mismo set de monedas.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Para calcular las combinaciones de dejar de tomar monedas de cierta denominación de igual forma se puede usar la función con la misma cantidad pero con un set de monedas que no incluya la denominación que decidimos dejar de tomar.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Si se toma la moneda sin considerar si la denominación es más grande que la cantidad entonces existe el caso donde la cantidad es negativa y en ese caso la respuesta debiera ser cero puesto que es una combinación no válida.&lt;/p>
&lt;p>De igual forma si el set de denominaciones disponibles está vacío significa que ya no hay más denominaciones para probar y por lo tanto no hay ninguna forma de lograrlo.&lt;/p>
&lt;p>Como podemos notar dicha función es recursiva y se llama a si misma hasta que la cantidad se vuelve cero, negativa y/o el set de denominaciones queda vació, y si lo analizamos un poco podemos darnos cuenta de que funciona. La forma simple de saber que set de monedas es usable es guardar el índice de la primera moneda usable y eliminarlas en orden. Hay que notar que hasta el momento no hemos mejorado en nada la solución anterior, y la complejidad de esto es similar a la de nuestra idea anterior.&lt;/p>
&lt;p>Lo que hay que notar es que la cantidad no tendrá más de 10,000 valores distintos y que nunca habrá más de 100 sets distintos, por lo tanto dicha función solo se puede mandar a llamar 1,000,000 de veces con parámetros distintos. Sin embargo sabemos que la cantidad de combinaciones puede llegar a ser mucho mayor. Entonces ¿Qué sucede?, pues es sencillo darse cuenta que dicha función se mandará a llamar más de una vez con los mismos parámetros y en todos esos casos siempre deberá entregar la misma solución, es por esto que podemos guardar las respuestas para cada uno de los casos en un array y así nunca tener que calcularlos más de una vez, esto hace que nuestro programa pueda correr en tiempo.&lt;/p>
&lt;p>&lt;em>El asunto de los módulos creo que es algo que debiesen saber sin embargo les digo que el modulo se puede aplicar al sumar el tomar y el no tomar, puesto que (A + B) modulo X es igual a (A modulo X + B modulo X ) modulo X.&lt;/em>&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559217.js">&lt;/script></description></item><item><title>Solución a "Minecraft"</title><link>https://blog.omegaup.com/solution/solucion-a-minecraft/</link><pubDate>Tue, 08 Jan 2013 17:14:15 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-minecraft/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Este problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.&lt;/p>
&lt;h2>Para los primeros 50 puntos
aliases: [&amp;rsquo;/solucion-a-minecraft']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-minecraft">&lt;/span>
&lt;a href="#aliases-solucion-a-minecraft" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.&lt;/p>
&lt;h2>Para los 75 puntos
aliases: [&amp;rsquo;/solucion-a-minecraft']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-minecraft-1">&lt;/span>
&lt;a href="#aliases-solucion-a-minecraft-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.&lt;/p>
&lt;h2>Para los 100 puntos
aliases: [&amp;rsquo;/solucion-a-minecraft']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-minecraft-2">&lt;/span>
&lt;a href="#aliases-solucion-a-minecraft-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución era para aquellos que supieran hacer una búsqueda utilizando una cola de prioridad. La idea es que al sacar un elemento de la cola siempre nos dé aquel al que se puede llegar con la menor cantidad de movimientos. Este procedimiento es idéntico a una búsqueda en amplitud solo que se utiliza una cola de prioridad. En la solución hago uso de un montículo como cola de prioridad.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559202.js">&lt;/script></description></item><item><title>Solución a "K-Arbol"</title><link>https://blog.omegaup.com/solution/solucion-a-k-arbol/</link><pubDate>Mon, 07 Jan 2013 17:37:40 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-k-arbol/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:lkt345@gmail.com" >Saul de Nova Caballero&lt;/a>&lt;/p>
&lt;p>En pocas palabras el problema es, dado un árbol que se puede colorear, encuentra la menor solución satisfaciendo las restricciones dadas sobre los colores. Este problema es un caso particular de Graph Coloring(en español coloración de grafos), en donde el grafo es un árbol.&lt;/p>
&lt;h1>Subcaso 1(10 puntos)&lt;/h1>&lt;p>Para el primer subcaso era posible hacer una búsqueda en profunidad sobre todos los nodos, encontrando la menor solución. Para guardar el árbol, era posible utilizar una matriz que guardara todos los colores posibles y entonces ver si era posible una solución con el menor color posible. La solución de este caso era trivial si se usaba una búsqueda exhaustiva.&lt;/p>
&lt;h1>Subcaso 2(20 puntos)&lt;/h1>&lt;p>Para el segundo subcaso era necesario una mejor estrategia. Para este caso, era necesaria la observación de que todos los colores de los nodos solo dependen de su padre y de sus hijos. Otra observación importante era que para los nodos del árbol, excepto las hojas, había que procesar a sus hijos menores.Procesar implica checar que colores puede tener un nodo. Por lo que para lograr los puntos en este subcaso era necesario procesar los nodos hijos, luego sus padres y asi sucesivamente. Es decir para procesar, un nodo primero hay que procesar a todos sus hijos.&lt;/p>
&lt;p>La forma de procesar a un nodo es la siguiente. Por cada nodo se compara con su padre y al momento de comparar, lo que se busca es que por cada color del nodo, el padre no tenga un color que lo elimine como opción. Es decir tengo el siguiente caso&lt;/p>
&lt;p>Nodo -&amp;gt; Rojo, Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo, Verde&lt;/p>
&lt;p>Por cada color del nodo, el padre puede elegir un color distinto. Por ejemplo, si el Nodo es Rojo, el padre puede ser Verde. Si el nodo es Verde, el padre puede ser Rojo y si el nodo es Azul, puedes elegir el Rojo o el Verde. Sin embargo, para el siguiente caso&lt;/p>
&lt;p>Nodo -&amp;gt; Rojo, Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo&lt;/p>
&lt;p>El padre del nodo solo puede ser Rojo, por lo que para que las condiciones del problema se cumplan, el Nodo no puede ser Rojo. En este caso actualizamos la tabla de valores posibles del Nodo. Y queda como&lt;/p>
&lt;p>Nodo -&amp;gt; Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo&lt;/p>
&lt;p>Lo anterior se hace para cada par de nodos desde los nodos hoja hasta la raíz. Procesandolos de menor a mayor da la mejor solución&lt;/p>
&lt;h1>Subcaso 3(20 puntos)&lt;/h1>&lt;p>Para obtener los puntos del subcaso 3 era posible simplemente ver por cada nodo procesarlo comenzando en la raíz, ya que en este caso el grafo en basicamente una gran línea. Utilizando la técnica descrita en el subcaso 2 por cada nodo se obtenía una solución a este subcaso&lt;/p>
&lt;h1>Subcaso 4(50 puntos)&lt;/h1>&lt;p>Para los puntos del cuarto caso era necesario &amp;ldquo;linearizar&amp;rdquo; el grafo, esto simplemente significa que los nodos mas arriba van a tener menor prioridad que los nodos de abajo, es decir el nodo raíz tendría valor 0 mientras que sus hijos tendrían valores más altos. Por ejemplo para un caso asi:&lt;/p>
&lt;p>0 -&amp;gt; 1 -&amp;gt; 4&lt;/p>
&lt;p>-&amp;gt; 2&lt;/p>
&lt;p>-&amp;gt; 3&lt;/p>
&lt;p>El nodo 0 es la raíz del árbol, el nodo 1 y 3 son hijos de 0 y los nodos 2 y 4 son hijos de 1, el arbol se linearizaría de la siguiente manera:&lt;/p>
&lt;p>0 -&amp;gt; 1, 1 -&amp;gt; 2, 3 -&amp;gt; 3, 4 -&amp;gt; 4, 2 -&amp;gt; 5&lt;/p>
&lt;p>Ahora lo que es necesario hacer es por cada nodo de mayor prioridad a los de menor prioridad es necesario hacer la técnica explicada en el subcaso 2.Tomando en cuenta otra observación. Que solo es necesario procesar los nodos que solo tengan un color. Es decir si el nodo 0 tiene posibilidad de ser Rojo, Azul o Verde, no es necesario procesarlo. Sin embargo si un nodo solo puede ser azul, hay que eliminar esa posiblidad tanto de su padre como de sus hijos.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/linearizar.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Imagen obtenida de &lt;a href="http://aima.cs.berkeley.edu/newchap05.pdf" target="_blank" rel="noopener">http://aima.cs.berkeley.edu/newchap05.pdf&lt;/a>&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span> &lt;span class="c1">// karbol100.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="c1">// By Saul de Nova Caballero
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">4&lt;/span> &lt;span class="c1">//Librerias de la standard template library de c++(stl)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">algorithm&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">6&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cassert&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">7&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cstdio&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">8&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cstdlib&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">9&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cstring&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">10&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">iostream&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">11&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">12&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">utility&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">13&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">14&lt;/span> &lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">15&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">16&lt;/span> &lt;span class="c1">//Iterador sobre estructuras de datos. En este caso listas de la stl
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">17&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">define&lt;/span> &lt;span class="n">TR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">18&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">typeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">19&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">20&lt;/span> &lt;span class="c1">//Definicion de un par de la stl
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">21&lt;/span> &lt;span class="k">typedef&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">pii&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">22&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">23&lt;/span> &lt;span class="c1">//Constantes del programa
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">24&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAXN&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10002&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">25&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAXM&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">502&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">26&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAXMEM&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">27&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">28&lt;/span> &lt;span class="c1">//Clase para definir los hijos del arbol
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">29&lt;/span> &lt;span class="c1">//Es una lista con todos los hijos de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Graph&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">31&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">32&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">addNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">33&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">34&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">35&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">36&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">37&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">38&lt;/span> &lt;span class="c1">//Clase para cola de las busquedas en amplitud
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">39&lt;/span> &lt;span class="c1">//Es de tipo generica
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">40&lt;/span> &lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">41&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Queue&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">42&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">43&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">44&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">p1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">p2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">45&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">46&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">front&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">47&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">48&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">49&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">50&lt;/span> &lt;span class="k">private&lt;/span> &lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">51&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">52&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXMEM&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">53&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">54&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">55&lt;/span> &lt;span class="c1">//Definicion de todas las variables del programa
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">56&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">C&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">//Variables dadas
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">57&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="c1">//La cantidad de colores posibles por nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">58&lt;/span> &lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="c1">//El padre de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">59&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//El color que le asigne al final al nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">60&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXM&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//Una matriz con todos los colores posibles por cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//Una lista ordenada de mayor a menor por la profundidad de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">62&lt;/span> &lt;span class="n">Graph&lt;/span> &lt;span class="n">tree&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//Mi arbol
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">63&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">pii&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//Una cola para la busqueda
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">65&lt;/span> &lt;span class="c1">//Regresa el color valido por cada nodo permitiendo que un nodo no sea de un color
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">66&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">constraint&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">67&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">68&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">constraint&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">69&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">70&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">71&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">72&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">73&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">74&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">75&lt;/span> &lt;span class="c1">//Funcion para la lectura de todas las variables y la inicializacion de las estructuras
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">76&lt;/span> &lt;span class="c1">//Los asserts son para probar que el codigo es correcto
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">77&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Guarda&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">allowedColors&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">posibles&lt;/span> &lt;span class="n">colores&lt;/span> &lt;span class="n">por&lt;/span> &lt;span class="n">nodo&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">una&lt;/span> &lt;span class="n">matriz&lt;/span>&lt;span class="err">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">78&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">79&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">prohibited&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">80&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">81&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">MAXN&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">82&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">83&lt;/span> &lt;span class="nf">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">84&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">85&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">86&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">87&lt;/span> &lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">88&lt;/span> &lt;span class="n">tree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">addNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">89&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">90&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">91&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">92&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">C&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">93&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">prohibited&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">94&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">prohibited&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">prohibited&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">95&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">prohibited&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//Checa que los nodos no se repitan ya que se pueden repetir
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">96&lt;/span> &lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">prohibited&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">97&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">98&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">99&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">100&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">101&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">102&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Una&lt;/span> &lt;span class="n">busqueda&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">amplitud&lt;/span> &lt;span class="n">para&lt;/span> &lt;span class="s">&amp;#34;linearizar el árbol&amp;#34;&lt;/span>&lt;span class="err">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">103&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">orderNodes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">104&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">make&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">105&lt;/span> &lt;span class="nf">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">106&lt;/span> &lt;span class="n">pii&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">107&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_front&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">108&lt;/span> &lt;span class="n">TR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">109&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">make&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">110&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">111&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">112&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">113&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">114&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Checa&lt;/span> &lt;span class="n">por&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">nodo&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">mayor&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">menor&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">linearizacion&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">colores&lt;/span> &lt;span class="n">posibles&lt;/span> &lt;span class="n">por&lt;/span> &lt;span class="n">nodo&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">solo&lt;/span> &lt;span class="n">tiene&lt;/span> &lt;span class="n">un&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="n">posible&lt;/span>&lt;span class="err">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">115&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">enforceArc&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">116&lt;/span> &lt;span class="nf">TR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">117&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">currNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">118&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">119&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currNode&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">120&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">121&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">122&lt;/span> &lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">123&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">124&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">125&lt;/span> &lt;span class="c1">//printf(&amp;#34;%d %d %d\\n&amp;#34;, currNode, parent, color);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">126&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">127&lt;/span> &lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">128&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">129&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">130&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">131&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">132&lt;/span> &lt;span class="c1">//Si no hay colores posibles, no se puede resolver el mapa
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">133&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">134&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;-1&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">n&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">135&lt;/span> &lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">136&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">137&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">138&lt;/span> &lt;span class="c1">//Checa de nuevo si alguno de los colores no puede ser
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">139&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">140&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">141&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;-1&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">n&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">142&lt;/span> &lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">143&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">144&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">145&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">146&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">147&lt;/span> &lt;span class="c1">//Hace un ciclo checando el menor color posible por nodo e imprime los colores menores
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">148&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">findSolution&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">149&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">150&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;::&lt;/span>&lt;span class="n">iterator&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">151&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">152&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">153&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">154&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">155&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">156&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">157&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">158&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">159&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">160&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">161&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">162&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">163&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">164&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">165&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">166&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">167&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">168&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">169&lt;/span> &lt;span class="n">orderNodes&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">170&lt;/span> &lt;span class="n">enforceArc&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">171&lt;/span> &lt;span class="n">findSolution&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">172&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">173&lt;/span> &lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "Metro"</title><link>https://blog.omegaup.com/solution/solucion-a-metro/</link><pubDate>Mon, 07 Jan 2013 17:22:45 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-metro/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>El problema en cuestión se reduce a encontrar un árbol de expansión mínima. La solución es una aplicación directa de alguno de los algoritmos existentes para ello (bien implementada), por lo que hablaré brevemente sobre una de las posibilidades y daré referencias donde puedan encontrar información más detallada.&lt;/p>
&lt;p>Para encontrar el costo mínimo de unir todas las estaciones debemos encontrar el árbol de expansión mínima de la gráfica en cuestión (es decir, una subgráfica conexa que una todos los vértices de la gráfica original y cuyo peso (la suma de los costos de todas sus aristas) sea el mínimo posible (siempre es un árbol)). Para ello una opción es usar el algoritmo de Kruskal: Ordenamos las aristas por su peso y vamos agregando cada arista de peso mínimo que no cree un ciclo en la gráfica. Hacemos esto hasta haber conectado todos los vértices de nuestra gráfica. Por la cantidad de aristas que tenemos requerimos ordenar eficientemente y verificar si las aristas forman un ciclo o no eficientemente en cada paso, de lo contrario el programa no correrá en tiempo.&lt;/p>
&lt;p>Para verificar si se forma o no un ciclo agregando una determinada arista empleamos el algoritmo conocido como Union Find, que se explica ampliamente en las secciones 16.7, 16.8 y 16.9 del libro Problemas y Algoritmos de Luis E. Vargas Azcona. Es importante mencionar que para obtener los 100 puntos en el problema es necesario implementar las optimizaciones que se mencionan (y aunque no fuera así no está de más que las conozcan).&lt;/p>
&lt;p>Además del libro de Luis E. Vargas, que recomiendo ampliamente, sugiero la página de Pier Guillen &lt;a href="http://pier.guillen.com.mx/" target="_blank" rel="noopener">http://pier.guillen.com.mx/&lt;/a> , que en -&amp;gt;Algorithms -&amp;gt;10. Gráficas -&amp;gt;10.6 Árboles Mínimos Generadores desarrolla el tema en cuestión. Y claro, no está de más que consulten el tema en el libro Introduction to Algorithms de Thomas H. Cormen, que en la tercera edición trabaja el tema en el capítulo VI. Graph Algorithms -&amp;gt;23 Minimum Spanning Trees.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559170.js">&lt;/script></description></item><item><title>Solución a "Pulseras"</title><link>https://blog.omegaup.com/solution/162/</link><pubDate>Mon, 07 Jan 2013 16:58:46 +0000</pubDate><guid>https://blog.omegaup.com/solution/162/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Considero este problema como un buen ejemplo para quienes desean comenzar a trabajar con problemas de programación dinámica. Se nos pide calcular la cantidad de pulseras diferentes que se pueden construir bajo ciertas condiciones. Podemos comenzar preguntándonos, ¿qué sucede si la primera cuenta es negra? La siguiente podrá ser sólo blanca. Y si comenzamos con una blanca, la siguiente puede ser negra o blanca. Podemos entonces en una matriz de 2xn colocar en cada columna cuántas secuencias distintas hay que en la posición i-ésima terminen en negro y cuántas en blanco de tal modo que no haya dos cuentas negras consecutivas. Simplemente, para obtener los números de la siguiente posición, observamos que el número de las que terminan en blanco es la suma de ambos números de la posición anterior y de las que terminan en negro es el número de secuencias que terminan en blanco de la posición anterior.&lt;/p>
&lt;p>Resta solo un detalle más a considerar. Requerimos que la secuencia no inicie y termine en negro, pues los extremos quedarán adyacentes al cerrar la pulsera. Una forma de resolver esto es la siguiente: Contamos, con el método descrito, cuántas secuencias distintas hay que inicien con blanco y que no tengan dos cuentas negras consecutivas. El número que nos pide el problema será entonces la cantidad de pulseras que empiezan con blanco y cumplen con que no haya dos negras consecutivas (independientemente de con qué color terminen) más el número de pulseras que inicien con negro y terminen con blanco (y claro, cumplan con que no haya dos negras consecutivas). ¿Cuántas hay de estas últimas? La misma cantidad que de pulseras que inician con blanco y terminan con negro, pues su simétrica inicia con negro, termina con blanco y claramente sigue cumpliendo el que no posea dos cuentas negras consecutivas. Así que es posible resolver el problema con un código muy breve, como se muestra abajo.&lt;/p>
&lt;p>Solo resta mencionar que hay que tener cuidado de aplicar el módulo correctamente. Se pueden evitar errores definiendo el valor del mismo para no tener que escribir el número varias veces.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559167.js">&lt;/script></description></item><item><title>Solución a "Los Bloques de Link"</title><link>https://blog.omegaup.com/solution/solucion-a-los-bloques-de-link/</link><pubDate>Mon, 07 Jan 2013 16:54:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-los-bloques-de-link/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Es claro que no es posible probar todas las sucesiones posibles de movimientos de los bloques para encontrar la solución (a excepción de casos muy simples). El número de tales sucesiones puede ser infinito en caso de que se puedan formar ciclos de movimientos (lo cual sucede en muchos de lo casos de prueba), y aún en casos donde el número sea finito puede suceder que no se tenga tiempo para probarlos todos.&lt;/p>
&lt;p>Una primera observación crucial es que, en el estado del mapa, solo nos interesa saber donde están los bloques de hielo en cada paso, es decir, su ubicación es lo que determina lo que nos interesa del estado. No nos interesan los pasos previos que los llevaron a su posición, solo que sea el número mínimo posible. Tenemos un problema que puede ser resuelto realizando una búsqueda en amplitud.&lt;/p>
&lt;p>¿Cuántos estados es posible alcanzar? El mapa es a lo más de 40x40 espacios y las orillas siempre están bloqueadas, así que realmente tenemos 38x38=1444 espacios a los que quizá es posible llevar a los bloques. Tenemos dos bloques de hielo, así que hay (1444x1443)/2=1,041,846 formas de colocarlos en el mapa (hemos considerado aquí ya el hecho de que son indistinguibles). Para fines de la búsqueda el número que hemos calculado es en realidad una cota superior muy mala (mala en el sentido de que la cota superior mínima es muy inferior, es decir, calculamos “de más”), pues por la forma en que se mueven los bloques es claro que aún en el peor de los casos posibles la cantidad de estados a los que se puede acceder es mucho menor (¿cuál es el peor de los casos?). Es posible entonces emplear una búsqueda en amplitud común para resolver el problema, el espacio de búsqueda no es muy grande y es claro que podemos recorrerlo por completo.&lt;/p>
&lt;p>Para representar los estados requerimos tener la posición de ambos bloques, y nada más. Podemos emplear una arreglo de bool&amp;rsquo;s (boolean&amp;rsquo;s en pascal) de cuatro dimensiones para marcar los estados a los que se ha accedido. Para la cola, en el código que se anexa más abajo, empleamos un arreglo de dos dimensiones (una matriz) donde además de guardar la posición de los bloques de los estados guardamos la cantidad de movimientos realizados para llegar a cada estado. Para ver a que estados podemos llegar desde un estado dado basta con ver en que direcciones es posible mover los bloques y a qué posición llegarán.&lt;/p>
&lt;p>Para optimizar la búsqueda podemos hacer dos observaciones. La primera es que con nuestra representación de los estados podríamos llegar dos veces al mismo estado, ya que los dos bloques de hielo son para nuestros fines iguales. En el código de abajo es por ello que al llegar a un estado nuevo se marcan dos valores en el arreglo de bools como verdaderos, pues ambos representan en realidad el mismo estado.&lt;/p>
&lt;p>Otra observación es que para averiguar eficientemente a que estados se puede llegar desde un estado dado podemos precalcular, antes de realizar la búsqueda, para cada espacio vacío o con bloque de hielo, cuál es la posición del espacio bloqueado (con numeral # o con el botón A) más cercano en cada dirección. Así solo habrá que comparar esa posición con la del otro bloque de hielo para ver a dónde llegará el bloque tras su movimiento. Esto puede mejorar el tiempo de ejecución para un caso dado, aunque no siempre es así. En este problema para obtener los 100 puntos no hacen falta optimizaciones de este tipo, aunque es bueno tener este tipo de ideas en mente para problemas más complejos.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559163.js">&lt;/script></description></item><item><title>Solución a "Problema"</title><link>https://blog.omegaup.com/solution/solucion-a-problema/</link><pubDate>Mon, 07 Jan 2013 16:34:20 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-problema/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Primero, dado una secuencia $ A$ denotaremos por $ s(A)$ a la suma de los elementos de A. Entonces podemos replantear el problema como: Dada una secuencia $ S$ debemos de econtrar una subsecuencia $ A$ de $ S$ tal que $ s(A) - (s(S) - s(A))$ sea la minima posible.&lt;/p>
&lt;p>Ahora, como $ s(A) - (s(S) - s(A)) = 2 \times s(A) - s(S)$, entonces tenemos que minimizar $ 2 \times s(A) - s(S)$ que es lo mismo que minimizar $ s(A) - s(S)/2$. O sea, debemos de encontrar una subsecuencia $ A$ cuya suma esté lo más cercana a la mitad de la suma de $ S$, en particular podemos restringir nuestra búsqueda a las subsecuencias cuya suma sea menor o igual a $ s(S)/2$.&lt;/p>
&lt;p>Se plantea para este problema una solución de tipo &lt;em>Programación Dinámcia&lt;/em> que corre sobre los elementos de la secuencia $ S$ y considera todas las posibles diferentes sumas de subsecuencias cuyos elementos tienen índices menores o iguales al actual y cuya suma no excede $ s(S)/2$. Se tendrán entonces $ n \times s(S)/2$ posibles estados y cada uno podrá ser procesado en tiempo constante ya que solo hay dos trancisiones posibles para cada estado: Se toma el elemento actual dentro de la subsecuencia o no. Por lo tanto la solución tendrá una complejidad temporal de $ O (n \times s(S))$.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559155.js">&lt;/script></description></item><item><title>Solución a "Alfiles"</title><link>https://blog.omegaup.com/solution/solucion-a-alfiles/</link><pubDate>Mon, 07 Jan 2013 16:23:49 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-alfiles/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Lo primero que se debe de notar es que en cada una de las $ 2n-1$ diagonales principales, las cuales mostradas en la imagen de abajo, habrá máximo 1 alfil. Lo mismo se cumple para las diagonales invertidas, mostradas también en una imagen abajo.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic1.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic2.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora, cada diagonal principal se cruza con ciertas diagonales invertidas. Entonces se plantea una solución de tipo &lt;em>Backtracking&lt;/em> que corre sobre las diagonales principales marcando diagonales invertidas a cada paso (representando que se ha colocado un alfil en el cruce de esas dos diagonales).&lt;/p>
&lt;p>Una implementación directa y sin optimizaciones ni podas para los casas donde $ n = 8$ hará uso de $ 1\times2\times3\times4\times5\times6\times7\times8\times7\times6\times5\times4\times3\times2\times1=203212800$ operaciones, lo cual no está muy lejos de ser una solución eficiente. Entonces bastan algunas podas para obtener una solución al 100%, podemos por ejemplo podar las ramas de la recursión que consideran combinaciones con una diagonal invertida repetida.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559152.js">&lt;/script></description></item><item><title>Solución a "Mario Reloaded"</title><link>https://blog.omegaup.com/solution/solucion-a-mario-reloaded/</link><pubDate>Mon, 07 Jan 2013 16:08:32 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mario-reloaded/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:paspartu@gmail.com" >Pavel Herrera Dominguez&lt;/a>)&lt;/p>
&lt;h2>Observaciones
aliases: [&amp;rsquo;/solucion-a-mario-reloaded']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-mario-reloaded">&lt;/span>
&lt;a href="#aliases-solucion-a-mario-reloaded" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Lo primero es ver como se modelan los estados del problema sin pensar en que Mario puede tomar los atajos, únicamente pensar en las llaves, claramente existen $ n\times2^m$ estados, pues no importa el orden en que se toman las llaves solo las llaves que se tienen al llegar a cada puerta. A partir de aquí nos referiremos como estado a la puerta y las llaves que trae Mario.&lt;/p>
&lt;p>La segunda observación es ver como afecta llegar a una puerta con cierto juego de llaves, osea a cada estado. Cada vez que visitamos un estado todos los estados ya visitados que tienen el mismo juego de llaves se actualiza instantáneamente. Esto se puede entender como si únicamente el juego de llaves definiera el estado, lo que nos lleva a pensar que el problema es saber que puertas pertenecen a qué juego de llaves.&lt;/p>
&lt;p>De la observación anterior podemos pensar que si mantenemos una lista de puertas ya visitadas para cada juego de llaves, cuando algún estado (puerta, juego de llaves) se visita con un menor tiempo, todas las puertas alcanzadas con ese juego de llaves deben ser actualizadas y sus respectivos vecinos.&lt;/p>
&lt;h2>Idea
aliases: [&amp;rsquo;/solucion-a-mario-reloaded']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-mario-reloaded-1">&lt;/span>
&lt;a href="#aliases-solucion-a-mario-reloaded-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>La idea es hacer una especie de búsqueda en amplitud la cual tome en cuenta las observaciones anteriores. Esto es una búsqueda que visite los estados (puerta, llave) y conserve una lista de las puertas alcanzables con cada juego de llaves.&lt;/p>
&lt;h2>Implementacion
aliases: [&amp;rsquo;/solucion-a-mario-reloaded']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-mario-reloaded-2">&lt;/span>
&lt;a href="#aliases-solucion-a-mario-reloaded-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559138.js">&lt;/script>
&lt;h2>Tarea
aliases: [&amp;rsquo;/solucion-a-mario-reloaded']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-mario-reloaded-3">&lt;/span>
&lt;a href="#aliases-solucion-a-mario-reloaded-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Pensar si es posible hacer la búsqueda sin usar los estados (puerta, juego de llaves).&lt;/p></description></item><item><title>Solución a "El collar de perlas"</title><link>https://blog.omegaup.com/solution/solucion-a-el-collar-de-perlas/</link><pubDate>Thu, 03 Jan 2013 16:01:37 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-el-collar-de-perlas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://goldendarknut.blogspot.mx/" target="_blank" rel="noopener">Félix Rafael Horta Cuadrilla&lt;/a>&lt;/p>
&lt;p>En una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.&lt;/p>
&lt;p>Para resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero &lt;em>i&lt;/em> en cualquier lista representa al enano &lt;em>i&lt;/em>.&lt;/p>
&lt;p>Durante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.&lt;/p>
&lt;p>En algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.&lt;/p>
&lt;p>&lt;strong>Problema&lt;/strong>&lt;/p>
&lt;p>Escribe un programa que ayude a los enanos verdes a obtener el diamante, sabiendo de antemano las listas de todos los enanos. Puedes asumir que los enanos rojos juegan de manera optima. Se garantiza que siempre habra una forma en la que los enanos verdes puedan ganar si juegan optimamente.&lt;/p>
&lt;p>&lt;strong>Entrada&lt;/strong>&lt;/p>
&lt;p>La primer linea contiene la longitud &lt;strong>L&lt;/strong> del collar, el numero &lt;strong>N&lt;/strong> de enanos y el numero &lt;strong>F&lt;/strong> que representa el enano que empieza con el collar.&lt;/p>
&lt;p>La segunda linea contiene &lt;strong>L&lt;/strong> caracteres (seguidos, es decir, &lt;strong>NO&lt;/strong> hay espacios entre ellos) que representan el collar, estos caracteres pueden ser una letra &lt;strong>B&lt;/strong> que significa que es una perla blanca, una letra &lt;strong>N&lt;/strong> que significa que es una perla negra o una &lt;strong>D&lt;/strong> que indica que es el diamante. Solo habra un diamante y este siempre estara al final del collar.&lt;/p>
&lt;p>Las siguientes &lt;strong>N&lt;/strong> lineas describen a los enanos y sus listas. Cada linea esta formada por un numero &lt;strong>C&lt;/strong> que representa el color del enano (0 si es verde y 1 si es rojo) seguido por la longitud &lt;strong>LN&lt;/strong> de la lista negra y de &lt;strong>LN&lt;/strong> numeros, representando cada uno de los numeros en la lista negra del enano. Finalmente, en la misma linea, el numero &lt;strong>LB&lt;/strong> que indica la longitud de la lista blanca del enano y de &lt;strong>LB&lt;/strong> numeros indicando los elementos de dicha lista.&lt;/p>
&lt;p>&lt;strong>Límites&lt;/strong>&lt;/p>
&lt;p>1 &amp;lt;= L &amp;lt;= 1000&lt;/p>
&lt;p>1 &amp;lt;= N &amp;lt;= 1000&lt;/p>
&lt;p>&lt;strong>Interacción&lt;/strong>&lt;/p>
&lt;p>Este problema es interactivo y deberas escribir una funcion llamada &lt;em>juega()&lt;/em> que lea de pantalla el problema los datos de entrada y se cominique con tres funciones en una libreria.&lt;/p>
&lt;p>Las tres funciones con las que hay que interactuar son las siguientes:&lt;/p>
&lt;p>    void pasaCollar(int enano);&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos verdes posea el collar, tu programa mande el collar al enano especificado como parametro. Llamar a &lt;em>pasaCollar&lt;/em> cuando no le corresponde o pasar el collar a un enano que no este en la lista correspondiente resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>    int recibeCollar();&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos rojos posea el collar, tu programa llame a esta funcion para saber a que enano paso el collar el evaluador. Llamar a esta funcion cuando no le corresponde el turno a un enano rojo resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>void termina();&lt;/p>
&lt;p>Debe ser llamada una vez cuando en el collar solo quede el diamante. Si se llama en otro momento o si se llama y el collar esta en posesion de un enano rojo obtendras cero puntos en ese caso. Solo recibiras puntos si llamas a la funcion &lt;em>termina()&lt;/em> cuando el collar este en posesion de un enano verde y el collar solo posea al diamante.&lt;/p>
&lt;p>&lt;strong>Ejemplo&lt;/strong>&lt;/p>
&lt;p>Entrada&lt;/p>
&lt;p>6 4 2&lt;br>
NBBNND&lt;br>
0 1 2 1 4&lt;br>
0 2 1 3 1 1&lt;br>
1 1 4 1 4&lt;br>
1 2 2 3 1 1&lt;/p>
&lt;p>Salida&lt;/p>
&lt;p>pasaCollar(1)&lt;br>
pasaCollar(4)&lt;br>
recibeCollar() -&amp;gt; 1&lt;br>
pasaCollar(2)&lt;br>
pasaCollar(1)&lt;br>
termina()&lt;/p>
&lt;p>&lt;strong>Compilación&lt;/strong>&lt;/p>
&lt;p>Se proporcionan plantillas para facilitar la codificación del problema, de esa forma sólo necesitas codificar el archivo perlas.c/perlas.cpp/perlas.pas. Las plantillas son solo para facilitar la codificación y las pruebas, &lt;strong>no se garantiza que se evaluará con las mismas&lt;/strong>.&lt;/p>
&lt;p>Utilizando la plantilla proporcionada, puedes compilar este programa correctamente en C++ de la siguiente forma:&lt;/p>
&lt;p>    g++ main.cpp perlas.cpp -o perlas&lt;/p>
&lt;p>En C, se hace de la siguiente forma:&lt;/p>
&lt;p>    g++ main.c perlas.c -o perlas&lt;/p>
&lt;p>Mientras que para Pascal:&lt;/p>
&lt;p>fpc main.pas&lt;/p>
&lt;p>De la misma forma, las opciones de compilación pueden ser diferentes en la evaluación, sin embargo, si tu programa compila con las plantillas, también debería de hacerlo en el evaluador.&lt;/p>
&lt;p>&lt;strong>Descarga las plantillas &lt;a href="https://www.dropbox.com/sh/nux63uknmdyzgej/sfqTP9Tng8/plantillas.rar" target="_blank" rel="noopener">aquí&lt;/a> .&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Solución&lt;/strong>&lt;/p>
&lt;p>Una manera sencilla de tratar de ganar en este juego, es hacer una búsqueda sobre las listas de los enanos verdes y siempre pasar el collar sobre los enanos verdes, lo cual resolvería un par de casos. Sin embargo, en la mayor parte de los casos, es necesario pasar el collar a un enano rojo que eventualmente lo regresará a un enano verde. Y este es precisamente el problema, saber cuándo pasar a un enano rojo y a qué enano rojo, y como se necesita de la interacción de los enanos rojos para llegar a la solución, un gran problema se presenta.&lt;/p>
&lt;p>Aunque este problema podría resolverse fácilmente con una búsqueda memorizada haciendo las llamadas a las funciones durante la búsqueda, no puede hacerse de esta forma porque cuando se hace una búsqueda se requiere poder ir hacia adelante y hacia atrás en el árbol de búsqueda, y como se necesita de la interacción de los enanos rojos, se tiene que lograr la solución en la primera pasada.&lt;/p>
&lt;p>Por lo tanto hay que calcular todas las posibles tiradas antes de jugar, considerando las mejores tiradas de los enanos rojos. De esta forma, una vez que se tiene  una jugada para ganar el juego para &lt;strong>cualquier estado posible&lt;/strong>, se puede jugar teniendo seguro el triunfo.&lt;/p>
&lt;p>Ahora, aunque sabemos que no se puede resolver con una búsqueda, sí podemos utilizar un árbol de búsqueda para resolver el problema, pero ¿cómo tomar en cuenta las elecciones de los enanos rojos?, la respuesta a esto es jugar para ambos equipos y usar el mismo cósigo para ello, eligendo siempre la mejor opción para &lt;strong>el color de enano&lt;/strong> en cada turno, es decir, cuando la búsqueda esté sobre un enano rojo, hay que elegir la opción que haga que los enanos rojos ganen, y cuando la búsqueda esté sobre un enano verde, hay que elegir la opción que haga ganar a los enanos verdes.&lt;/p>
&lt;p>Es evidente que cuando las hojas del árbol terminan en un enano verde, se gana el juego (esos estados son estados ganadores), y cuando termina en un enano rojo el juego se pierde (esos estados son estados perdedores), eso es fácil, lo difícil son los siguientes niveles.&lt;/p>
&lt;p>Tomando en cuenta esto necesitamos etiquetar todos los estados como estados ganadores o estados perdedores, debido a que ya sabemos qué son los estados hojas, podemos deducir qué son los estados anteriores a las hojas de la siguiente forma: Si el estado pertenece a un enano verde, nos basta con que UN y solo UN enano en su lista lleve a un estado ganador, ya que como enanos verdes podemos controlar a quien le pasamos el collar, por lo que basta con que el estado pueda llevar a un estado ganador para que también sea un estado ganador. Si el enano verde NO lleva a ningún estado ganador, entonces ese estado NO es un estado ganador, por que no importa a quien se lo pases, siempre perderás.&lt;/p>
&lt;p>Pensando de esta misma forma, si el estado pertenece a un enano rojo, necesitamos que TODOS los estados a los que conduzca sean estados ganadores, por que si hay solo un estado perdedor, los enanos rojos, que juegan con la mejor estrategia, siempre eligirán ese estado.&lt;/p>
&lt;p>De esta forma, es posible que haya enanos verdes a los que quieras evitar, y enanos rojos a los que quieras pasarle el collar.&lt;/p>
&lt;p>Entonces, para resolver el problema, hay que pasar por todos los estados y marcarlos como estados ganadores o estados perdedores con la técnica que más te guste, ya sea programación dinámica o búsqueda memorizada, pero hay que hacerlo antes de jugar. Una vez teniendo precalculado cuáles son los estados ganadores y perdedores, solo hay que hacer las llamadas de los enanos verdes siempre hacia estados ganadores.&lt;/p>
&lt;p>&lt;a href="http://elira.operamail.com/files/perlas.rar" target="_blank" rel="noopener">DESCARGAR ARCHIVOS Y SOLUCIÓN&lt;/a>&lt;/p></description></item><item><title>Solución a "Teclado Roto"</title><link>https://blog.omegaup.com/solution/solucion-a-teclado-roto/</link><pubDate>Sun, 28 Oct 2012 01:31:45 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-teclado-roto/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 2&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="#" >Jorge Alberto González Martínez&lt;/a>&lt;/p>
&lt;p>Los temas para el examen donde apareció este problema eran pilas, colas y búsqueda binaria. Después de haber estudiado los temas, es buena idea combinar la teoría aprendida.&lt;/p>
&lt;p>El problema del teclado roto describe una serie de operaciones en las que es necesaria una estructura en la que sea posible agregar elementos por ambos lados (izquierda y derecha). La descripción del problema muestra las restricciones, que no superan los 100, 000 elementos, por lo que es posible hacer un arreglo estático de caracteres de ese tamaño.&lt;/p>
&lt;p>En el caso de mi solución, para que sea más clara la inserción, también utilizo memoria auxiliar para guardar las palabras que se van a insertar en la estructura de datos.&lt;/p>
&lt;p>En el código que se muestra abajo se describe la forma en la que se implementa y opera la estructura mencionada anteriormente:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559109.js">&lt;/script></description></item><item><title>Solución a "El Artista Lento"</title><link>https://blog.omegaup.com/solution/solucion-a-el-artista-lento/</link><pubDate>Fri, 19 Oct 2012 17:09:21 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-el-artista-lento/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 2&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="#" >Christian Hernández&lt;/a>&lt;/p>
&lt;p>Lo primero de lo que debemos darnos cuenta es de que como los pedazos son de dimensiones enteras y se colocan en dimensiones enteras, podemos &amp;ldquo;pensar&amp;rdquo; el problema de manera que en lugar de pegar rectángulos de &lt;strong>Mi&lt;/strong> x &lt;strong>Ni&lt;/strong>, estamos pegando &lt;strong>Mi&lt;/strong> x &lt;strong>Ni&lt;/strong> de 1 x 1 (Ejemplo: Si tuvieramos que pegar un rectángulo de 4 x 3, podemos pensarlo como pegar 12 rectangulos de 1 x 1). Podemos pensar lo mismo de los rectángulos adhesivos.&lt;/p>
&lt;p>Si pensamos el problema sin rectángulos adhesivos, podríamos resolverlo teniendo en un arreglo matricial el color que se encuentra hasta arriba de cada rectángulo de 1 x 1 que tiene la cartulina.&lt;/p>
&lt;p>Si tomamos la misma idea pero ahora teniendo en cuenta que existen rectángulos adhesivos, nos encontramos con el problema de que si rasgamos un cuadro necesitamos recordar el color la capa de papel que se encontraba debajo de la capa &amp;ldquo;visible&amp;rdquo;, y además podemos rasgar tantas veces como capas de papel hemos puesto. Con esto tenemos que necesitamos guardar un número de valores igual al número de capas que hemos puesto. Además tenemos que tener en cuenta el orden en el que fuimos poniendo las capas; esto es la última capa que pusimos debe de recordarse primero que la primera que pusimos, o en otras palabras: El primero que entras es el último que sale, así como el el último que entra es el primero que sale. Ese comportamiento lo encontramos en la estructura de datos Pila (Si no conoces la estructura de datos, puedes consultarla &lt;a href="http://es.wikipedia.org/wiki/Pila_%28inform%c3%a1tica%29" target="_blank" rel="noopener">acá&lt;/a>).&lt;/p>
&lt;p>A continuación se encuentra la implementación de una estrúctura Pila que nos serviría para este problema:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Pila&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2002&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">short&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">posActual&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//Devuelve si la pila esta vacia
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">estaVacia&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">posActual&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//inserta un elemento en cima de la pila
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">valor&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">posActual&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">posActual&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">valor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//quita el elemento de la cima de la pila y lo devuelve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">valor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">estaVacia&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">valor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">posActual&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">posActual&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">valor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//devuelve el valor del elemento de la cima de la pila
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="nf">top&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">posActual&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Es importante notar que esta es una implementación estática de una Pila (Siempre ocupa el mismo espacio en memoria sin importar el número de elementos, además de que el número de elementos máximo ya está definido). Como se ve, se han utilizado char para guardar los valores, ya que el valor de los colores llega hasta 100, por lo que un char es más que suficiente.&lt;/p>
&lt;p>Entonces teniendo pilas para recordar todas nuestras capas de papel en orden, lo que podemos hacer es hacer un arreglo matricial de pilas para resolver nuestro problema.&lt;/p>
&lt;p>Básicamente, cada que agreguemos un rectágulo de papel a nuestra cartulina lo que tenemos que hacer es, para cada rectángulo de 1 x 1 que abarca, agregar el color a la pila en su posición en la matriz. Si se trata de un rectángulo adhesivo, hacemos justo lo contrario, sacamos un valor de la pilas correspondientes.&lt;/p>
&lt;p>Sólo nos queda resolver el problema del grosor de la cartulina. Debido a que necesitamos desgarrala G veces con un rectángulo adhesivo, podemos pensar que se tratan de G capas de papel del color de la cartulina. Entonces, se reduce a inicializar nuestro arreglo pilas agregando G capas del color de la cartulina.&lt;/p>
&lt;p>La complejidad de agregar una capa de papel a la cartulina es de &lt;strong>O(M x N)&lt;/strong> (ya que una sola capa puede abarcar toda la cartulina), la misma aplica para usar un rectángulo adhesivo. Entonces la complejidad de agregar todas las capas quedaría &lt;strong>O(M x N x K)&lt;/strong> donde &lt;strong>K&lt;/strong> es el número de rectángulos por pegar. Inicializar la cartulina tendría una complejidad &lt;strong>O(M x N x G)&lt;/strong> donde &lt;strong>G&lt;/strong> es el grosor. Dejándonos con una complejidad final de &lt;strong>O(M x N x (K + G))&lt;/strong> que es suficientemente buena como para funcionar con los límites de tiempo establecidos.&lt;/p>
&lt;p>La complejidad en memoria es igual de &lt;strong>O(M x N x (K + G))&lt;/strong>, ya que se tienen que guardar las &lt;strong>(K + G)&lt;/strong> capas de papel en la matriz de &lt;strong>M&lt;/strong> x &lt;strong>N&lt;/strong>.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559074.js">&lt;/script></description></item><item><title>Solución a "Engranes"</title><link>https://blog.omegaup.com/solution/engranes-khayyam-solucion-enrique-lira/</link><pubDate>Sat, 13 Oct 2012 04:06:46 +0000</pubDate><guid>https://blog.omegaup.com/solution/engranes-khayyam-solucion-enrique-lira/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://www.linkedin.com/pub/jesus-omar-ocegueda-gonzalez/18/b45/5b9" target="_blank" rel="noopener">Omar Ocegueda (Khayyam)&lt;/a> **Solución por: **&lt;a href="http://elira.me/" target="_blank" rel="noopener">Enrique Lira&lt;/a>&lt;/p>
&lt;p>Para poder resolver este problema hay que ver ciertas propiedades a las cuales podemos llegar fácilmente a partir de ejemplos. Una primera duda que nos surge es: ¿Vuelve al estado inicial?, si hacemos un par de ejemplos podemos ver que si, otra duda que nos surge es: ¿Cuándo vuelve al estado inicial?, y aquí comienza lo complicado. Para saber cuando vuelve a su estado inicial hay que notar ciertas cosas, una de ellas es que en cuanto el diente 1 vuelve a tocar al valle 1 hemos vuelto al estado inicial, no hay forma de que el diente 0 toque al valle 0 sin haber vuelto al estado inicial, entonces hay que buscar ese instante.&lt;/p>
&lt;p>Consideremos ra y rb como el número de vueltas que ha dado el engrane a y el engrane b respectivamente en un momento dado después de x pasos, hay que notar que si ra y rb son enteros significa que hemos vuelto al estado inicial o estamos en el estado inicial (ra igual a cero y rb igual a cero).&lt;/p>
&lt;p>Para que tanto ra y rb sean enteros, es necesario que x sea divisible tanto por N como por M y hay que encontrar el numero más pequeño distinto de cero (cero es el momento inicial) en el que esto pasa. Para nuestra fortuna esto es fácilmente calculable y es algo que nos enseñan en la escuela, se llama mínimo común múltiplo.&lt;/p>
&lt;p>$ mcm(N,M) = \frac{N * M}{MCD(N, M)}&amp;amp;s=2 $&lt;/p>
&lt;p>Ya que sabemos después de cuantos pasos se repite (llamémoslos K), debemos notar que en esos K pasos ningún par (diente, valle) se va a repetir, dado que si se repite significaría que K no es el primer momento en el que se vuelve al estado inicial.&lt;/p>
&lt;p>Sabiendo esto podemos saber cuantos dientes distintos pasan por cada valle, siendo K la cantidad de parejas (diente, valle) distintas que existen (no sé pueden generar más), se puede deducir que K / M es la cantidad de dientes distintos que pasan por cada valle, simplificando nos queda:&lt;/p>
&lt;p>$ frac {N} {MCD(N, M)} &amp;amp; s=2 $&lt;/p>
&lt;p>Ahora hay que buscar una forma de saber el primer diente que pasa por un valle x, con un poco de observación podemos saber que el numero del primer diente en tocar al valle x esta dado por el residuo de la división x sobre N ( x mod N ).&lt;/p>
&lt;p>Ya que sabemos cual es el primer diente en tocar al valle x, debemos buscar la forma de calcular los otros dientes, con algunos ejemplos podemos notar que el numero del siguiente diente es M mod N veces mayor que el actual.&lt;/p>
&lt;p>En el peor de los casos, los N dientes pasan por todos los valles, resultando nuestra solución actual con una complejidad de $ O(LN)$ y funciona bastante bien para los 80 puntos del problema.&lt;/p>
&lt;p>Para llegar a la solución de 100 puntos hay que notar que después de que un diente y se junta en un valle x, el siguiente diente en juntarse con el valle x no depende del valle sino solo del diente, es por esto que si el diente y pasa por un conjunto de valles y uno de ellos no es estable, ninguno de los otros lo será y viceversa si el diente y pasa por un valle x que es estable, todos los demás valles por los que pase serán estables. Sabiendo esto podemos guardarlo en un arreglo que nos diga por cada diente si pasa por valles estables o no, reduciendo la complejidad a $ O(N)$.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559014.js">&lt;/script></description></item><item><title>Solución a "Juego Lento"</title><link>https://blog.omegaup.com/solution/juego-lento-ethan-jimenez/</link><pubDate>Fri, 12 Oct 2012 21:43:58 +0000</pubDate><guid>https://blog.omegaup.com/solution/juego-lento-ethan-jimenez/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a>&lt;/strong>&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>&lt;br>
&lt;strong>Autor:&lt;/strong> &lt;a href="http://www.codechef.com/users/ethanjimenez" target="_blank" rel="noopener">Ethan Jimenez&lt;/a>&lt;/p>
&lt;p>Empecemos analizando el caso en que solo jugamos con un montón de fichas, dada la restricción de tomar únicamente una sola ficha el juego se vuelve predecible ya que no hay más opción que tomar una ficha de ese montón. Si el montón tiene una sola ficha el jugador con el primer turno pierde, si hay dos fichas el jugador con el primer turno gana, si hay tres fichas el jugador con el primer turno pierde, y así alternadamente, podemos entonces deducir que si hay un número impar de fichas en el montón, el jugador con el primer turno perderá, por el otro lado, si el montón tiene un número par de fichas ganará la partida.&lt;/p>
&lt;p>La pregunta clave para este problema es, ¿realmente hay diferencia entre tomar una ficha de un montón y tomar una ficha de otro montón? Aumentemos la cantidad de montones en el juego, digamos que ahora tenemos dos montones de fichas, ambos montones tienen una sola ficha, el jugador con el primer turno ganará, detente por un momento a experimentar qué sucede si aumentamos la cantidad de fichas en un montón, en el otro y en ambos montones, teniendo en mente la pregunta anterior.&lt;/p>
&lt;p>Después de probar con diferentes configuraciones de juego podemos decir que la respuesta a la pregunta es no, tomar primero una ficha de un montón no es diferente a haberla tomado de cualquier otro montón, con lo que podemos concluir que, si tenemos dos montones, el primero con &lt;em>&lt;strong>a1&lt;/strong>&lt;/em> fichas y el segundo con_&lt;strong>a2&lt;/strong>_fichas, este juego es equivalente a tener un solo montón con _&lt;strong>a1+a2&lt;/strong>_fichas, una vez establecido podemos volver a nuestro análisis inicial y calcular quién ganará.&lt;/p>
&lt;p>De manera análoga deducimos que si tenemos _&lt;strong>N&lt;/strong>_montones de fichas y elegimos _&lt;strong>K&lt;/strong>_de ellos, podemos reducir la configuración &lt;a href="http://maileswaste.com/category/causes/" target="_blank" rel="noopener">herpes transmission&lt;/a> de esta partida a un juego con solo un montón de _&lt;strong>k1+k2+&amp;hellip;+kN&lt;/strong>_fichas, donde kies el número de fichas en el montón elegido &lt;em>&lt;strong>i&lt;/strong>&lt;/em>. Una vez que sabemos lo anterior debemos darnos cuenta que para ganar tenemos que elegir &lt;em>&lt;strong>K&lt;/strong>&lt;/em> de los N montones cuya suma total sea un número impar.&lt;/p>
&lt;p>Para asegurarnos que un conjunto de montones tiene un número impar de fichas debemos considerar lo siguiente, un número impar más un par da un número impar, un número impar sumado a un impar da un número par y un número par más un par da otro número par. Dado lo anterior podemos definir una regla para tener una suma total impar, debe existir una cantidad impar de montones con un número de fichas impar, si le agregamos cualquier cantidad montones con número de fichas par no se modifica la condición de tener un total impar.&lt;/p>
&lt;p>En conclusión, es posible ganar el juego cuando existe más de un montón con número impar de fichas, si hay una cantidad impar de montones impares ya se cumple la condición deseada, pero si hay una cantidad par de montones impares debemos quitar uno para cumplirla, para obtener el juego con la mayor cantidad de fichas el montón que quitemos debe ser el que tenga menos fichas, nota que, como mencioné antes, agregar montones pares no afecta la condición de victoria, por lo que para aumentar la cantidad de fichas en el juego se deben agregar todos ellos.&lt;/p></description></item></channel></rss>