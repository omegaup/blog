<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Ethan Jiménez</title><link>https://blog.omegaup.com/tags/ethan-jim%C3%A9nez/</link><description>Recent content in Ethan Jiménez on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es-MX</language><lastBuildDate>Mon, 14 Jan 2013 16:27:54 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/ethan-jim%C3%A9nez/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Cueva"</title><link>https://blog.omegaup.com/posts/solucion-a-cueva/</link><pubDate>Mon, 14 Jan 2013 16:27:54 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-cueva/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P4" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>Después de comprender el problema podemos deducir dos cosas:&lt;/p>
&lt;ul>
&lt;li>Los &lt;strong>N&lt;/strong> puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán &lt;strong>N-1&lt;/strong> aristas y siempre hay un camino entre cualquier par de nodos.&lt;/li>
&lt;li>Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las &lt;strong>Q&lt;/strong> preguntas, ¿el nodo A es un ancestro del nodo &lt;strong>B&lt;/strong>?”, de modo que necesitamos encontrar una manera óptima de saberlo.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Subtarea 1&lt;/strong>&lt;/em>. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si &lt;strong>A&lt;/strong> es ancestro de &lt;strong>B&lt;/strong>, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo &lt;strong>A&lt;/strong> encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo &lt;strong>B&lt;/strong>, si existe un camino del nodo &lt;strong>A&lt;/strong> al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo &lt;strong>A&lt;/strong> es el mismo nodo &lt;strong>B&lt;/strong>, en ambos casos la respuesta es 0.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NQ)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>&lt;em>Subtarea 2.&lt;/em>&lt;/strong> Es notable que esta vez el número de preguntas es mucho mayor, por ello la solución anterior tardaría demasiado. Cambiemos nuestra estrategia, esta vez realicemos una búsqueda en profundidad desde el nodo 1 hasta los demás &lt;strong>N&lt;/strong> nodos, llevando una lista &lt;strong>L&lt;/strong> de los nodos que forman parte del camino desde el nodo 1 hasta el nodo &lt;strong>K&lt;/strong>, incluyendo los nodos 1 y &lt;strong>K&lt;/strong>, esto puede lograrse mediante recursividad.&lt;/p>
&lt;p>La tabla &lt;strong>ancestro[K][M]&lt;/strong> nos permitirá saber si el nodo &lt;strong>M&lt;/strong> es un ancestro del nodo &lt;strong>K&lt;/strong>, dándonos cuenta que todos los ancestros de &lt;strong>K&lt;/strong> se encuentran en la lista &lt;strong>L&lt;/strong> cuando la búsqueda en profundidad llega al nodo &lt;strong>K&lt;/strong>, podemos llenar la tabla &lt;strong>ancestro[K][M]&lt;/strong> durante la búsqueda en profundidad. Con la tabla anterior es fácil responder las preguntas, pues la respuesta depende de &lt;strong>ancestro[B][A]&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N2+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 3&lt;/strong>&lt;/em>. Para obtener los puntos de esta subtarea podemos utilizar cualquier algoritmo para resolver el clásico problema del ancestro común de dos nodos en un árbol, puesto que la respuesta es 1 si el ancestro común entre los nodos &lt;strong>A&lt;/strong> y &lt;strong>B&lt;/strong> es el nodo &lt;strong>A&lt;/strong>. Este problema ya ha sido estudiado ampliamente y tiene diversas formas de ser resuelto con complejidad &lt;strong>O(NlogN)&lt;/strong>, en el foro de tutoriales de TopCoder podemos encontrar un buen artículo con algunos de los algoritmos que pueden ser utilizados:&lt;/p>
&lt;p>&lt;a href="http://community.topcoder.com/tc?module=Static&amp;amp;d1=tutorials&amp;amp;d2=lowestCommonAncestor" target="_blank" rel="noopener">TopCoder Lowest Common Ancestor&lt;/a>&lt;/p>
&lt;p>El algoritmo que utiliza programación dinámica es el más recomendado, puesto que se puede responder a las &lt;strong>Q&lt;/strong> preguntas en un tiempo constante.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NlogN+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 4&lt;/strong>&lt;/em>. Para empezar, notemos que la solución anterior no funciona para este conjunto de puntos porque utiliza demasiada memoria, el simple hecho de almacenar los nodos y las aristas ocupa bastante espacio en memoria (aproximadamente 100Mb) y una solución para la subtarea 3 requeriría al menos 50Mb más, por lo tanto no es posible completar la subtarea 4 con una solución como la anterior, para obtener los 100 puntos en este problema necesitamos una idea mucho más creativa.&lt;/p>
&lt;p>Renombremos todos los nodos del árbol enumerandolos del 1 al &lt;strong>N&lt;/strong> siguiendo el orden establecido por el recorrido en postorden del árbol comenzando por el nodo 1, después, para cada nodo, con su respectivo número &lt;strong>Y&lt;/strong>, hay que obtener el menor número presente en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>, denotemos este número menor como &lt;strong>X&lt;/strong>, con los números &lt;strong>X&lt;/strong> y &lt;strong>Y&lt;/strong> definimos entonces un intervalo cerrado &lt;strong>[X,Y]&lt;/strong> que nos representa que en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong> se contienen todos los nodos cuyo número se encuentra en el intervalo &lt;strong>[X,Y]&lt;/strong>. Podemos interpretar esta información de una manera más conveniente, un nodo con número &lt;strong>Y&lt;/strong> es ancestro de un nodo con número &lt;strong>K&lt;/strong> si &lt;strong>X ≤ K ≤ Y&lt;/strong>, lo cual nos permitirá responder las preguntas planteadas.&lt;/p>
&lt;p>Es recomendable que el olímpico experimente y se convenza que la propiedad del intervalo &lt;strong>[X,Y]&lt;/strong> es siempre correcta debido a que el recorrido en postorden establecerá que el nodo con el número &lt;strong>X&lt;/strong>, que establece la cota inferior del intervalo, siempre será una hoja del subárbol y el nodo con valor &lt;strong>Y&lt;/strong>, que establece la cota superior del intervalo, siempre será la raíz del subárbol, cualquier otro valor fuera del intervalo estará excluido del subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N+Q)&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>Solución a "Chilly Rapero"</title><link>https://blog.omegaup.com/posts/solucion-a-chilly-rapero/</link><pubDate>Sat, 12 Jan 2013 19:41:11 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-chilly-rapero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>La clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.&lt;/p>
&lt;p>Crear las aristas entre los nodos tiene una complejidad de O(LN2) y la manera más simple de almacenar dichas aristas es mediante una matriz de adyacencia. Ya que tenemos el grafo planteado, buscaremos la manera más rápida de cambiar de palabra entre cualquier par de palabras, esto puede conseguirse usando el algoritmo de &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Floyd-Warshall" target="_blank" rel="noopener">Floyd-Warshall&lt;/a> con una complejidad de O(N3) que es suficiente para el problema.&lt;/p>
&lt;p>Finalmente, para obtener la respuesta sumamos el mínimo número de cambios requeridos entre todos los pares de palabras consecutivas en el rap, este número de cambios fue obtenido mediante el algoritmo de Floyd-Warshall. El número total de cambios lo multiplicamos por 0.2 y será la respuesta para el problema.&lt;/p>
&lt;p>Complejidad de la solución: O(LN2+N3)&lt;/p></description></item><item><title>Solución a "Juego Lento"</title><link>https://blog.omegaup.com/posts/juego-lento-ethan-jimenez/</link><pubDate>Fri, 12 Oct 2012 21:43:58 +0000</pubDate><guid>https://blog.omegaup.com/posts/juego-lento-ethan-jimenez/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a>&lt;/strong>&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>&lt;br>
&lt;strong>Autor:&lt;/strong> &lt;a href="http://www.codechef.com/users/ethanjimenez" target="_blank" rel="noopener">Ethan Jimenez&lt;/a>&lt;/p>
&lt;p>Empecemos analizando el caso en que solo jugamos con un montón de fichas, dada la restricción de tomar únicamente una sola ficha el juego se vuelve predecible ya que no hay más opción que tomar una ficha de ese montón. Si el montón tiene una sola ficha el jugador con el primer turno pierde, si hay dos fichas el jugador con el primer turno gana, si hay tres fichas el jugador con el primer turno pierde, y así alternadamente, podemos entonces deducir que si hay un número impar de fichas en el montón, el jugador con el primer turno perderá, por el otro lado, si el montón tiene un número par de fichas ganará la partida.&lt;/p>
&lt;p>La pregunta clave para este problema es, ¿realmente hay diferencia entre tomar una ficha de un montón y tomar una ficha de otro montón? Aumentemos la cantidad de montones en el juego, digamos que ahora tenemos dos montones de fichas, ambos montones tienen una sola ficha, el jugador con el primer turno ganará, detente por un momento a experimentar qué sucede si aumentamos la cantidad de fichas en un montón, en el otro y en ambos montones, teniendo en mente la pregunta anterior.&lt;/p>
&lt;p>Después de probar con diferentes configuraciones de juego podemos decir que la respuesta a la pregunta es no, tomar primero una ficha de un montón no es diferente a haberla tomado de cualquier otro montón, con lo que podemos concluir que, si tenemos dos montones, el primero con &lt;em>&lt;strong>a1&lt;/strong>&lt;/em> fichas y el segundo con_&lt;strong>a2&lt;/strong>_fichas, este juego es equivalente a tener un solo montón con _&lt;strong>a1+a2&lt;/strong>_fichas, una vez establecido podemos volver a nuestro análisis inicial y calcular quién ganará.&lt;/p>
&lt;p>De manera análoga deducimos que si tenemos _&lt;strong>N&lt;/strong>_montones de fichas y elegimos _&lt;strong>K&lt;/strong>_de ellos, podemos reducir la configuración &lt;a href="http://maileswaste.com/category/causes/" target="_blank" rel="noopener">herpes transmission&lt;/a> de esta partida a un juego con solo un montón de _&lt;strong>k1+k2+&amp;hellip;+kN&lt;/strong>_fichas, donde kies el número de fichas en el montón elegido &lt;em>&lt;strong>i&lt;/strong>&lt;/em>. Una vez que sabemos lo anterior debemos darnos cuenta que para ganar tenemos que elegir &lt;em>&lt;strong>K&lt;/strong>&lt;/em> de los N montones cuya suma total sea un número impar.&lt;/p>
&lt;p>Para asegurarnos que un conjunto de montones tiene un número impar de fichas debemos considerar lo siguiente, un número impar más un par da un número impar, un número impar sumado a un impar da un número par y un número par más un par da otro número par. Dado lo anterior podemos definir una regla para tener una suma total impar, debe existir una cantidad impar de montones con un número de fichas impar, si le agregamos cualquier cantidad montones con número de fichas par no se modifica la condición de tener un total impar.&lt;/p>
&lt;p>En conclusión, es posible ganar el juego cuando existe más de un montón con número impar de fichas, si hay una cantidad impar de montones impares ya se cumple la condición deseada, pero si hay una cantidad par de montones impares debemos quitar uno para cumplirla, para obtener el juego con la mayor cantidad de fichas el montón que quitemos debe ser el que tenga menos fichas, nota que, como mencioné antes, agregar montones pares no afecta la condición de victoria, por lo que para aumentar la cantidad de fichas en el juego se deben agregar todos ellos.&lt;/p></description></item></channel></rss>