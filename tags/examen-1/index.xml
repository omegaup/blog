<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 1</title><link>https://blog.omegaup.com/tags/examen-1/</link><description>Recent content in Examen 1 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Fri, 25 Jul 2014 04:28:19 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-1/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Carretera"</title><link>https://blog.omegaup.com/solution/solucion-a-carretera/</link><pubDate>Fri, 25 Jul 2014 04:28:19 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-carretera/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1E1/#problems/carretera" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Examen 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Para obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.&lt;/p>
&lt;p>Este código obtiene los primeros 30 puntos:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/94cddcf809bc5a583540.js">&lt;/script>
&lt;p>Para el resto de los puntos: Sea $ f(t)$ el ancho necesario para la fotografía en el segundo $ t$. La observación crucial es que $ f$ es una función unimodal: es decir, existe un punto $ t_0$ tal que $ f$ es decreciente a la izquierda de $ t_0$ y es creciente a la derecha.&lt;/p>
&lt;p>Computar $ f(t)$ para $ t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $ t$, lo cual toma tiempo $ O(N)$. Como $ f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $ O(\lg T)$, donde $ T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $ O(N \lg T)$, suficiente para obtener todos los puntos del problema.&lt;/p>
&lt;p>El siguiente código implementa la solución anterior con búsqueda binaria.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/eee062837acde7bcd8ea.js">&lt;/script></description></item><item><title>Solución a "La Venganza de Silvio"</title><link>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</link><pubDate>Thu, 08 Aug 2013 02:02:51 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/VenganzaDeSilvio" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Freddy&lt;/p>
&lt;p>Este problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.&lt;/p>
&lt;h2>Subtarea 1
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para obtener el primer grupo de puntos, sólo basta calcular $ N^M$ multiplicando a $ N$ por sí mismo $ M$ veces, teniendo cuidado de que no haya overflow.&lt;/p>
&lt;h2>Subtarea 2
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-1">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar &lt;a href="http://es.wikipedia.org/wiki/Exponenciaci%c3%b3n_binaria" target="_blank" rel="noopener">exponenciación binaria&lt;/a>.&lt;/p>
&lt;p>Sabemos que $ x^0 = 1$, que $ (x^n)^2 = x^{2n}$, y que $ x * x^{n-1} = x^n$ para toda $ x$ y $ n$, por lo que podemos escribir la siguiente relación:&lt;/p>
&lt;p>$ \text{potencia}(N,M) = \begin{cases} 1 &amp;amp; \text{si } M = 0 \\ (potencia(N,M/2))^2 &amp;amp; \text{si } M \text{ es par} \\ N * (potencia(N,(M-1)/2))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>Aplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $ O(log M)$, ya que en cada paso $ M$ se reduce a la mitad.&lt;/p>
&lt;h2>Subtarea 3
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-2">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $ M$. Para ello requerimos una observación adicional. Dividir entre $ 2$ en base $ 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.&lt;/p>
&lt;p>Podemos aprovechar esta observación guardando $ M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $ A$ es el arreglo donde guardamos los bits de $ M$, está $ 0$-indexado, tiene $ k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $ potencia2(N,k-1)$, donde $ potencia2$ es:&lt;/p>
&lt;p>$ \text{potencia2}(N,i) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \\ (potencia2(N,i-1))^2 &amp;amp; \text{si } A[i] = 0 \\ N * (potencia2(N,i-1))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;h2>Subtarea 4
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-3">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.&lt;/p>
&lt;p>Por conveniencia, definamos $ f(i)$ como el número que se obtiene tomando los elementos $ [0..i]$ del arreglo $ A$, y $ f(-1) = 0$. Recordando que multiplicar por $ 2$ en base $ 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $ f(i) = 2f(i-1) + A[i]$.&lt;/p>
&lt;p>Ahora, es simple notar que $ potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $ potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.&lt;/p>
&lt;p>Por lo tanto, podemos escribir un ciclo en vez de utilizar recursión.&lt;/p>
&lt;p>Este algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.&lt;/p>
&lt;p>Aquí está la implementación del algoritmo anterior:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559240.js">&lt;/script>
&lt;h2>Consideraciones
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-4">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Hay que tener cuidado de que no haya overflow. Cuando un entero de $ k$ bits se eleva al cuadrado, puede ahora tener a lo más $ 2k$ bits. Como $ m$ puede tener hasta $ 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.&lt;/p>
&lt;p>También, varios competidores no consideraron el caso en el que se pide calcular $ N^0 \pmod 1$.&lt;/p></description></item><item><title>Solución a Las Cartas del Dr. Lira</title><link>https://blog.omegaup.com/solution/solucion-a-las-cartas-del-dr-lira/</link><pubDate>Mon, 29 Jul 2013 15:26:08 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-las-cartas-del-dr-lira/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/CartasDrLira" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.linkedin.com/in/joemmanuel/" target="_blank" rel="noopener">Joemmanuel Ponce Galindo&lt;/a> &lt;strong>Fuente&lt;/strong>: Topcoder&lt;/p>
&lt;p>Básicamente lo que nos pide el problema es encontrar el número de cartas que son distintas entre la configuración que es dada como entrada y una configuración donde las cartas estén alternadas.&lt;/p>
&lt;p>Cómo se explica en el problema, sólo hay 2 estados posibles en los que una carta puede estar: negro (B) y blanco (W). En otras palabras, la observación clave para resolver el problema es darse cuenta que sólo existen 2 configuraciones que cumplen con las reglas que necesita Dr. Lira: Una configuración donde la primer carta es W, la siguiente B, la siguiente W y así sucesivamente. La otra configuración posible es donde las cartas empiezan con B, forzando la siguiente carta a ser W y esta a su vez forzando la siguiente carta a ser B.&lt;/p>
&lt;p>Contar el número de caracteres diferentes entre una cadena y otra sólo requiere de un ciclo, por lo que la complejidad es lineal con respecto al tamaño de la cadena. Lo único que tenemos que hacer es entonces comparar la cadena dada como entrada con las configuraciones BWBW.. y WBWB&amp;hellip;, contar el número de diferencias y dar como salida el mínimo de estos números.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559228.js">&lt;/script></description></item><item><title>Solución a "Engranes"</title><link>https://blog.omegaup.com/solution/engranes-khayyam-solucion-enrique-lira/</link><pubDate>Sat, 13 Oct 2012 04:06:46 +0000</pubDate><guid>https://blog.omegaup.com/solution/engranes-khayyam-solucion-enrique-lira/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://www.linkedin.com/pub/jesus-omar-ocegueda-gonzalez/18/b45/5b9" target="_blank" rel="noopener">Omar Ocegueda (Khayyam)&lt;/a> **Solución por: **&lt;a href="http://elira.me/" target="_blank" rel="noopener">Enrique Lira&lt;/a>&lt;/p>
&lt;p>Para poder resolver este problema hay que ver ciertas propiedades a las cuales podemos llegar fácilmente a partir de ejemplos. Una primera duda que nos surge es: ¿Vuelve al estado inicial?, si hacemos un par de ejemplos podemos ver que si, otra duda que nos surge es: ¿Cuándo vuelve al estado inicial?, y aquí comienza lo complicado. Para saber cuando vuelve a su estado inicial hay que notar ciertas cosas, una de ellas es que en cuanto el diente 1 vuelve a tocar al valle 1 hemos vuelto al estado inicial, no hay forma de que el diente 0 toque al valle 0 sin haber vuelto al estado inicial, entonces hay que buscar ese instante.&lt;/p>
&lt;p>Consideremos ra y rb como el número de vueltas que ha dado el engrane a y el engrane b respectivamente en un momento dado después de x pasos, hay que notar que si ra y rb son enteros significa que hemos vuelto al estado inicial o estamos en el estado inicial (ra igual a cero y rb igual a cero).&lt;/p>
&lt;p>Para que tanto ra y rb sean enteros, es necesario que x sea divisible tanto por N como por M y hay que encontrar el numero más pequeño distinto de cero (cero es el momento inicial) en el que esto pasa. Para nuestra fortuna esto es fácilmente calculable y es algo que nos enseñan en la escuela, se llama mínimo común múltiplo.&lt;/p>
&lt;p>$ mcm(N,M) = \frac{N * M}{MCD(N, M)}&amp;amp;s=2 $&lt;/p>
&lt;p>Ya que sabemos después de cuantos pasos se repite (llamémoslos K), debemos notar que en esos K pasos ningún par (diente, valle) se va a repetir, dado que si se repite significaría que K no es el primer momento en el que se vuelve al estado inicial.&lt;/p>
&lt;p>Sabiendo esto podemos saber cuantos dientes distintos pasan por cada valle, siendo K la cantidad de parejas (diente, valle) distintas que existen (no sé pueden generar más), se puede deducir que K / M es la cantidad de dientes distintos que pasan por cada valle, simplificando nos queda:&lt;/p>
&lt;p>$ frac {N} {MCD(N, M)} &amp;amp; s=2 $&lt;/p>
&lt;p>Ahora hay que buscar una forma de saber el primer diente que pasa por un valle x, con un poco de observación podemos saber que el numero del primer diente en tocar al valle x esta dado por el residuo de la división x sobre N ( x mod N ).&lt;/p>
&lt;p>Ya que sabemos cual es el primer diente en tocar al valle x, debemos buscar la forma de calcular los otros dientes, con algunos ejemplos podemos notar que el numero del siguiente diente es M mod N veces mayor que el actual.&lt;/p>
&lt;p>En el peor de los casos, los N dientes pasan por todos los valles, resultando nuestra solución actual con una complejidad de $ O(LN)$ y funciona bastante bien para los 80 puntos del problema.&lt;/p>
&lt;p>Para llegar a la solución de 100 puntos hay que notar que después de que un diente y se junta en un valle x, el siguiente diente en juntarse con el valle x no depende del valle sino solo del diente, es por esto que si el diente y pasa por un conjunto de valles y uno de ellos no es estable, ninguno de los otros lo será y viceversa si el diente y pasa por un valle x que es estable, todos los demás valles por los que pase serán estables. Sabiendo esto podemos guardarlo en un arreglo que nos diga por cada diente si pasa por valles estables o no, reduciendo la complejidad a $ O(N)$.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559014.js">&lt;/script></description></item><item><title>Solución a "Juego Lento"</title><link>https://blog.omegaup.com/solution/juego-lento-ethan-jimenez/</link><pubDate>Fri, 12 Oct 2012 21:43:58 +0000</pubDate><guid>https://blog.omegaup.com/solution/juego-lento-ethan-jimenez/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a>&lt;/strong>&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>&lt;br>
&lt;strong>Autor:&lt;/strong> &lt;a href="http://www.codechef.com/users/ethanjimenez" target="_blank" rel="noopener">Ethan Jimenez&lt;/a>&lt;/p>
&lt;p>Empecemos analizando el caso en que solo jugamos con un montón de fichas, dada la restricción de tomar únicamente una sola ficha el juego se vuelve predecible ya que no hay más opción que tomar una ficha de ese montón. Si el montón tiene una sola ficha el jugador con el primer turno pierde, si hay dos fichas el jugador con el primer turno gana, si hay tres fichas el jugador con el primer turno pierde, y así alternadamente, podemos entonces deducir que si hay un número impar de fichas en el montón, el jugador con el primer turno perderá, por el otro lado, si el montón tiene un número par de fichas ganará la partida.&lt;/p>
&lt;p>La pregunta clave para este problema es, ¿realmente hay diferencia entre tomar una ficha de un montón y tomar una ficha de otro montón? Aumentemos la cantidad de montones en el juego, digamos que ahora tenemos dos montones de fichas, ambos montones tienen una sola ficha, el jugador con el primer turno ganará, detente por un momento a experimentar qué sucede si aumentamos la cantidad de fichas en un montón, en el otro y en ambos montones, teniendo en mente la pregunta anterior.&lt;/p>
&lt;p>Después de probar con diferentes configuraciones de juego podemos decir que la respuesta a la pregunta es no, tomar primero una ficha de un montón no es diferente a haberla tomado de cualquier otro montón, con lo que podemos concluir que, si tenemos dos montones, el primero con &lt;em>&lt;strong>a1&lt;/strong>&lt;/em> fichas y el segundo con_&lt;strong>a2&lt;/strong>_fichas, este juego es equivalente a tener un solo montón con _&lt;strong>a1+a2&lt;/strong>_fichas, una vez establecido podemos volver a nuestro análisis inicial y calcular quién ganará.&lt;/p>
&lt;p>De manera análoga deducimos que si tenemos _&lt;strong>N&lt;/strong>_montones de fichas y elegimos _&lt;strong>K&lt;/strong>_de ellos, podemos reducir la configuración &lt;a href="http://maileswaste.com/category/causes/" target="_blank" rel="noopener">herpes transmission&lt;/a> de esta partida a un juego con solo un montón de _&lt;strong>k1+k2+&amp;hellip;+kN&lt;/strong>_fichas, donde kies el número de fichas en el montón elegido &lt;em>&lt;strong>i&lt;/strong>&lt;/em>. Una vez que sabemos lo anterior debemos darnos cuenta que para ganar tenemos que elegir &lt;em>&lt;strong>K&lt;/strong>&lt;/em> de los N montones cuya suma total sea un número impar.&lt;/p>
&lt;p>Para asegurarnos que un conjunto de montones tiene un número impar de fichas debemos considerar lo siguiente, un número impar más un par da un número impar, un número impar sumado a un impar da un número par y un número par más un par da otro número par. Dado lo anterior podemos definir una regla para tener una suma total impar, debe existir una cantidad impar de montones con un número de fichas impar, si le agregamos cualquier cantidad montones con número de fichas par no se modifica la condición de tener un total impar.&lt;/p>
&lt;p>En conclusión, es posible ganar el juego cuando existe más de un montón con número impar de fichas, si hay una cantidad impar de montones impares ya se cumple la condición deseada, pero si hay una cantidad par de montones impares debemos quitar uno para cumplirla, para obtener el juego con la mayor cantidad de fichas el montón que quitemos debe ser el que tenga menos fichas, nota que, como mencioné antes, agregar montones pares no afecta la condición de victoria, por lo que para aumentar la cantidad de fichas en el juego se deben agregar todos ellos.&lt;/p></description></item></channel></rss>