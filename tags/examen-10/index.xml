<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 10</title><link>https://blog.omegaup.com/tags/examen-10/</link><description>Recent content in Examen 10 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Mon, 07 Jan 2013 16:58:46 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-10/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Pulseras"</title><link>https://blog.omegaup.com/posts/162/</link><pubDate>Mon, 07 Jan 2013 16:58:46 +0000</pubDate><guid>https://blog.omegaup.com/posts/162/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Considero este problema como un buen ejemplo para quienes desean comenzar a trabajar con problemas de programación dinámica. Se nos pide calcular la cantidad de pulseras diferentes que se pueden construir bajo ciertas condiciones. Podemos comenzar preguntándonos, ¿qué sucede si la primera cuenta es negra? La siguiente podrá ser sólo blanca. Y si comenzamos con una blanca, la siguiente puede ser negra o blanca. Podemos entonces en una matriz de 2xn colocar en cada columna cuántas secuencias distintas hay que en la posición i-ésima terminen en negro y cuántas en blanco de tal modo que no haya dos cuentas negras consecutivas. Simplemente, para obtener los números de la siguiente posición, observamos que el número de las que terminan en blanco es la suma de ambos números de la posición anterior y de las que terminan en negro es el número de secuencias que terminan en blanco de la posición anterior.&lt;/p>
&lt;p>Resta solo un detalle más a considerar. Requerimos que la secuencia no inicie y termine en negro, pues los extremos quedarán adyacentes al cerrar la pulsera. Una forma de resolver esto es la siguiente: Contamos, con el método descrito, cuántas secuencias distintas hay que inicien con blanco y que no tengan dos cuentas negras consecutivas. El número que nos pide el problema será entonces la cantidad de pulseras que empiezan con blanco y cumplen con que no haya dos negras consecutivas (independientemente de con qué color terminen) más el número de pulseras que inicien con negro y terminen con blanco (y claro, cumplan con que no haya dos negras consecutivas). ¿Cuántas hay de estas últimas? La misma cantidad que de pulseras que inician con blanco y terminan con negro, pues su simétrica inicia con negro, termina con blanco y claramente sigue cumpliendo el que no posea dos cuentas negras consecutivas. Así que es posible resolver el problema con un código muy breve, como se muestra abajo.&lt;/p>
&lt;p>Solo resta mencionar que hay que tener cuidado de aplicar el módulo correctamente. Se pueden evitar errores definiendo el valor del mismo para no tener que escribir el número varias veces.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559167.js">&lt;/script></description></item><item><title>Solución a "Problema"</title><link>https://blog.omegaup.com/posts/solucion-a-problema/</link><pubDate>Mon, 07 Jan 2013 16:34:20 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-problema/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Primero, dado una secuencia $latex A$ denotaremos por $latex s(A)$ a la suma de los elementos de A. Entonces podemos replantear el problema como: Dada una secuencia $latex S$ debemos de econtrar una subsecuencia $latex A$ de $latex S$ tal que $latex s(A) - (s(S) - s(A))$ sea la minima posible.&lt;/p>
&lt;p>Ahora, como $latex s(A) - (s(S) - s(A)) = 2 \times s(A) - s(S)$, entonces tenemos que minimizar $latex 2 \times s(A) - s(S)$ que es lo mismo que minimizar $latex s(A) - s(S)/2$. O sea, debemos de encontrar una subsecuencia $latex A$ cuya suma esté lo más cercana a la mitad de la suma de $latex S$, en particular podemos restringir nuestra búsqueda a las subsecuencias cuya suma sea menor o igual a $latex s(S)/2$.&lt;/p>
&lt;p>Se plantea para este problema una solución de tipo &lt;em>Programación Dinámcia&lt;/em> que corre sobre los elementos de la secuencia $latex S$ y considera todas las posibles diferentes sumas de subsecuencias cuyos elementos tienen índices menores o iguales al actual y cuya suma no excede $latex s(S)/2$. Se tendrán entonces $latex n \times s(S)/2$ posibles estados y cada uno podrá ser procesado en tiempo constante ya que solo hay dos trancisiones posibles para cada estado: Se toma el elemento actual dentro de la subsecuencia o no. Por lo tanto la solución tendrá una complejidad temporal de $latex O (n \times s(S))$.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559155.js">&lt;/script></description></item><item><title>Solución a "El collar de perlas"</title><link>https://blog.omegaup.com/posts/solucion-a-el-collar-de-perlas/</link><pubDate>Thu, 03 Jan 2013 16:01:37 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-el-collar-de-perlas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://goldendarknut.blogspot.mx/" target="_blank" rel="noopener">Félix Rafael Horta Cuadrilla&lt;/a>&lt;/p>
&lt;p>En una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.&lt;/p>
&lt;p>Para resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero &lt;em>i&lt;/em> en cualquier lista representa al enano &lt;em>i&lt;/em>.&lt;/p>
&lt;p>Durante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.&lt;/p>
&lt;p>En algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.&lt;/p>
&lt;p>&lt;strong>Problema&lt;/strong>&lt;/p>
&lt;p>Escribe un programa que ayude a los enanos verdes a obtener el diamante, sabiendo de antemano las listas de todos los enanos. Puedes asumir que los enanos rojos juegan de manera optima. Se garantiza que siempre habra una forma en la que los enanos verdes puedan ganar si juegan optimamente.&lt;/p>
&lt;p>&lt;strong>Entrada&lt;/strong>&lt;/p>
&lt;p>La primer linea contiene la longitud &lt;strong>L&lt;/strong> del collar, el numero &lt;strong>N&lt;/strong> de enanos y el numero &lt;strong>F&lt;/strong> que representa el enano que empieza con el collar.&lt;/p>
&lt;p>La segunda linea contiene &lt;strong>L&lt;/strong> caracteres (seguidos, es decir, &lt;strong>NO&lt;/strong> hay espacios entre ellos) que representan el collar, estos caracteres pueden ser una letra &lt;strong>B&lt;/strong> que significa que es una perla blanca, una letra &lt;strong>N&lt;/strong> que significa que es una perla negra o una &lt;strong>D&lt;/strong> que indica que es el diamante. Solo habra un diamante y este siempre estara al final del collar.&lt;/p>
&lt;p>Las siguientes &lt;strong>N&lt;/strong> lineas describen a los enanos y sus listas. Cada linea esta formada por un numero &lt;strong>C&lt;/strong> que representa el color del enano (0 si es verde y 1 si es rojo) seguido por la longitud &lt;strong>LN&lt;/strong> de la lista negra y de &lt;strong>LN&lt;/strong> numeros, representando cada uno de los numeros en la lista negra del enano. Finalmente, en la misma linea, el numero &lt;strong>LB&lt;/strong> que indica la longitud de la lista blanca del enano y de &lt;strong>LB&lt;/strong> numeros indicando los elementos de dicha lista.&lt;/p>
&lt;p>&lt;strong>Límites&lt;/strong>&lt;/p>
&lt;p>1 &amp;lt;= L &amp;lt;= 1000&lt;/p>
&lt;p>1 &amp;lt;= N &amp;lt;= 1000&lt;/p>
&lt;p>&lt;strong>Interacción&lt;/strong>&lt;/p>
&lt;p>Este problema es interactivo y deberas escribir una funcion llamada &lt;em>juega()&lt;/em> que lea de pantalla el problema los datos de entrada y se cominique con tres funciones en una libreria.&lt;/p>
&lt;p>Las tres funciones con las que hay que interactuar son las siguientes:&lt;/p>
&lt;p>    void pasaCollar(int enano);&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos verdes posea el collar, tu programa mande el collar al enano especificado como parametro. Llamar a &lt;em>pasaCollar&lt;/em> cuando no le corresponde o pasar el collar a un enano que no este en la lista correspondiente resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>    int recibeCollar();&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos rojos posea el collar, tu programa llame a esta funcion para saber a que enano paso el collar el evaluador. Llamar a esta funcion cuando no le corresponde el turno a un enano rojo resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>void termina();&lt;/p>
&lt;p>Debe ser llamada una vez cuando en el collar solo quede el diamante. Si se llama en otro momento o si se llama y el collar esta en posesion de un enano rojo obtendras cero puntos en ese caso. Solo recibiras puntos si llamas a la funcion &lt;em>termina()&lt;/em> cuando el collar este en posesion de un enano verde y el collar solo posea al diamante.&lt;/p>
&lt;p>&lt;strong>Ejemplo&lt;/strong>&lt;/p>
&lt;p>Entrada&lt;/p>
&lt;p>6 4 2&lt;br>
NBBNND&lt;br>
0 1 2 1 4&lt;br>
0 2 1 3 1 1&lt;br>
1 1 4 1 4&lt;br>
1 2 2 3 1 1&lt;/p>
&lt;p>Salida&lt;/p>
&lt;p>pasaCollar(1)&lt;br>
pasaCollar(4)&lt;br>
recibeCollar() -&amp;gt; 1&lt;br>
pasaCollar(2)&lt;br>
pasaCollar(1)&lt;br>
termina()&lt;/p>
&lt;p>&lt;strong>Compilación&lt;/strong>&lt;/p>
&lt;p>Se proporcionan plantillas para facilitar la codificación del problema, de esa forma sólo necesitas codificar el archivo perlas.c/perlas.cpp/perlas.pas. Las plantillas son solo para facilitar la codificación y las pruebas, &lt;strong>no se garantiza que se evaluará con las mismas&lt;/strong>.&lt;/p>
&lt;p>Utilizando la plantilla proporcionada, puedes compilar este programa correctamente en C++ de la siguiente forma:&lt;/p>
&lt;p>    g++ main.cpp perlas.cpp -o perlas&lt;/p>
&lt;p>En C, se hace de la siguiente forma:&lt;/p>
&lt;p>    g++ main.c perlas.c -o perlas&lt;/p>
&lt;p>Mientras que para Pascal:&lt;/p>
&lt;p>fpc main.pas&lt;/p>
&lt;p>De la misma forma, las opciones de compilación pueden ser diferentes en la evaluación, sin embargo, si tu programa compila con las plantillas, también debería de hacerlo en el evaluador.&lt;/p>
&lt;p>&lt;strong>Descarga las plantillas &lt;a href="https://www.dropbox.com/sh/nux63uknmdyzgej/sfqTP9Tng8/plantillas.rar" target="_blank" rel="noopener">aquí&lt;/a> .&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Solución&lt;/strong>&lt;/p>
&lt;p>Una manera sencilla de tratar de ganar en este juego, es hacer una búsqueda sobre las listas de los enanos verdes y siempre pasar el collar sobre los enanos verdes, lo cual resolvería un par de casos. Sin embargo, en la mayor parte de los casos, es necesario pasar el collar a un enano rojo que eventualmente lo regresará a un enano verde. Y este es precisamente el problema, saber cuándo pasar a un enano rojo y a qué enano rojo, y como se necesita de la interacción de los enanos rojos para llegar a la solución, un gran problema se presenta.&lt;/p>
&lt;p>Aunque este problema podría resolverse fácilmente con una búsqueda memorizada haciendo las llamadas a las funciones durante la búsqueda, no puede hacerse de esta forma porque cuando se hace una búsqueda se requiere poder ir hacia adelante y hacia atrás en el árbol de búsqueda, y como se necesita de la interacción de los enanos rojos, se tiene que lograr la solución en la primera pasada.&lt;/p>
&lt;p>Por lo tanto hay que calcular todas las posibles tiradas antes de jugar, considerando las mejores tiradas de los enanos rojos. De esta forma, una vez que se tiene  una jugada para ganar el juego para &lt;strong>cualquier estado posible&lt;/strong>, se puede jugar teniendo seguro el triunfo.&lt;/p>
&lt;p>Ahora, aunque sabemos que no se puede resolver con una búsqueda, sí podemos utilizar un árbol de búsqueda para resolver el problema, pero ¿cómo tomar en cuenta las elecciones de los enanos rojos?, la respuesta a esto es jugar para ambos equipos y usar el mismo cósigo para ello, eligendo siempre la mejor opción para &lt;strong>el color de enano&lt;/strong> en cada turno, es decir, cuando la búsqueda esté sobre un enano rojo, hay que elegir la opción que haga que los enanos rojos ganen, y cuando la búsqueda esté sobre un enano verde, hay que elegir la opción que haga ganar a los enanos verdes.&lt;/p>
&lt;p>Es evidente que cuando las hojas del árbol terminan en un enano verde, se gana el juego (esos estados son estados ganadores), y cuando termina en un enano rojo el juego se pierde (esos estados son estados perdedores), eso es fácil, lo difícil son los siguientes niveles.&lt;/p>
&lt;p>Tomando en cuenta esto necesitamos etiquetar todos los estados como estados ganadores o estados perdedores, debido a que ya sabemos qué son los estados hojas, podemos deducir qué son los estados anteriores a las hojas de la siguiente forma: Si el estado pertenece a un enano verde, nos basta con que UN y solo UN enano en su lista lleve a un estado ganador, ya que como enanos verdes podemos controlar a quien le pasamos el collar, por lo que basta con que el estado pueda llevar a un estado ganador para que también sea un estado ganador. Si el enano verde NO lleva a ningún estado ganador, entonces ese estado NO es un estado ganador, por que no importa a quien se lo pases, siempre perderás.&lt;/p>
&lt;p>Pensando de esta misma forma, si el estado pertenece a un enano rojo, necesitamos que TODOS los estados a los que conduzca sean estados ganadores, por que si hay solo un estado perdedor, los enanos rojos, que juegan con la mejor estrategia, siempre eligirán ese estado.&lt;/p>
&lt;p>De esta forma, es posible que haya enanos verdes a los que quieras evitar, y enanos rojos a los que quieras pasarle el collar.&lt;/p>
&lt;p>Entonces, para resolver el problema, hay que pasar por todos los estados y marcarlos como estados ganadores o estados perdedores con la técnica que más te guste, ya sea programación dinámica o búsqueda memorizada, pero hay que hacerlo antes de jugar. Una vez teniendo precalculado cuáles son los estados ganadores y perdedores, solo hay que hacer las llamadas de los enanos verdes siempre hacia estados ganadores.&lt;/p>
&lt;p>&lt;a href="http://elira.operamail.com/files/perlas.rar" target="_blank" rel="noopener">DESCARGAR ARCHIVOS Y SOLUCIÓN&lt;/a>&lt;/p></description></item></channel></rss>