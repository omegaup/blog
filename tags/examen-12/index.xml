<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 12</title><link>https://blog.omegaup.com/tags/examen-12/</link><description>Recent content in Examen 12 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sun, 06 Oct 2013 22:56:54 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-12/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Mapas de bits"</title><link>https://blog.omegaup.com/posts/solucion-a-mapas-de-bits/</link><pubDate>Sun, 06 Oct 2013 22:56:54 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-mapas-de-bits/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P12/#problems/Mapas-de-bits" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 12&lt;/a> &lt;strong>Autor:&lt;/strong> Jorge Alberto González Martínez &lt;strong>Fuente&lt;/strong>: Jorge Alberto González Martínez&lt;/p>
&lt;p>En el problema se describen dos formas de representar un mapa de bits.&lt;/p>
&lt;p>La forma bidimensional es simplemente utilizar una matriz para representar los bits. La forma por descomposición consiste en agrupar los bits similares y solo escribir el valor de los bits similares. En caso de que no sean similares todos los bits en un mapa de bits dado, se procede a dividir en cuatro secciones, imprimir la letra D y procesar cada uno de los cuartos de la misma manera, tal como se lee en la descripción del problema.&lt;/p>
&lt;p>La solución a este problema consistía en programar el método descrito. Este método inherentemente está basado en la técnica de divide y vencerás.&lt;/p>
&lt;p>A continuación, un pseudo-código que muestra la forma de llevar a cabo la transformación de un mapa de bits bidimensional a la forma reducida:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> ReduceMapa(mapaDeBits)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Si todos los elementos en mapaDeBits son iguales
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Imprime el valor y termina
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Si no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Imprime D
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReduceMapa(mapaDeBits.superiorIzquierdo)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReduceMapa(mapaDeBits.superiorDerecho)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReduceMapa(mapaDeBits.inferiorIzquierdo)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReduceMapa(mapaDeBits.inferiorDerecho)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>El método para hacer la transformación inversa es muy parecido, sólo que para imprimir la equivalencia hay que comenzar con un mapa de bits bidimensional que nos sirva de variable auxiliar para hacer la conversión. Esta variable auxiliar se puede declarar de manera global y, cuando el método recursivo termine, simplemente imprimir su contenido:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> AmplificaMapa(mapaDeBits, sección)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Si mapaDeBits comienza con un valor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rellenar sección del mapa bidimensional con el valor
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Si no
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.superiorIzquierda)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.superiorDerecha)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.inferiorIzquierda)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AmplificaMapa(mapaDeBits.removerPrimerElemento, sección.inferiorDerecha)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>La primera vez que se llama a la función AmplificaMapa se debe entregar la representación de la forma por descomposición del mapa de bits en la variable mapaDeBits y la sección que se entrega inicialmente es todo el mapa de bits. Esto puede ser manejado por filas y columnas.&lt;/p>
&lt;p>A continuación se muestra una implementación en C++ que resuelve el problema. Nótese cómo se maneja la sección sobre la que se está trabajando con cuatro variables: &lt;code>tl_row&lt;/code>, &lt;code>tl_col&lt;/code>, &lt;code>br_row&lt;/code>, &lt;code>br_col&lt;/code>. El nombre de las variables proviene de top-left row, top-left colum, bottom-right row y bottom-right colum respectivamente. Representan los índices (fila,columa) de las esquinas superior izquierda e inferior derecha.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860210.js">&lt;/script></description></item><item><title>Solución a "Chilly Rapero"</title><link>https://blog.omegaup.com/posts/solucion-a-chilly-rapero/</link><pubDate>Sat, 12 Jan 2013 19:41:11 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-chilly-rapero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>La clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.&lt;/p>
&lt;p>Crear las aristas entre los nodos tiene una complejidad de O(LN2) y la manera más simple de almacenar dichas aristas es mediante una matriz de adyacencia. Ya que tenemos el grafo planteado, buscaremos la manera más rápida de cambiar de palabra entre cualquier par de palabras, esto puede conseguirse usando el algoritmo de &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Floyd-Warshall" target="_blank" rel="noopener">Floyd-Warshall&lt;/a> con una complejidad de O(N3) que es suficiente para el problema.&lt;/p>
&lt;p>Finalmente, para obtener la respuesta sumamos el mínimo número de cambios requeridos entre todos los pares de palabras consecutivas en el rap, este número de cambios fue obtenido mediante el algoritmo de Floyd-Warshall. El número total de cambios lo multiplicamos por 0.2 y será la respuesta para el problema.&lt;/p>
&lt;p>Complejidad de la solución: O(LN2+N3)&lt;/p></description></item><item><title>Solución a "Metro"</title><link>https://blog.omegaup.com/posts/solucion-a-metro/</link><pubDate>Mon, 07 Jan 2013 17:22:45 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-metro/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>El problema en cuestión se reduce a encontrar un árbol de expansión mínima. La solución es una aplicación directa de alguno de los algoritmos existentes para ello (bien implementada), por lo que hablaré brevemente sobre una de las posibilidades y daré referencias donde puedan encontrar información más detallada.&lt;/p>
&lt;p>Para encontrar el costo mínimo de unir todas las estaciones debemos encontrar el árbol de expansión mínima de la gráfica en cuestión (es decir, una subgráfica conexa que una todos los vértices de la gráfica original y cuyo peso (la suma de los costos de todas sus aristas) sea el mínimo posible (siempre es un árbol)). Para ello una opción es usar el algoritmo de Kruskal: Ordenamos las aristas por su peso y vamos agregando cada arista de peso mínimo que no cree un ciclo en la gráfica. Hacemos esto hasta haber conectado todos los vértices de nuestra gráfica. Por la cantidad de aristas que tenemos requerimos ordenar eficientemente y verificar si las aristas forman un ciclo o no eficientemente en cada paso, de lo contrario el programa no correrá en tiempo.&lt;/p>
&lt;p>Para verificar si se forma o no un ciclo agregando una determinada arista empleamos el algoritmo conocido como Union Find, que se explica ampliamente en las secciones 16.7, 16.8 y 16.9 del libro Problemas y Algoritmos de Luis E. Vargas Azcona. Es importante mencionar que para obtener los 100 puntos en el problema es necesario implementar las optimizaciones que se mencionan (y aunque no fuera así no está de más que las conozcan).&lt;/p>
&lt;p>Además del libro de Luis E. Vargas, que recomiendo ampliamente, sugiero la página de Pier Guillen &lt;a href="http://pier.guillen.com.mx/" target="_blank" rel="noopener">http://pier.guillen.com.mx/&lt;/a> , que en -&amp;gt;Algorithms -&amp;gt;10. Gráficas -&amp;gt;10.6 Árboles Mínimos Generadores desarrolla el tema en cuestión. Y claro, no está de más que consulten el tema en el libro Introduction to Algorithms de Thomas H. Cormen, que en la tercera edición trabaja el tema en el capítulo VI. Graph Algorithms -&amp;gt;23 Minimum Spanning Trees.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559170.js">&lt;/script></description></item></channel></rss>