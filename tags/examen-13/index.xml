<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 13</title><link>https://blog.omegaup.com/tags/examen-13/</link><description>Recent content in Examen 13 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Mon, 30 Sep 2013 14:48:04 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-13/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución de "El Concierto de Dr. Lira"</title><link>https://blog.omegaup.com/solution/solucion-de-el-concierto-de-dr-lira/</link><pubDate>Mon, 30 Sep 2013 14:48:04 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-de-el-concierto-de-dr-lira/</guid><description>
&lt;p>**Concurso: **&lt;a href="https://omegaup.com/arena/IOI2014E1P13#problems/DP-Generica" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 13&lt;/a> &lt;strong>Fuente&lt;/strong>: Topcoder&lt;/p>
&lt;p>El Concierto de Dr. Lira es una adaptación al problema Changing Sounds que apareció en el SRM 366 (2007, ya llovió) en TopCoder. La solución explicada la pueden encontrar en el &lt;a href="http://community.topcoder.com/tc?module=Static&amp;amp;d1=match_editorials&amp;amp;d2=srm366" target="_blank" rel="noopener">Match Summary&lt;/a> (necesitan registrarse en omegaUp para verlo).&lt;/p>
&lt;p>Les dejo la implementación de &lt;a href="https://omegaup.com/profile/spleensarethebest" target="_blank" rel="noopener">spleensarethebest&lt;/a> como un muy bien ejemplo de solución a este problema. Cualquier duda, déjenos un comentario.&lt;/p>
&lt;script src="https://gist.github.com/joemmanuel/6764850.js">&lt;/script></description></item><item><title>Solución a "DP Genérica"</title><link>https://blog.omegaup.com/solution/solucion-a-dp-generica/</link><pubDate>Wed, 25 Sep 2013 06:00:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-dp-generica/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P13#problems/DP-Generica" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 13&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Project Euler&lt;/p>
&lt;p>Podemos tratar este problema de varias maneras distintas, 3 de las cuales discutiré en esta solución.&lt;/p>
&lt;h2>Análisis 1&lt;span class="hx-absolute -hx-mt-20" id="análisis-1">&lt;/span>
&lt;a href="#an%c3%a1lisis-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero, una idea que hubiera obtenido 50 puntos.&lt;/p>
&lt;p>Podemos observar que el problema es equivalente a encontrar de cuántas maneras se le puede asignar un número $latex n_i$ del conjunto $latex \{0,1,2\}$ a cada potencia de 2 tal que $latex \sum_{i=0}^{\infty} n_i 2^i = x$. Esto también es equivalente a encontrar cuántos números $latex a$ y $latex b$ hay tales que $latex a + b = x$ y no haya ningún bit encendido en $latex b$ que no esté encendido en $latex a$.&lt;/p>
&lt;p>Consideremos la expansión binaria de $latex a = \sum_{i=0}^{\infty} a_i 2^i$ y $latex b = \sum_{i=0}^{\infty} b_i 2^i$ , donde cada $latex a_i$ y $latex b_i$ es 1 o 0. Al sumar $latex a + b = \sum_{i=0}^{\infty} (a_i + b_i) 2^i$ tenemos que $latex 0 \le n_i = a_i + b_i \le 2$, como se necesita. Para contar solamente una vez cada configuración distinta de la secuencia $latex n$, añadimos la restricción de que cualquier $latex b_i$ puede ser 1 sólo si $latex a_i$ también lo es.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Para esta subtarea es suficiente probar todas las $latex a$ y $latex b$ posibles, revisando con un loop para cada bit si la condición sobre $latex b$ se cumple. Este algoritmo corre en tiempo $latex O(N^2 \log N)$.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Para esta subtarea podemos hacer una observación sencilla: a cada $latex a$ sólo le puede corresponder una $latex b$, igual a $latex x - a$, lo que reduce la complejidad en tiempo del algoritmo a $latex O(N \log N)$.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos comprobar si $latex b$ cumple la condición en tiempo constante utilizando operaciones de bits. Si &lt;code>~a &amp;amp; b&lt;/code> es igual a 0, $latex b$ no tiene ningún bit encendido que $latex a$ no tenga encendido. Ahora tenemos un algoritmo lineal. Desafortunadamente, ya no podemos mejorar nuestra solución fácilmente continuando con esta idea.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702819.js">&lt;/script>
&lt;h2>Análisis 2&lt;span class="hx-absolute -hx-mt-20" id="análisis-2">&lt;/span>
&lt;a href="#an%c3%a1lisis-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos hacer programación dinámica de forma &lt;em>top-down&lt;/em>. En ésta, contamos la cantidad de maneras de escribir $latex x$ como pide el problema incluyendo o no cada una de las potencias distintas.&lt;/p>
&lt;p>Consideremos la función $latex f(n,p)$, que cuenta de cuántas maneras podemos escribir $latex n$ utilizando potencias de 2 menores o iguales a $latex p$ no más de 2 veces cada una. Es evidente que la respuesta se encontraría evaluando $latex f(x,63)$.&lt;/p>
&lt;p>Sabemos que $latex f(n,p) = 0$ si $latex n$ es negativo o si $latex p$ es negativo. Del mismo modo, $latex f(n,p) = 1$ si $latex n = 0$. De lo contrario, es igual a la suma de $latex f(n,p-1)$, $latex f(n-2^p,p-1)$ y $latex f(n-2^{p+1},p-1)$, que corresponden a poner 0, 1, o 2 veces la potencia $latex 2^p$.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Aplicando directamente el análisis anterior, la subtarea 1 queda resuelta.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Varios de estos estados se repiten, así que convendría memorizarlos. Utilizando un contenedor como &lt;code>std::map&lt;/code>, la solución se vuelve lo suficientemente rápida para resolver esta subtarea.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos determinar en algunos casos rápidamente si la función se evaluará a 0. Sabemos que $latex \sum_{i=0}^{k} 2^i = 2^{k+1} - 1$. Entonces, el número más grande que podemos escribir sólo usando potencias de 2 menores o iguales a $latex p$ a lo más dos veces es $latex 2\sum_{i=0}^{p} 2^p = 2 (2^{p+1} - 1) = 2^{p+2} - 2$. Por lo tanto, $latex f(n,p) = 0$ si $latex n &amp;gt; 2^{p+2} - 2$.&lt;/p>
&lt;p>Esa optimización por sí misma (sin memorización), resuelve la subtarea 3.&lt;/p>
&lt;h1>Subtarea 4&lt;/h1>&lt;p>Combinando las ideas de las dos subtareas anteriores, el algoritmo es lo suficientemente rápido para resolver todos los casos. Específicamente, la cantidad de estados que no podemos determinar como no viables instantáneamente es proporcional a $latex \log x$, y cada estado lo podemos evaluar en tiempo $latex O(\log \log x)$ por nuestro &lt;code>std::map&lt;/code>, dándonos una complejidad total de $latex O(\log x \log \log x)$. Esta cota puede quedar más clara después de describir la tercera solución.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702849.js">&lt;/script>
&lt;h2>Análisis 3&lt;span class="hx-absolute -hx-mt-20" id="análisis-3">&lt;/span>
&lt;a href="#an%c3%a1lisis-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución es equivalente a la anterior, pero no precisa de un &lt;code>std::map&lt;/code>.&lt;/p>
&lt;p>Consideremos la función $latex n(k)$, que definimos como el número que obtenemos tomando los bits $latex 0..k$ de $latex x$. En otras palabras, si $latex x = \sum_{i=0}^{\infty} x_i 2^i$ donde $latex x_i$ es el $latex i$-ésimo bit de $latex x$, $latex n(k) = \sum_{i=0}^k x_i 2^i$. Ahora, definimos la función $latex g(i,r)$, que cuenta de cuántas maneras se puede escribir el número $latex n(i) + r2^i$, utilizando potencias de 2 menores o iguales a $latex i$ a lo más 2 veces. La respuesta, por lo tanto, se obtendría evaluando $latex g(63,0)$.&lt;/p>
&lt;p>Ahora, sabemos que $latex g(i,r) = 1$ si $latex i &amp;lt; 0$ y $latex r = 0$, porque podemos escribir sólo de una manera 0. Recordando que $latex x_i$ es el $latex i$-ésimo bit de $latex x$, podemos decir que $latex g(i,r)$ cuenta la cantidad de formas que se puede escribir el número $latex (r+x_i)2^i + n(i-1)$. De ahora en adelante, por conveniencia, $latex t = r + x_i$.&lt;/p>
&lt;p>Usando esto, podemos definir $latex g(i,r)$ recursivamente:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \text{ y } r = 0 \\ \sum_{k=0}^{min(t,2)}g(i-1,2(t-k)) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>En otras palabras, si tenemos que poner $latex t$ veces la potencia $latex i$, podemos elegir ponerla hasta $latex min(t,2)$ veces, y contar las maneras de escribir el resto usando potencias de 2 menores a $latex p$. Pero como dejamos $latex t-k$ veces la potencia $latex i$ sin poner, es igual a poner $latex 2(t-k)$ veces la potencia $latex i-1$.&lt;/p>
&lt;p>La siguiente observación es que si $latex t$ es mayor a 3, $latex g(i,r) = 0$ porque $latex 2\sum_{k=0}^{i} 2^k &amp;lt; 4 \times 2^{i}$. Entonces, sólo nos interesan los casos en los que $latex 0 \le t \le 3$. En total, sólo hay 4 valores posibles para $latex t$ en los que $latex g(i,r)$ no es 0: 0, 1, 2, y 3. Enumerémoslos:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,4) + g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,6) + g(i-1,4) + g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Pero $latex g(i,r) = 0$ si $latex t &amp;gt; 3$, y como $latex t \ge r$, nos quedamos con:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Tomando en cuenta que $latex r$ sólo puede ser 0 o 2, y $latex x_i$ sólo 0 o 1:&lt;/p>
&lt;p>$latex (g(i,0),g(i,2)) = \begin{cases} (g(i-1,0),g(i-1,2)+g(i-1,0)) &amp;amp; \text{si } x_i = 0 \\ (g(i-1,2)+g(i-1,0),g(i-1,2)) &amp;amp; \text{si } x_i = 1 \end{cases}$&lt;/p>
&lt;p>El siguiente código implementa esta solución, que corre en tiempo $latex O(\log n)$ y espacio constante:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702863.js">&lt;/script>
&lt;p>Como podemos observar, esta solución considera los mismos estados que la anterior, sólo que aquí evitamos computarlos, mientras que la otra los descarta inmediatamente.&lt;/p>
&lt;h2>Consideraciones&lt;span class="hx-absolute -hx-mt-20" id="consideraciones">&lt;/span>
&lt;a href="#consideraciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Varios competidores no consideraron que $latex x$ no cabe en un entero signado de 64 bits. Si bien la &lt;em>respuesta&lt;/em> cabe en uno, en los límites del problema se especifica que $latex x &amp;lt; 2^{64}$.&lt;/p>
&lt;h2>Análisis adicional:&lt;span class="hx-absolute -hx-mt-20" id="análisis-adicional">&lt;/span>
&lt;a href="#an%c3%a1lisis-adicional" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;a href="https://omegaup.com/profile/DiegoRoque" target="_blank" rel="noopener">Diego Roque&lt;/a> escribió una solución distinta, la cual detallaré a continuación.&lt;/p>
&lt;p>Consideremos la función $latex f(x)$ como la define el problema: la cantidad de maneras de escribir $latex x$ como una suma de potencias no negativas de 2 sin usar cada una más de 2 veces.&lt;/p>
&lt;p>Enfoquémonos en la paridad de $latex x$ (es decir, el último bit de $latex x$). Si $latex x$ es impar, necesariamente tenemos que poner una vez la potencia $latex 2^0$, porque las otras dos opciones: ponerla 0 veces o ponerla 2 veces cambiarían la paridad de $latex x$. Por lo tanto, $latex f(x) = f(\frac{x-1}{2})$ si $latex x$ es impar. En cambio, si es par, podemos elegir poner la potencia $latex 2^0$ 0 o 2 veces, lo que nos deja con $latex f(x) = f(\frac{x}{2}) + f(\frac{x}{2}-1)$. Sólo falta definir los casos base: $latex f(0) = f(1) = 1$.&lt;/p>
&lt;p>Aquí está su código que implementa esta solución, que corre en tiempo $latex O(\log^2 x \log \log^2 x):$&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702891.js">&lt;/script></description></item></channel></rss>