<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 17</title><link>https://blog.omegaup.com/tags/examen-17/</link><description>Recent content in Examen 17 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sat, 18 Jan 2014 23:25:14 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-17/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Mocha Hojas"</title><link>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</link><pubDate>Sat, 18 Jan 2014 23:25:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Mocha-Hojas" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Alberto José Ramírez Valadez&lt;/p>
&lt;p>Para simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.&lt;/p>
&lt;p>Consideremos el caso de un árbol con un solo nivel. Ya que sólo podemos restarle a los pesos de las hojas, evidentemente el peso máximo del árbol se alcanza cuando se emparejan todas las hojas al peso de la hoja con peso mínimo.&lt;/p>
&lt;p>Ahora, consideremos un árbol con dos niveles. Si la raíz tiene $ k$ hijos, para cada hijo $ i$ sea $ h_i$ el subárbol de $ i$, $ b_i$ el número de hojas de $ h_i$, y $ c_i$ el peso del árbol obtenido de realizar el procedimiento del párrafo anterior a $ h_i$. Si todas las $ c_i$ son iguales, entonces nuestro árbol está balanceado. De lo contrario, debemos restar aún más para poder balancearlo. Sin embargo, también necesitamos que cada $ h_i$ continúe estando balanceado. La única manera que le podemos restar peso a $ h_i$ sería restarle la misma cantidad de peso a cada una de sus hojas. Entonces, a cada $ h_i$ sólo podemos restarle peso en múltiplos de $ b_i$. Como queremos maximizar el peso del árbol resultante, necesitamos encontrar el número más grande $ x$ tal que a todos los $ c_i$ les podamos restar un múltiplo de su respectivo $ b_i$ para obtener $ x$. Notemos también que $ c_i$ es un múltiplo de $ b_i$ porque los nodos internos del árbol no tienen peso. Si $ m$ es el mínimo común múltiplo de todos los $ b_i$, entonces $ x$ también es un múltiplo de $ m$. Entonces, el máximo $ x$ posible es igual al múltiplo de $ m$ más grande que sea menor o igual a todos los $ c_i$. Por lo tanto, el valor máximo obtenible del árbol completo es igual a $ kx$. Por último, si tuviéramos que restarle más peso a este árbol pero mantenerlo balanceado, es evidente que lo menos que podemos restar para mantenerlo balanceado es $ km$, y si seguimos restando $ km$ continuará balanceado.&lt;/p>
&lt;p>De esta observación podemos obtener la solución para cualquier árbol. Reusando la notación del párrafo anterior, $ k$ es la cantidad de hijos de la raíz, $ h_i$ el subárbol del $ i$ésimo hijo, y $ c_i$ el peso del árbol obtenido de realizar recursivamente el procedimiento de éste párrafo a $ h_i$ (o el del anterior si $ h_i$ tiene 2 niveles). Ahora $ b_i$ es igual a lo mínimo que le podemos restar a $ h_i$ y que continúe balanceado. El análisis del párrafo anterior también es correcto para la nueva definición de $ b_i$ y $ c_i$.&lt;/p>
&lt;p>El código siguiente implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8498208.js">&lt;/script></description></item><item><title>Solución a "Panoramas"</title><link>https://blog.omegaup.com/solution/solucion-a-panoramas/</link><pubDate>Thu, 16 Jan 2014 17:36:38 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-panoramas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Tour" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Ángel Covarrubias &lt;strong>Fuente&lt;/strong>: Miguel Ángel Covarrubias&lt;/p>
&lt;p>El problema es un Steiner tree problem (un MST pero donde sólo hay que conectar un subconjunto de nodos) pero con costo por nodo en vez de por arista. El grafo de los panoramas es un árbol más un ciclo. Para un árbol una solución es poner como raíz a $ s_1$ y para cada $ s_i$ marcar los nodos en su camino hacia la raíz. Se puede usar DP o recursión para calcular el mínimo numero de vertices que conectan todos los nodos interesantes y pasan por la raíz para cada subárbol.&lt;/p>
&lt;p>$ \mathrm{dp}_r=\mathrm{interesante}(r)\ \mathrm{si}\ \Sigma_h\mathrm{dp}_h=0$ $ \mathrm{dp}_r = \Sigma_h\mathrm{dp}_h+1\ \mathrm{si}\ \Sigma_c\mathrm{dp}_h&amp;gt;0$&lt;/p>
&lt;p>$ h$ es un hijo de $ r$. La arista extra $ (u,v)$ en el ciclo $ c$ permite usar otros caminos a lo largo de $ c$. Tales caminos deben conectar todos los nodos en $ c$ que tengan nodos interesantes en su árbol después de quitar las aristas del ciclo $ E-c$. Etiquetemos tales nodos con un uno y los demás nodos del $ c$ con un cero. Para $ E-(u,v)$ el ciclo sólo no cubre los últimos ceros. Para encontrar la solución sólo basta encontrar la secuencia de ceros más grande. En el siguiente diagrama, la arista que falta es $ (u,v)$. La DP sólo no usa el último cero, pero es mejor no usar los dos ceros que están adyacentes.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">0&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">/&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">\\&lt;/span> &lt;span class="o">/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Este código implementa la solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8468920.js">&lt;/script></description></item></channel></rss>