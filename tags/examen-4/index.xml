<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 4</title><link>https://blog.omegaup.com/tags/examen-4/</link><description>Recent content in Examen 4 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 23 Jan 2014 03:41:06 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-4/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Crucero"</title><link>https://blog.omegaup.com/posts/solucion-a-crucero/</link><pubDate>Thu, 23 Jan 2014 03:41:06 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-crucero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P4#problems/Crucero" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:saul.g.gutierrez@gmail.com" >Saúl Germán Gutiérrez Calderón&lt;/a> &lt;strong>Fuente&lt;/strong>: USACO Enero 2009 Gold&lt;/p>
&lt;p>Como se puede notar, al trazar la ruta óptima del crucero se está desperdiciando mucho espacio, y daría lo mismo si expandiésemos la isla para que no se desperdiciara espacio entre la ruta y la orilla de ésta.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image002.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image002.jpg" title="image002" alt="" loading="lazy" />
&lt;figcaption>image002&lt;/figcaption>
&lt;/figure>&lt;/a> &lt;a href="https://blog.omegaup.com/images/image004.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image004.jpg" title="image004" alt="" loading="lazy" />
&lt;figcaption>image004&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si supiéramos cual es la ruta óptima del crucero para expandir la isla bastaría con hacer un Flood Fill para rellenar los espacios con agua que quedan dentro de la ruta.&lt;/p>
&lt;p>Resulta que el flood fill e puede hacer aun sin conocer cuál sería la ruta óptima. Si nos ponemos a hacer todos los tipos de celdas adyacentes a la celda actual en un flood fill, nos toparemos con que solo hay 2 que permiten que la isla crezca y 1 que evita que se expanda. El resto de las celdas adyacentes no nos dice nada acerca de si tenemos que poner algo ahí o no (de momento).&lt;/p>
&lt;p>Si se pone un pedazo de isla nuevo en el centro de las figura de abajo, entonces la cosa peligrosa tendría que ser rodeada de alguna manera para poder pasar, lo cual nos llevaría a tomar una ruta mas larga. Por ello, no es una buena idea poner un pedazo de isla ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image005.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image005.png" title="image005" alt="" loading="lazy" />
&lt;figcaption>image005&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si es como la de la figura de abajo,&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image006.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image006.png" title="image006" alt="" loading="lazy" />
&lt;figcaption>image006&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>ambos caminos tienen la misma longitud. Por ello, se puede poner un pedazo de isla ahí y esto nos simplifica el problema.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image007.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image007.png" title="image007" alt="" loading="lazy" />
&lt;figcaption>image007&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;a href="https://blog.omegaup.com/images/image008.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image008.png" title="image008" alt="" loading="lazy" />
&lt;figcaption>image008&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>La ruta óptima no puede pasar por el cuadro del centro ya que esto sería un desperdicio de tiempo, por lo cual podemos expandir la tierra ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image009.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image009.png" title="image009" alt="" loading="lazy" />
&lt;figcaption>image009&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Entonces, sólo hay que hacer todas las expansiones de tierra hasta que ya no se pueda más y después de esto se puede hacer una mano derecha para buscar la orilla de la isla que al mismo tiempo será la ruta óptima.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572582.js">&lt;/script></description></item><item><title>Solución a "Cueva"</title><link>https://blog.omegaup.com/posts/solucion-a-cueva/</link><pubDate>Mon, 14 Jan 2013 16:27:54 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-cueva/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P4" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>Después de comprender el problema podemos deducir dos cosas:&lt;/p>
&lt;ul>
&lt;li>Los &lt;strong>N&lt;/strong> puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán &lt;strong>N-1&lt;/strong> aristas y siempre hay un camino entre cualquier par de nodos.&lt;/li>
&lt;li>Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las &lt;strong>Q&lt;/strong> preguntas, ¿el nodo A es un ancestro del nodo &lt;strong>B&lt;/strong>?”, de modo que necesitamos encontrar una manera óptima de saberlo.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Subtarea 1&lt;/strong>&lt;/em>. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si &lt;strong>A&lt;/strong> es ancestro de &lt;strong>B&lt;/strong>, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo &lt;strong>A&lt;/strong> encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo &lt;strong>B&lt;/strong>, si existe un camino del nodo &lt;strong>A&lt;/strong> al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo &lt;strong>A&lt;/strong> es el mismo nodo &lt;strong>B&lt;/strong>, en ambos casos la respuesta es 0.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NQ)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>&lt;em>Subtarea 2.&lt;/em>&lt;/strong> Es notable que esta vez el número de preguntas es mucho mayor, por ello la solución anterior tardaría demasiado. Cambiemos nuestra estrategia, esta vez realicemos una búsqueda en profundidad desde el nodo 1 hasta los demás &lt;strong>N&lt;/strong> nodos, llevando una lista &lt;strong>L&lt;/strong> de los nodos que forman parte del camino desde el nodo 1 hasta el nodo &lt;strong>K&lt;/strong>, incluyendo los nodos 1 y &lt;strong>K&lt;/strong>, esto puede lograrse mediante recursividad.&lt;/p>
&lt;p>La tabla &lt;strong>ancestro[K][M]&lt;/strong> nos permitirá saber si el nodo &lt;strong>M&lt;/strong> es un ancestro del nodo &lt;strong>K&lt;/strong>, dándonos cuenta que todos los ancestros de &lt;strong>K&lt;/strong> se encuentran en la lista &lt;strong>L&lt;/strong> cuando la búsqueda en profundidad llega al nodo &lt;strong>K&lt;/strong>, podemos llenar la tabla &lt;strong>ancestro[K][M]&lt;/strong> durante la búsqueda en profundidad. Con la tabla anterior es fácil responder las preguntas, pues la respuesta depende de &lt;strong>ancestro[B][A]&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N2+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 3&lt;/strong>&lt;/em>. Para obtener los puntos de esta subtarea podemos utilizar cualquier algoritmo para resolver el clásico problema del ancestro común de dos nodos en un árbol, puesto que la respuesta es 1 si el ancestro común entre los nodos &lt;strong>A&lt;/strong> y &lt;strong>B&lt;/strong> es el nodo &lt;strong>A&lt;/strong>. Este problema ya ha sido estudiado ampliamente y tiene diversas formas de ser resuelto con complejidad &lt;strong>O(NlogN)&lt;/strong>, en el foro de tutoriales de TopCoder podemos encontrar un buen artículo con algunos de los algoritmos que pueden ser utilizados:&lt;/p>
&lt;p>&lt;a href="http://community.topcoder.com/tc?module=Static&amp;amp;d1=tutorials&amp;amp;d2=lowestCommonAncestor" target="_blank" rel="noopener">TopCoder Lowest Common Ancestor&lt;/a>&lt;/p>
&lt;p>El algoritmo que utiliza programación dinámica es el más recomendado, puesto que se puede responder a las &lt;strong>Q&lt;/strong> preguntas en un tiempo constante.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NlogN+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 4&lt;/strong>&lt;/em>. Para empezar, notemos que la solución anterior no funciona para este conjunto de puntos porque utiliza demasiada memoria, el simple hecho de almacenar los nodos y las aristas ocupa bastante espacio en memoria (aproximadamente 100Mb) y una solución para la subtarea 3 requeriría al menos 50Mb más, por lo tanto no es posible completar la subtarea 4 con una solución como la anterior, para obtener los 100 puntos en este problema necesitamos una idea mucho más creativa.&lt;/p>
&lt;p>Renombremos todos los nodos del árbol enumerandolos del 1 al &lt;strong>N&lt;/strong> siguiendo el orden establecido por el recorrido en postorden del árbol comenzando por el nodo 1, después, para cada nodo, con su respectivo número &lt;strong>Y&lt;/strong>, hay que obtener el menor número presente en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>, denotemos este número menor como &lt;strong>X&lt;/strong>, con los números &lt;strong>X&lt;/strong> y &lt;strong>Y&lt;/strong> definimos entonces un intervalo cerrado &lt;strong>[X,Y]&lt;/strong> que nos representa que en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong> se contienen todos los nodos cuyo número se encuentra en el intervalo &lt;strong>[X,Y]&lt;/strong>. Podemos interpretar esta información de una manera más conveniente, un nodo con número &lt;strong>Y&lt;/strong> es ancestro de un nodo con número &lt;strong>K&lt;/strong> si &lt;strong>X ≤ K ≤ Y&lt;/strong>, lo cual nos permitirá responder las preguntas planteadas.&lt;/p>
&lt;p>Es recomendable que el olímpico experimente y se convenza que la propiedad del intervalo &lt;strong>[X,Y]&lt;/strong> es siempre correcta debido a que el recorrido en postorden establecerá que el nodo con el número &lt;strong>X&lt;/strong>, que establece la cota inferior del intervalo, siempre será una hoja del subárbol y el nodo con valor &lt;strong>Y&lt;/strong>, que establece la cota superior del intervalo, siempre será la raíz del subárbol, cualquier otro valor fuera del intervalo estará excluido del subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N+Q)&lt;/strong>&lt;/em>&lt;/p></description></item></channel></rss>