<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 5</title><link>https://blog.omegaup.com/tags/examen-5/</link><description>Recent content in Examen 5 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es-MX</language><lastBuildDate>Sat, 14 Sep 2013 05:21:32 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-5/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Comesolo"</title><link>https://blog.omegaup.com/posts/solucion-a-comesolo/</link><pubDate>Sat, 14 Sep 2013 05:21:32 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-comesolo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/comesolo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://lhchavez.com" target="_blank" rel="noopener">lhchavez&lt;/a> &lt;strong>Fuente&lt;/strong>: Félix&lt;/p>
&lt;p>Este problema es especial porque es el primero en omegaUp de solo salida! Usualmente lo que debes esperar cuando te enfrentes con uno de esos problemas es que sea un problema NP que no tiene una solución rápida, y usualmente te pedirán que te aproximes lo más posible a la solución óptima. Esto significa que te vas a tener que valer de técnicas ad-hoc y heurísticas para sacar puntos.&lt;/p>
&lt;p>La solución del problema es bastante sencilla de explicar: haz una búsqueda en profundidad intentando todos los posibles movimientos por fuerza bruta hasta que te salga una solución aceptable e imprímela. El problema es que esta estrategia es $latex O(n!)$, y como $latex n$ puede valer hasta 30x30, puedes esperar que el programa corra varios milenios antes de encontrar la solución óptima. Hay tres trucos (en orden de importancia) para obtener una solución decente en un tiempo razonable:&lt;/p>
&lt;ul>
&lt;li>No repetir estados.&lt;/li>
&lt;li>No &amp;ldquo;clavarse&amp;rdquo; con soluciones que parece que son muy buenas, pero en realidad llevan a callejones sin salida.&lt;/li>
&lt;li>Encontrar una manera de darle prioridad a los estados que tengan más probabilidad de llegar a una solución buena.&lt;/li>
&lt;/ul>
&lt;p>La estrategia que yo personalmente seguí fue que cada que encontraba un nuevo estado, obtenía su &lt;a href="http://es.wikipedia.org/wiki/Funci%C3%B3n_hash" target="_blank" rel="noopener">hash&lt;/a> (que resultaba en un entero de 64 bits) y verificaba si no lo había visitado usando una tabla de hash&lt;a href="#note" >*&lt;/a>. Si no la había visitado, encontraba todos los estados vecinos (todos los tableros que resultaban de hacer un movimiento válido) y los guardaba en una fila de acuerdo a la cantidad de puntos (entre más puntos, más adelante en la fila). Luego, elegía aleatoriamente un estado de la fila dándole prioridad a los que estaban más adelante (pues son los que tienen mayor probabilidad de llegar a una buena solución), lo cual también me evitaba seguir un único camino donde me podría atorar. Repetí eso hasta que se me terminó la memoria de la computadora e imprimí la mejor solución.&lt;/p>
&lt;p>A continuación, el pseudocódigo de la solución:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Estado&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> puntos &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[N&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[N&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] tablero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Estado padre &lt;span style="color:#f92672">=&lt;/span> null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> def &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_init&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_(Estado p)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puntos &lt;span style="color:#f92672">=&lt;/span> p.puntos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tablero &lt;span style="color:#f92672">=&lt;/span> p.tablero
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> padre &lt;span style="color:#f92672">=&lt;/span> p
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> def hash()&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Puedes usar cualquier algoritmo que genere un entero de 64 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># a partir de tablero y puntos. Este es el más sencillo.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hash &lt;span style="color:#f92672">=&lt;/span> puntos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i in range(&lt;span style="color:#ae81ff">0&lt;/span>, N)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hash &lt;span style="color:#f92672">=&lt;/span> ((hash &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">7&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> (hash &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">53&lt;/span>)) &lt;span style="color:#f92672">^&lt;/span> tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> hash
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> def siguientes(queue&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#ae81ff">300&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] colas)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Para todas las celdas (i, j) del tablero...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> i in range(&lt;span style="color:#ae81ff">0&lt;/span>, N)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> j in range(&lt;span style="color:#ae81ff">0&lt;/span>, N)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Si la celda tiene una pieza...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[j&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Para todos los vecinos contiguos (i+k, j+l)...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> k in range(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> l in range(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Asegúrate que se haya movido \_algo\_.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> k &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> l &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Y que pueda brincar dentro del tablero.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> l &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> or j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> l &lt;span style="color:#f92672">&amp;gt;=&lt;/span> N: &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Y que haya brincado una pieza.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> not tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i &lt;span style="color:#f92672">+&lt;/span> k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[j &lt;span style="color:#f92672">+&lt;/span> l&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Y que el lugar a donde brinca esté desocupado.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> l&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hijo &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Estado(&lt;span style="color:#66d9ef">this&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Aumenta la puntuación del hijo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hijo.puntos&lt;span style="color:#f92672">++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Borra la ficha original y la &amp;#34;comida&amp;#34;.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hijo.tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[j&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> hijo.tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i &lt;span style="color:#f92672">+&lt;/span> k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[j &lt;span style="color:#f92672">+&lt;/span> l&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> False
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Agrega la ficha en su posición final.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> hijo.tablero&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[j &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> l&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> True
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Agrégala a la cola correspondiente.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> colas&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[hijo.puntos&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>].push(hijo)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>def elige&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_estado()&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Número aleatorio entre 0 y 1.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> r &lt;span style="color:#f92672">=&lt;/span> (random() &lt;span style="color:#f92672">/&lt;/span> (&lt;span style="color:#66d9ef">float&lt;/span>)RAND&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_MAX)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># El índice de la última cola que estuvo llena.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> ultimolleno &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># La cola que se está considerando.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Elige la cola con mayores puntos que no esté vacía como
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># primera opción.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> i in range(&lt;span style="color:#ae81ff">0&lt;/span>, N)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> not colas&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>].vacio()&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># La primer cola tiene probabilidad de 31% de ser elegida.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># La segunda cola tiene probabilidad de 21%, la tercera 14%,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># la cuarta 10% y así sucesivamente.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> x &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> not colas&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[x&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>].vacio()&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ultimolleno &lt;span style="color:#f92672">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x&lt;span style="color:#f92672">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*=&lt;/span> &lt;span style="color:#ae81ff">1.45&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> r &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> and ultimolleno &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ultimolleno &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> Null
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> colas&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[lastfull&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>].pop()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>queue&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#ae81ff">300&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] colas
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hashtable estados&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_visitados
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">\#&lt;/span> lee el estado original
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>colas&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>].push(estado&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_original)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Estado mejor &lt;span style="color:#f92672">=&lt;/span> estado&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_original
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> no&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_se&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_haya&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_terminado&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_la&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_memoria()&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Estado s &lt;span style="color:#f92672">=&lt;/span> elige&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_estado()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Si ya no hay más estados por visitar,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e"># encontramos la respuesta óptima en algún punto.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> s &lt;span style="color:#f92672">==&lt;/span> Null: &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Actualiza |mejor| si hay una respuesta mejor.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> mejor.puntos &lt;span style="color:#f92672">&amp;lt;&lt;/span> s.puntos: mejor &lt;span style="color:#f92672">=&lt;/span> s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Repetir estados es malo.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> s.hash() in estados&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_visitados: &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> estados&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_visitados.add(s.hash())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Agrega todos los vecinos.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> s.siguiente(colas)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">\#&lt;/span> A partir de este punto, &lt;span style="color:#f92672">|&lt;/span>mejor&lt;span style="color:#f92672">|&lt;/span> contiene la mejor solución. Podemos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># saber qué movimiento se hizo para llegar a él comparando las
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># diferencias entre el tablero de |mejor.padre| y |mejor|. Ya solo es
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cuestión de imprimir el resultado y listo.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span> Aquí mucha gente se va a quejar porque solo guardar el hash abre la puerta a que haya dos estados que puede tener hasta &lt;span style="color:#ae81ff">900&lt;/span> bits que tengan el mismo hash de &lt;span style="color:#ae81ff">64&lt;/span> bits (por el [principio del palomar](http:&lt;span style="color:#75715e">//es.wikipedia.org/wiki/Principio_del_palomar)) y esté considerando que ya se visitó un estado que en realidad es nuevo. Si haces las cuentas, la probabilidad de colisión es negligible: la cantidad de estados que podía visitar en mi computadora (27 millones) es significativamente más pequeña que el número de estados necesarios para que la probabilidad de colisión sea de 1% ($latex \\approx 10^{135}$, por la [paradoja del cumpleaños](http://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os)).
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "Colección"</title><link>https://blog.omegaup.com/posts/solucion-a-coleccion/</link><pubDate>Sat, 14 Sep 2013 05:16:07 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-coleccion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/coleccion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> Alexis Cervantes / César Cepeda &lt;strong>Fuente:&lt;/strong> Alexis Cervantes / César Cepeda&lt;/p>
&lt;p>&lt;strong>_Estructura de la solución: _&lt;/strong>¿Qué nos están pidiendo? El problema nos esta pidiendo que encontremos un subconjunto de las tarjetas tal que la suma de todos los puntajes de las tarjetas de ese subconjunto sea la maxima posible, y la suma de sus precios sea menor o igual al dinero con el que cuentas.  En otras palabras lo que se esta buscando es que:&lt;/p>
&lt;p>la suma &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_51.webm" type="video/mp4">
&lt;/video>
sea maxima siempre y cuando &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_52.webm" type="video/mp4">
&lt;/video>
&lt;/p>
&lt;p>donde &lt;em>Xi&lt;/em>** = &lt;strong>{1 si se compró la tarjeta _i&lt;/strong>, **_y 0 si no se compró}&lt;/p>
&lt;p>**_Modelo del espacio de búsqueda como árbol: _**Al final de cuentas, incluso el nombre lo indica, este problema se puede reducir a asignarle a cada tarjeta un 0 ó un 1 dependiendo de si la vamos a comprar o no, por lo que una forma de modelar el espacio de búsqueda sería formar un número binario de &lt;strong>&lt;em>N&lt;/em>&lt;/strong> dígitosy crear todos los valores posibles para dicho número.&lt;/p>
&lt;p>Para formar todos los números, podemos pensar que en el nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> del árbol vamos a decidir si compramos la tarjeta &lt;strong>&lt;em>j&lt;/em>&lt;/strong>, por lo tanto todos los nodos del nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> tendrán dos hijos, uno de ellos indicando que si compramos la tarjeta y el otro indicando que no la compramos.  El árbol de búsqueda queda como se muestra a continuación.&lt;/p>
&lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_53.webm" type="video/mp4">
&lt;/video>
&lt;p>_**Técnica de búsquda a utilizar: **_Dado que tenemos que entregar como resultado el camino con el mayor puntaje de todos , es preciso que revisemos el 100% de los caminos.  &lt;/p>
&lt;p>Una forma de resolver el problema es utilizar búsqued en profundidad, sin embargo el espacio de búsqueda es un árbol binario con &lt;strong>&lt;em>N&lt;/em>&lt;/strong> niveles por tanto de _**2N **_estados.  Para nuestro problema &lt;strong>&lt;em>N=500&lt;/em>&lt;/strong> por lo que el espacio de búsqueda es indescriptiblemente grande, aunque claro que se pueden podar las ramas en las que el precio ya superó a la cantidad de dinero que tenemos, el aplicar la técnica de búsqueda en profundidad en este problema dificilmente alcanzaría para una **_N _**mayor que 24 ó 25.&lt;/p>
&lt;p>Necesitamos por tanto encontrar una poda mucho más agresiva.&lt;/p>
&lt;p>Anteriormente, en el ejemplo de los Tanques, utilizamos la búsqueda en profundidad para encontrar un camino mínimo, por lo tanto, debido a que cada nivel que descendemos el coste aumenta, se podía aplicar la poda de que si obteniamos algún mínimo se podían cortar todas las ramas cuyo coste fuera mayor o igual que el mínimo actual.  Sin embargo al querer encontrar un máximo, esto no es posible, ya que el coste por rama siempre aumenta y lo que queremos es es encontrar el máximo, así que no sabemos si el camino nos va a llevar a algo mejor a menos que lo recorramos todo!&lt;/p>
&lt;p>Pero que pasaría si tuvieramos una función tal que nos permitiera saber cual es el máximo posible que podemos obtener por una cierta rama?  En ese caso, podríamos cortar cualquier rama si supieramos que por ese camino es imposible lograr algo mejor que lo que ya tenemos.&lt;/p>
&lt;p>Esta técnica se conoce como de &amp;ldquo;acotamiento y poda&amp;rdquo;.  La idea es buscar una función que para cada estado del espacio de búsqueda nos de cotas del máximo posible al que se puede llegar por dicho camino y de mínimo seguro que podemos obtener también por ese camino.&lt;/p>
&lt;p>Esta técnica es increíblemente poderosa y conviene que mediten un momento sobre la misma.  Vale la pena hacer notar que no siempre es sencillo encontrar la función de acotamiento correcta.  Ya que una función que de una cota muy alta no nos sirve de mucho, ya que las podas serian pocas, pero una cota incorrecta nos puede hacer que entreguemos resultados incorrectos.  Por lo tanto al utilizar esta técnica, siempre debemos buscar la función que acote lo más posible pero estando siempre 100% seguros de que el resultado que obtuvimos es efectivamente mayor o igual al máximo posible.&lt;/p>
&lt;p>Para este problema voy a definir las dos funciones de acotamiento, llamemos &lt;strong>&lt;em>a(c)&lt;/em>&lt;/strong> a la función que nos da el máximo posible que se puede obtener estando en el nodo **&lt;em>c&lt;/em>**y &lt;em>&lt;strong>b(c)&lt;/strong>&lt;/em> a la función que nos da el mínimo asegurado que tenemos también al estar en el nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  El demostrar que ambas funciones son válidas queda como tarea para el alumno.&lt;/p>
&lt;p>Lo primero que tenemos que hacer es ordenar las tarjetas de acuerdo a la relación &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong>, es decir, cuantos puntos nos dan por cada peso gastado.  Como queremos obtener el máximo puntaje por nuestro dinero obviamente son mejores las tarjetas que nos dan muchos puntos por peso comparadas con las tarjetas que nos dan pocos puntos por cada peso gastado. &lt;em>&lt;strong>OJO: esto no implica que la solución correcta deba tomar siempre las mejores tarjetas, únicamente quiere decir que comparadas individualmente, para nuestro objetivo son mejores las tarjetas que dan más puntos por peso.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Una vez que tengamos todas las tarjetas ordenadas en base a este criterio, iremos decidiendo si las tomamos o no, en ese respectivo orden.  Para cada nodo, nuestras funciones de acotamiento estarán definidas de la siguiente manera:&lt;/p>
&lt;p>&lt;em>&lt;strong>b(c):&lt;/strong>&lt;/em>  Para calcular la cota mínima asegurada del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong> vamos tomando las tarjetas que aún no hemos utilizado según el ordenamiento mientras aún tengamos dinero, en el momento en el que no tengamos más dinero para comprar ahi nos detenemos.  Ese es el mínimo que seguro podemos obtener.&lt;/p>
&lt;p>_**a(c):  **_Para calcular la cota alta, hacemos el mismo procedimiento que en &lt;strong>&lt;em>b&lt;/em>&lt;/strong> (o mejor tomamos el resultado de &lt;strong>&lt;em>b&lt;/em>&lt;/strong> para no recalcular) y con la primera tarjeta que no pudimos tomamos su relacion &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong> y la multiplicamos por el dinero que aún tenemos disponible y lo sumamos a &lt;strong>&lt;em>b&lt;/em>&lt;/strong>.  Así obtenemos el máximo posible que se puede lograr en el subárbol del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  La operación que efectuamos al final fue la de utilizar el dinero que aún tenemos disponible para comprar un &amp;ldquo;pedazo&amp;rdquo; de la mejor tarjeta aún queda, obviamente esto no es posible ya que no podemos comprar pedazos de tarjeta, sin embargo nos sirve para calcular el máximo posible.  &lt;/p>
&lt;p>Demostrar que &lt;strong>&lt;em>b&lt;/em>&lt;/strong> es válida es trivial, sin embargo queda para el lector demostrar que &lt;strong>&lt;em>a&lt;/em>&lt;/strong> es una cota que siempre dará un número mayor o igual al máximo posible que se puede obtener por ese camino.&lt;/p>
&lt;p>Obviamente una vez que tengamos las funciones de acotamiento, podemos hacer nuestra búsqueda almacenando cual es el mejor mínimo asegurado que hemos obtenido hasta el momento y eliminando todas las ramas cuyo máximo asegurado es menor o igual que éste.&lt;/p>
&lt;p>**_Detalles de implementación: _**Para la implementación queda un último detalle que resolver, y este es como vamos a buscar?  Como casi siempre tenemos dos opciones, la primera es la de la búsqueda en profundidad, para la cual se implementa una rutina recursiva y no se requiere de mantener arreglos de memoria externos.  Y la segunda es una búsqueda por amplitud, para la cual requieres de una cola que te permita almacenar los estados proximos a ser evaluados.&lt;/p>
&lt;p>Si optamos por la búsqueda en profundidad, hay un detalle de implementación muy sútil que puede ser de gran ayuda.  Supongan que modelamos el árbol de búsqueda como el que se muestra en la figura de arriba.  Y supongan que nuestro algoritmo de búsqueda revisa primero la rama izquierda, de ser asi, la cota mínima asegurada y la cota máxima del hijo de la izquierda es exactamente igual a la de su padre, por lo que bajariamos un nivel en la búsqueda sin obtener ninguna información nueva, si, en cambio, revisamos primero el hijo de la derecha, entonces estaríamos obteniendo nuevas cotas con información probablemente últil.&lt;/p>
&lt;p>Si se opta por la búsqueda en amplitud, se tiene una ventaja, y esta es que la cola se puede sustituir por un monticulo de modo que se priorice la búsqueda según el nodo que tiene el mejor mínimo asegurado.  Sin embargo aunque esto podría efectivamente reducir la búsqueda bastante no estamos seguros del tamaño que puede llegar a tener la cola y requeririamos que al llenarse la cola el programa pudiera cambiar a una técnica de búsqueda en profundidad, lo cual haría el código más enredado.  Sin embargo si se desea llegar a límites aún mas grandes, esta sería la opción a seguir.  &lt;/p>
&lt;p>&lt;strong>&lt;em>Implementación:&lt;/em>&lt;/strong>  &lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558998.js">&lt;/script></description></item><item><title>Solución a "Minecraft"</title><link>https://blog.omegaup.com/posts/solucion-a-minecraft/</link><pubDate>Tue, 08 Jan 2013 17:14:15 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-minecraft/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Este problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.&lt;/p>
&lt;h2>Para los primeros 50 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-primeros-50-puntos">&lt;/span>
&lt;a href="#para-los-primeros-50-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.&lt;/p>
&lt;h2>Para los 75 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-75-puntos">&lt;/span>
&lt;a href="#para-los-75-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.&lt;/p>
&lt;h2>Para los 100 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-100-puntos">&lt;/span>
&lt;a href="#para-los-100-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución era para aquellos que supieran hacer una búsqueda utilizando una cola de prioridad. La idea es que al sacar un elemento de la cola siempre nos dé aquel al que se puede llegar con la menor cantidad de movimientos. Este procedimiento es idéntico a una búsqueda en amplitud solo que se utiliza una cola de prioridad. En la solución hago uso de un montículo como cola de prioridad.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559202.js">&lt;/script></description></item><item><title>Solución a "K-Arbol"</title><link>https://blog.omegaup.com/posts/solucion-a-k-arbol/</link><pubDate>Mon, 07 Jan 2013 17:37:40 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-k-arbol/</guid><description>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:lkt345@gmail.com" >Saul de Nova Caballero&lt;/a>&lt;/p>
&lt;p>En pocas palabras el problema es, dado un árbol que se puede colorear, encuentra la menor solución satisfaciendo las restricciones dadas sobre los colores. Este problema es un caso particular de Graph Coloring(en español coloración de grafos), en donde el grafo es un árbol.&lt;/p>
&lt;h1>Subcaso 1(10 puntos)&lt;/h1>&lt;p>Para el primer subcaso era posible hacer una búsqueda en profunidad sobre todos los nodos, encontrando la menor solución. Para guardar el árbol, era posible utilizar una matriz que guardara todos los colores posibles y entonces ver si era posible una solución con el menor color posible. La solución de este caso era trivial si se usaba una búsqueda exhaustiva.&lt;/p>
&lt;h1>Subcaso 2(20 puntos)&lt;/h1>&lt;p>Para el segundo subcaso era necesario una mejor estrategia. Para este caso, era necesaria la observación de que todos los colores de los nodos solo dependen de su padre y de sus hijos. Otra observación importante era que para los nodos del árbol, excepto las hojas, había que procesar a sus hijos menores.Procesar implica checar que colores puede tener un nodo. Por lo que para lograr los puntos en este subcaso era necesario procesar los nodos hijos, luego sus padres y asi sucesivamente. Es decir para procesar, un nodo primero hay que procesar a todos sus hijos.&lt;/p>
&lt;p>La forma de procesar a un nodo es la siguiente. Por cada nodo se compara con su padre y al momento de comparar, lo que se busca es que por cada color del nodo, el padre no tenga un color que lo elimine como opción. Es decir tengo el siguiente caso&lt;/p>
&lt;p>Nodo -&amp;gt; Rojo, Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo, Verde&lt;/p>
&lt;p>Por cada color del nodo, el padre puede elegir un color distinto. Por ejemplo, si el Nodo es Rojo, el padre puede ser Verde. Si el nodo es Verde, el padre puede ser Rojo y si el nodo es Azul, puedes elegir el Rojo o el Verde. Sin embargo, para el siguiente caso&lt;/p>
&lt;p>Nodo -&amp;gt; Rojo, Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo&lt;/p>
&lt;p>El padre del nodo solo puede ser Rojo, por lo que para que las condiciones del problema se cumplan, el Nodo no puede ser Rojo. En este caso actualizamos la tabla de valores posibles del Nodo. Y queda como&lt;/p>
&lt;p>Nodo -&amp;gt; Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo&lt;/p>
&lt;p>Lo anterior se hace para cada par de nodos desde los nodos hoja hasta la raíz. Procesandolos de menor a mayor da la mejor solución&lt;/p>
&lt;h1>Subcaso 3(20 puntos)&lt;/h1>&lt;p>Para obtener los puntos del subcaso 3 era posible simplemente ver por cada nodo procesarlo comenzando en la raíz, ya que en este caso el grafo en basicamente una gran línea. Utilizando la técnica descrita en el subcaso 2 por cada nodo se obtenía una solución a este subcaso&lt;/p>
&lt;h1>Subcaso 4(50 puntos)&lt;/h1>&lt;p>Para los puntos del cuarto caso era necesario &amp;ldquo;linearizar&amp;rdquo; el grafo, esto simplemente significa que los nodos mas arriba van a tener menor prioridad que los nodos de abajo, es decir el nodo raíz tendría valor 0 mientras que sus hijos tendrían valores más altos. Por ejemplo para un caso asi:&lt;/p>
&lt;p>0 -&amp;gt; 1 -&amp;gt; 4&lt;/p>
&lt;p>-&amp;gt; 2&lt;/p>
&lt;p>-&amp;gt; 3&lt;/p>
&lt;p>El nodo 0 es la raíz del árbol, el nodo 1 y 3 son hijos de 0 y los nodos 2 y 4 son hijos de 1, el arbol se linearizaría de la siguiente manera:&lt;/p>
&lt;p>0 -&amp;gt; 1, 1 -&amp;gt; 2, 3 -&amp;gt; 3, 4 -&amp;gt; 4, 2 -&amp;gt; 5&lt;/p>
&lt;p>Ahora lo que es necesario hacer es por cada nodo de mayor prioridad a los de menor prioridad es necesario hacer la técnica explicada en el subcaso 2.Tomando en cuenta otra observación. Que solo es necesario procesar los nodos que solo tengan un color. Es decir si el nodo 0 tiene posibilidad de ser Rojo, Azul o Verde, no es necesario procesarlo. Sin embargo si un nodo solo puede ser azul, hay que eliminar esa posiblidad tanto de su padre como de sus hijos.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/linearizar.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Imagen obtenida de &lt;a href="http://aima.cs.berkeley.edu/newchap05.pdf" target="_blank" rel="noopener">http://aima.cs.berkeley.edu/newchap05.pdf&lt;/a>&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">// karbol100.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#75715e">// By Saul de Nova Caballero
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#75715e">//Librerias de la standard template library de c++(stl)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>algorithm&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">6&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>cassert&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">7&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>cstdio&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>cstdlib&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">9&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>cstring&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">10&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>iostream&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">11&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>list&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">12&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>include &lt;span style="color:#f92672">&amp;lt;&lt;/span>utility&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">13&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">14&lt;/span> &lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">15&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">16&lt;/span> &lt;span style="color:#75715e">//Iterador sobre estructuras de datos. En este caso listas de la stl
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">17&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span>define TR(container, it) &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">18&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(typeof(container.begin()) it &lt;span style="color:#f92672">=&lt;/span> container.begin() ; it &lt;span style="color:#f92672">!=&lt;/span> container.end() ; &lt;span style="color:#f92672">++&lt;/span>it)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">19&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#75715e">//Definicion de un par de la stl
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">21&lt;/span> &lt;span style="color:#66d9ef">typedef&lt;/span> pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> pii;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">23&lt;/span> &lt;span style="color:#75715e">//Constantes del programa
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">24&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MAXN &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10002&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">25&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MAXM &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">502&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">26&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MAXMEM &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>MAXN;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">27&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">28&lt;/span> &lt;span style="color:#75715e">//Clase para definir los hijos del arbol
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">29&lt;/span> &lt;span style="color:#75715e">//Es una lista con todos los hijos de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">30&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Graph&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">31&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">32&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> addNode(&lt;span style="color:#66d9ef">int&lt;/span> node, &lt;span style="color:#66d9ef">int&lt;/span> value) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">33&lt;/span> nodes&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[node&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>].push&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_back(value);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">34&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">35&lt;/span> list&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> nodes&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXN&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">36&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">37&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">38&lt;/span> &lt;span style="color:#75715e">//Clase para cola de las busquedas en amplitud
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">39&lt;/span> &lt;span style="color:#75715e">//Es de tipo generica
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">40&lt;/span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">41&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Queue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">42&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">43&lt;/span> Queue() { init(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">44&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>() { p1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; p2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">45&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>(T val) { memory&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#f92672">++&lt;/span>p1&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> val; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">46&lt;/span> T &lt;span style="color:#a6e22e">front&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> memory&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[p2&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">47&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pop&lt;/span>() { p2&lt;span style="color:#f92672">++&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">48&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">empty&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> (p1 &lt;span style="color:#f92672">&amp;lt;&lt;/span> p2); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">49&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">50&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">51&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> p1, p2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">52&lt;/span> T memory&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXMEM&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">53&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">54&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">55&lt;/span> &lt;span style="color:#75715e">//Definicion de todas las variables del programa
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> N, M, C, &lt;span style="color:#75715e">//Variables dadas
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">57&lt;/span> allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXN&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>], &lt;span style="color:#75715e">//La cantidad de colores posibles por nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">58&lt;/span> parents&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXN&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>], &lt;span style="color:#75715e">//El padre de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">59&lt;/span> colorAssigned&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXN&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]; &lt;span style="color:#75715e">//El color que le asigne al final al nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">60&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> allowedColors&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXN&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[MAXM&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]; &lt;span style="color:#75715e">//Una matriz con todos los colores posibles por cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">61&lt;/span> list&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> nodesOrder; &lt;span style="color:#75715e">//Una lista ordenada de mayor a menor por la profundidad de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">62&lt;/span> Graph tree; &lt;span style="color:#75715e">//Mi arbol
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">63&lt;/span> Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>pii&lt;span style="color:#f92672">&amp;gt;&lt;/span> searchDepth; &lt;span style="color:#75715e">//Una cola para la busqueda
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">64&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">65&lt;/span> &lt;span style="color:#75715e">//Regresa el color valido por cada nodo permitiendo que un nodo no sea de un color
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">66&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> validColor(&lt;span style="color:#66d9ef">int&lt;/span> node, &lt;span style="color:#66d9ef">int&lt;/span> constraint &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">67&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> M; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">68&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(allowedColors&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[node&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[i&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> constraint &lt;span style="color:#f92672">!=&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">69&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">70&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">71&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">72&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">73&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">74&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">75&lt;/span> &lt;span style="color:#75715e">//Funcion para la lectura de todas las variables y la inicializacion de las estructuras
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">76&lt;/span> &lt;span style="color:#75715e">//Los asserts son para probar que el codigo es correcto
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">77&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>Guarda en allowedColors los posibles colores por nodo en una matriz&lt;span style="color:#960050;background-color:#1e0010">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">78&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> read() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">79&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> node, prohibited;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">80&lt;/span> &lt;span style="color:#a6e22e">scanf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>N, &lt;span style="color:#f92672">&amp;amp;&lt;/span>M);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">81&lt;/span> &lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> N &lt;span style="color:#f92672">&amp;lt;=&lt;/span> MAXN&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">82&lt;/span> allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> M;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">83&lt;/span> &lt;span style="color:#a6e22e">memset&lt;/span>(allowedColors, true, &lt;span style="color:#66d9ef">sizeof&lt;/span>(allowedColors));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">84&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">85&lt;/span> &lt;span style="color:#a6e22e">scanf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>node);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">86&lt;/span> &lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> node &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> node &lt;span style="color:#f92672">&amp;lt;&lt;/span> N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">87&lt;/span> parents&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> node;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">88&lt;/span> tree.addNode(node, k);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">89&lt;/span> allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> M;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">90&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">91&lt;/span> &lt;span style="color:#a6e22e">scanf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>C);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">92&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> C; &lt;span style="color:#f92672">++&lt;/span>k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">93&lt;/span> &lt;span style="color:#a6e22e">scanf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>node, &lt;span style="color:#f92672">&amp;amp;&lt;/span>prohibited);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">94&lt;/span> &lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> node &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> node &lt;span style="color:#f92672">&amp;lt;&lt;/span> N &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> prohibited &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> prohibited &lt;span style="color:#f92672">&amp;lt;&lt;/span> M);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">95&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(allowedColors&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[node&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[prohibited&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]) { &lt;span style="color:#75715e">//Checa que los nodos no se repitan ya que se pueden repetir
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">96&lt;/span> allowedColors&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[node&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[prohibited&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">97&lt;/span> allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[node&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">98&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">99&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">100&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">101&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">102&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>Una busqueda en amplitud para &lt;span style="color:#e6db74">&amp;#34;linearizar el árbol&amp;#34;&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">103&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> orderNodes() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">104&lt;/span> searchDepth.push(make&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_pair(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">105&lt;/span> &lt;span style="color:#a6e22e">while&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>searchDepth.empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">106&lt;/span> pii value &lt;span style="color:#f92672">=&lt;/span> searchDepth.front(); searchDepth.pop();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">107&lt;/span> nodesOrder.push&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_front(value.first);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">108&lt;/span> TR(tree.nodes&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[value.first&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>], it) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">109&lt;/span> searchDepth.push(make&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>_pair(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it, value.second &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">110&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">111&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">112&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">113&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">114&lt;/span> &lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>Checa por cada nodo de mayor a menor en la linearizacion, los colores posibles por nodo que solo tiene un color posible&lt;span style="color:#960050;background-color:#1e0010">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">115&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> enforceArc() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">116&lt;/span> &lt;span style="color:#a6e22e">TR&lt;/span>(nodesOrder, it) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">117&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> currNode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">118&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> parent &lt;span style="color:#f92672">=&lt;/span> parents&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">119&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(currNode &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">120&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[currNode&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[parent&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">121&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[parent&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">122&lt;/span> swap(currNode, parent);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">123&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">124&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> color &lt;span style="color:#f92672">=&lt;/span> validColor(currNode);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">125&lt;/span> &lt;span style="color:#75715e">//printf(&amp;#34;%d %d %d\\n&amp;#34;, currNode, parent, color);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">126&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(allowedColors&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[parent&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[color&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">127&lt;/span> allowedColors&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[parent&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[color&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">128&lt;/span> allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[parent&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">129&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">130&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">131&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">132&lt;/span> &lt;span style="color:#75715e">//Si no hay colores posibles, no se puede resolver el mapa
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">133&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[currNode&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">134&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">n&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">135&lt;/span> exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">136&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">137&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">138&lt;/span> &lt;span style="color:#75715e">//Checa de nuevo si alguno de los colores no puede ser
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">139&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">140&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(allowedColorsSize&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">141&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;-1&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">n&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">142&lt;/span> exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">143&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">144&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">145&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">146&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">147&lt;/span> &lt;span style="color:#75715e">//Hace un ciclo checando el menor color posible por nodo e imprime los colores menores
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#ae81ff">148&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> findSolution() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">149&lt;/span> colorAssigned&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">150&lt;/span> list&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>iterator it &lt;span style="color:#f92672">=&lt;/span> nodesOrder.end();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">151&lt;/span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">152&lt;/span> it &lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">153&lt;/span> &lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it &lt;span style="color:#f92672">&amp;lt;&lt;/span> N);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">154&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> color &lt;span style="color:#f92672">=&lt;/span> validColor(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">155&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(colorAssigned&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[parents&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> color) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">156&lt;/span> color &lt;span style="color:#f92672">=&lt;/span> validColor(&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it, color);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">157&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">158&lt;/span> &lt;span style="color:#a6e22e">assert&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> color &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> color &lt;span style="color:#f92672">&amp;lt;&lt;/span> M);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">159&lt;/span> colorAssigned&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>&lt;span style="color:#f92672">*&lt;/span>it&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> color;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">160&lt;/span> } &lt;span style="color:#66d9ef">while&lt;/span>(it &lt;span style="color:#f92672">!=&lt;/span> nodesOrder.begin()) ;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">161&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">162&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; k &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>k) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">163&lt;/span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">n&amp;#34;&lt;/span>, colorAssigned&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>[k&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">164&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">165&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">166&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">167&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">168&lt;/span> read();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">169&lt;/span> orderNodes();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">170&lt;/span> enforceArc();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">171&lt;/span> findSolution();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">172&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">173&lt;/span> }&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copy code"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item></channel></rss>