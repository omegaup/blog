<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 6</title><link>https://blog.omegaup.com/tags/examen-6/</link><description>Recent content in Examen 6 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 23 Jan 2014 03:51:39 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-6/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Químicos"</title><link>https://blog.omegaup.com/solution/solucion-a-quimicos/</link><pubDate>Thu, 23 Jan 2014 03:51:39 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-quimicos/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P6#problems/quimicos" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 6&lt;/a> &lt;strong>Autor:&lt;/strong>  &lt;a href="http://lhchavez.com/" target="_blank" rel="noopener">Luis Héctor Chávez (lhchavez)&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Éste es un problema que tiene una solución elegante y determinística pero requiere algoritmos avanzados bastante complicados. Lo bueno es que es posible aproximar a la solución utilizando fuerza bruta mediante backtracking.&lt;/p>
&lt;p>El problema nos pide encontrar una manera de asignar sustancias a los tubos y después mezclarlas con las dos operaciones disponibles (suma y diferencia absoluta) para terminar con un acomodo homogéneo de sustancias: la diferencia entre el tubo con más cantidad y con menos cantidad de sustancia debe ser lo más pequeña posible. Una manera de hacerlo es proponer un intervalo $latex [a,b]$ y ver si es posible asignar sustancias y aparear los tubos de manera que la cantidad de sustancia resultante de la mezcla en todos los tubos esté contenido dentro del intervalo. Para acelerar el proceso, puedes elegir los intervalos haciendo una búsqueda binaria de acuerdo a su ancho $latex b-a$, porque a fin de cuentas lo que nos pide el problema es precisamente el ancho mínimo. Para cada intervalo propuesto $latex [a,b]$, podemos hacer un grafo con $latex 2N$ nodos (uno para cada tubo), agregando un arco entre dos nodos $latex A$ y $latex B$ si $latex A+B\in[a,b]$ ó $latex |A-B|\in[a,b]$. Después, buscamos un &lt;a href="http://es.wikipedia.org/wiki/Apareamiento_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">apareamiento máximo&lt;/a> en el grafo: buscamos el conjunto de arcos con cardinalidad máxima tal que cada nodo tenga a lo más un arco incidente. Esto se puede encontrar con el &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Emparejamiento_de_Edmonds" target="_blank" rel="noopener">algoritmo de Edmonds&lt;/a> (también conocido como el Blossom algorithm por la forma de los ciclos de longitud impar) en tiempo $latex O(|2N|^4)$, lo cual encontraría todas las soluciones en solo un par de segundos.&lt;/p>
&lt;p>Lamentablemente la implementación del algoritmo de Edmonds es bastante complicada. Como este es un problema de solo-salida y todo se vale, en vez de hacer el intento por implementarlo, utilicé la librería &lt;a href="http://www.boost.org/" target="_blank" rel="noopener">Boost&lt;/a> de C++ que ya tiene muchísimos algoritmos de &lt;a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html" target="_blank" rel="noopener">grafos&lt;/a> ya implementados.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572476.js">&lt;/script>
&lt;p>Ahora, si no se te ocurre usar el algoritmo de Edmonds o no tienes acceso a Boost, aún así puedes obtener una cantidad decente de puntos usando una heurística: podemos &lt;em>intentar&lt;/em> hacer un apareamiento máximo usando fuerza bruta, rindiéndonos si el problema suena muy complicado y asumimos que no existe un apareamiento. Una fuerza bruta naïve con un contador que se decrementa cada vez que se llama la función de búsqueda es más que suficiente. Haciendo un par de modificaciones al algoritmo anterior nos da una solución que nos da el 80% de los casos bien:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572478.js">&lt;/script>
&lt;p>Claro que si te quieres ver greedy, puedes subirle al número de intentos, pero posiblemente no haya suficiente tiempo en el concurso para que termine. Si llegas a utilizar estas técnicas &amp;ldquo;impuras&amp;rdquo;, asegúrate primero de obtener cualquier solución que te de puntos antes de subirle para encontrar mejores respuestas.&lt;/p></description></item><item><title>Solución a "Super Nieves Bros"</title><link>https://blog.omegaup.com/solution/solucion-a-super-nieves-bros/</link><pubDate>Mon, 30 Sep 2013 15:54:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-super-nieves-bros/</guid><description>
&lt;p>**Concurso: **&lt;a href="https://omegaup.com/arena/IOI2014E1P6" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 6&lt;/a> &lt;strong>Fuente&lt;/strong>: Topcoder&lt;/p>
&lt;p>Este problema es una adaptación del problema &lt;a href="http://community.topcoder.com/stat?c=problem_statement&amp;amp;pm=12504&amp;amp;rd=15496" target="_blank" rel="noopener">ArcadeManao&lt;/a> que apareció en el SRM 576 (Abril 2013) de Topcoder. Los detalles de la solución explicada la pueden en el respectivo &lt;a href="http://apps.topcoder.com/wiki/display/tc/SRM&amp;#43;576" target="_blank" rel="noopener">Match Summary&lt;/a>.&lt;/p>
&lt;p>La idea general de este problema es muy sencilla: En base a los límites, la primera observación es que el mapa no es muy grande y en el peor caso, la escalera más alta es de tamaño 50. Hay que notar que no nos piden la ruta más corta para capturar la moneda, más bien cuál es el menor tamaño con el que podemos llegar.&lt;/p>
&lt;p>La idea principal es ir probando los tamaños de escalera, empezando desde 0 hasta 50, y para cada tamaño probar si es posible llegar a la moneda o no. Si empezamos probando los tamaños de menor a mayor, la primer escalera que lo logré será el resultado.&lt;/p>
&lt;p>Para probar que se puede llegar a la moneda, se puede usar búsqueda en amplitud o búsqueda en profundidad. Dado que el tamaño del mapa es relativamente pequeño, es posible usar búsqueda en profundidad y pararla en cuanto &amp;ldquo;pisemos&amp;rdquo; la moneda (de nuevo, no nos interesa saber si la ruta que la búsqueda siguió para dar con la moneda fue la menor de todas las posibles, con llegar a ella basta).&lt;/p>
&lt;p>Este par de observaciones son suficiente para resolver el problema. Si el lector quiere más reto, hay otra observación que permitiría reducir el número de búsquedas que hay que hacer de 50 a 6&amp;hellip;&lt;/p>
&lt;p>Esta es la solución de &lt;a href="https://omegaup.com/profile/charlyhlms" target="_blank" rel="noopener">charlyhlms&lt;/a> usando búsqueda en profundidad.&lt;/p>
&lt;script src="https://gist.github.com/joemmanuel/6765773.js">&lt;/script>
&lt;p>Esta es la solución de &lt;a href="https://omegaup.com/profile/spleensarethebest" target="_blank" rel="noopener">spleensarethebest&lt;/a> usando búsqueda en amplitud y optimizando la cantidad de pruebas de tamaños de escaleras que hay que hacer.&lt;/p>
&lt;script src="https://gist.github.com/joemmanuel/6765853.js">&lt;/script></description></item></channel></rss>