<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Examen 7 on omegaUp blog</title><link>https://blog.omegaup.com/tags/examen-7/</link><description>Recent content in Examen 7 on omegaUp blog</description><generator>Hugo</generator><language>es-mx</language><lastBuildDate>Tue, 08 Jan 2013 17:18:25 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-7/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Cambio"</title><link>https://blog.omegaup.com/solucion-a-cambio/</link><pubDate>Tue, 08 Jan 2013 17:18:25 +0000</pubDate><guid>https://blog.omegaup.com/solucion-a-cambio/</guid><description>&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me">Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Lo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.&lt;/p>
&lt;h2 id="solución-de-30-50-puntos">Solución de 30, 50 puntos&lt;/h2>
&lt;p>Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.&lt;/p></description></item><item><title>Solución a "Alfiles"</title><link>https://blog.omegaup.com/solucion-a-alfiles/</link><pubDate>Mon, 07 Jan 2013 16:23:49 +0000</pubDate><guid>https://blog.omegaup.com/solucion-a-alfiles/</guid><description>&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com">Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Lo primero que se debe de notar es que en cada una de las $latex 2n-1$ diagonales principales, las cuales mostradas en la imagen de abajo, habrá máximo 1 alfil. Lo mismo se cumple para las diagonales invertidas, mostradas también en una imagen abajo.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic1.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic2.png" alt="">&lt;/p>
&lt;p>Ahora, cada diagonal principal se cruza con ciertas diagonales invertidas. Entonces se plantea una solución de tipo &lt;em>Backtracking&lt;/em> que corre sobre las diagonales principales marcando diagonales invertidas a cada paso (representando que se ha colocado un alfil en el cruce de esas dos diagonales).&lt;/p></description></item></channel></rss>