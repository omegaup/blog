<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Examen 8</title><link>https://blog.omegaup.com/tags/examen-8/</link><description>Recent content in Examen 8 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Fri, 17 Jan 2014 02:14:47 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/examen-8/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución alternativa a "Decepción"</title><link>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</link><pubDate>Fri, 17 Jan 2014 02:14:47 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P8#problems/decepcion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Esta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $latex O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.&lt;/p>
&lt;p>Podemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $latex f(n,m)$ cuenta de cuántas maneras se pueden poner $latex n$ torres de tal manera de que sólo $latex m$ se pueden ver de un lado, la respuesta que queremos es $latex \sum_{i=0}^{N-1} ({N-1 \choose i} * f(i,F-1) * f(N-i-1,B-1))$.&lt;/p>
&lt;p>En otras palabras, esta expresión es la suma de las maneras de cumplir las condiciones originales del problema colocando la torre más alta en la posición $latex i$. Es decir, hay $latex {N-1 \choose i}$ maneras de distribuir el resto de las torres a la izquierda o derecha de la torre más alta (porque la única cosa que importa es el orden relativo de las torres y todas las alturas son distintas), las cuales multiplicamos por las maneras de hacer que se cumpla la condición sobre el lado izquierdo y lo mismo con el lado derecho.&lt;/p>
&lt;p>Ahora, para computar $latex f$, podemos reusar la misma observación. Cuando colocamos la torre más alta en el índice $latex i$, cualquier torre que pongamos después de $latex i$ ya no se podrá ver. Del lado visible, necesitamos reordenar las torres restantes de tal manera que sólo se puedan ver $latex m-1$. Además, podemos reordenar el lado oculto de la manera que queramos. Con esto tenemos que&lt;/p>
&lt;p>$latex f(0,0) = 1$ $latex f(n,m) = \begin{cases} 0 &amp;amp; \text{si } m &amp;gt; n\\ \sum_{i=0}^{n-1}({n-1 \choose i} * f(i,m-1) * (n-i-1)!) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>con lo que resolvemos el problema en tiempo $latex O(N^3)$ y memoria $latex O(N^2)$.&lt;/p>
&lt;p>Esto se puede mejorar aún más observando que $latex f(n,m)$ está computando los números de Stirling de primera clase, para los cuales hay una recurrencia que se puede utilizar para calcularlos en tiempo $latex O(N^2)$.&lt;/p>
&lt;p>Los números de Stirling de primera clase cuentan las permutaciones de $latex n$ elementos con $latex m$ ciclos. Considere una permutación con $latex m$ ciclos de los $latex n$ edificios. Cada ciclo debe tener un elemento máximo. Además podemos ordenar los ciclos entre sí por su elemento mayor. De esta manera, tenemos $latex m$ edificios visibles. Ya que estamos contando todas las permutaciones con $latex m$ ciclos, cada posible ordenamiento con $latex m$ edificios visibles será considerada. Esto se debe a que cada ciclo tiene únicamente un ordenamiento en el cual sólo uno de sus elementos es visible: el que comienza con el edificio más grande.&lt;/p>
&lt;p>Aquí está el código que implementa esta solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8467347.js">&lt;/script></description></item><item><title>Solución a "Ubongo 3D"</title><link>https://blog.omegaup.com/solution/solucion-a-ubongo-3d/</link><pubDate>Sat, 14 Sep 2013 05:04:59 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-ubongo-3d/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/ubongo-3d" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente:&lt;/strong> Miguel Covarrubias&lt;/p>
&lt;p>La solución pone piezas de manera recursiva mientras quepan en el tablero y no se empalmen.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">P&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">regresa&lt;/span> &lt;span class="err">“&lt;/span>&lt;span class="n">Si&lt;/span>&lt;span class="err">”&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">rotación&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">casilla&lt;/span> &lt;span class="n">g&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">cubo&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">al&lt;/span> &lt;span class="n">poner&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">sobre&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">queda&lt;/span> &lt;span class="n">dentro&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">primeros&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="n">niveles&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">empalma&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">otra&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">ya&lt;/span> &lt;span class="n">puesta&lt;/span> &lt;span class="n">entonces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">marca&lt;/span> &lt;span class="n">las&lt;/span> &lt;span class="n">posiciones&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">como&lt;/span> &lt;span class="n">ocupados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">desmarca&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Para rotar una pieza se puede rotar por $latex 0^o$, $latex 90^o$, $latex 180^o$ o $latex 270^o$ alrededor de cada eje. El número de operaciones es aproximadamente (número de rotaciones * número de casillas del tablero * número de cubos de una pieza)$latex ^3 \le (24 * 7 * 5)^3 &amp;lt; 600,000,000$. En los casos de prueba y en el juego todas las soluciones tocan la base del tablero, si no fuera así, solo hay que duplicar el 7 a 14. Para checar si una pieza se puede poner en cierta posición se pueden usar mascaras de bits para los niveles del tablero y para las posiciones ocupadas. Para poner la última pieza se puede comparar todas las rotaciones de los cubos no ocupados contra la última pieza y la complejidad cubica de la solución se reduce a cuadrática.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558928.js">&lt;/script></description></item><item><title>Solución a "Bloqueo"</title><link>https://blog.omegaup.com/solution/solucion-a-bloqueo/</link><pubDate>Tue, 10 Sep 2013 19:35:59 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-bloqueo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/bloqueo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.cimat.mx/~omar" target="_blank" rel="noopener">Khayyam&lt;/a> &lt;strong>Fuente&lt;/strong>: Khayyam&lt;/p>
&lt;p>La primera observación que hay que hacer es que si todas las carreteras son bidireccionales y entre cada par de ciudades existe exactamente un camino que las conecta (usando una o mas carreteras) entonces la representación gráfica del problema es un árbol: los nodos representan las ciudades y las aristas representan las carreteras. La siguiente figura, muestra el árbol que representa el caso de prueba dado como ejemplo. Los nodos rojos representan las ciudades ocupadas, el esfuerzo necesario para destruir cada carretera se muestra junto a la arista correspondiente. Entonces queremos eliminar un subconjunto de aristas de peso total mínimo de tal forma que los nodos rojos queden separados.&lt;/p>
&lt;p>Caso de ejemplo&lt;/p>
&lt;p>Solución&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example_solution.png" alt="" loading="lazy" />&lt;/p>
&lt;p>En problemas relacionados con árboles, es muy natural tratar de dividir el problema en problemas más pequeños que están dados por los sub-árboles del árbol original. Esto además sugiere usar recursión: &amp;ldquo;para resolver un árbol, primero resolvemos recursivamente sus sub-árboles y luego combinamos las sub-soluciones&amp;rdquo;.&lt;/p>
&lt;p>Comencemos con los casos sencillos. Si hay solamente un nodo (el árbol tiene altura 0), entonces no habrá aristas y el esfuerzo total necesario es cero.&lt;/p>
&lt;p>Consideremos ahora un árbol de altura 1 como el de la siguiente figura. Como la raiz no es roja, basta con eliminar una de las dos aristas: elegimos la que requiera menos esfuerzo.&lt;/p>
&lt;p>Caso sencillo: altura 1&lt;/p>
&lt;p>Solución (suponemos que la arista izquierda requiere menos esfuerzo)&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple0.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple1.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Si la raiz fuera roja, entonces tendríamos que eliminar ambas aristas. Con lo anterior nos damos cuenta de que hay dos casos que debemos considerar:&lt;/p>
&lt;ol>
&lt;li>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/li>
&lt;li>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos: la solución óptima es dejar conectado el nodo rojo asociado a la arista mas costosa.&lt;/li>
&lt;/ol>
&lt;p>Lo anterior se ilustra en la siguiente figura (aquí suponemos que la arista de la derecha es la mas costosa de todas):&lt;/p>
&lt;p>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/p>
&lt;p>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora que tenemos la solución para los casos pequeños, veamos si podemos usar estas soluciones para construir la solución del problema general, como en la siguiente figura.&lt;/p>
&lt;p>Si la raiz es roja y el nodo blanco está conectado&lt;br>
a algun descendiente rojo, la solución ya no es correcta&lt;/p>
&lt;p>Aún si la raiz es blanca, no podemos dejar conectado el nodo blanco&lt;br>
ya que si está conectado con un descendiente rojo, la solución sería incorrecta&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Supongamos que ya tenemos la solución para todos los hijos directos de la raíz, es decir, que ya cortamos de manera óptima las aristas de todos los subárboles, de modo que ningún par de nodos rojos se conectan en el sub-árbol. Usando sólo esta información, ¿podemos construir la solución del problema general?. Desafortunadamente, esto no es suficiente: nos gustaría dejar conectados a los hijos blancos, pero si existe un nodo rojo debajo de ellos, entonces tendríamos que desconectarlo también. Lo que necesitamos saber es precisamente si un hijo blanco está conectado con uno de sus descendientes rojos, de ser así diremos que el nodo blanco es &amp;ldquo;peligroso&amp;rdquo;. Si el nodo blanco está desconectado de todos sus descendientes rojos, entonces diremos que es &amp;ldquo;seguro&amp;rdquo;. Entonces tenemos tres tipos de nodos: ocupados, peligrosos y seguros, que representamos como nodos rojos, amarillos y verdes, respectivamente.Con este nuevo concepto, vemos que tenemos dos tipos de soluciones distintas para una raíz blanca: tenemos soluciones peligrosas y soluciones seguras. Es fácil ver que no existen &amp;ldquo;hojas peligrosas&amp;rdquo;, ya que las hojas están ocupadas (rojas) o son seguras (verdes).&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootOneGreen.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/yellowRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/greenRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Reformulemos nuestra solución con este concepto. Si la raíz es roja, entonces debemos desconectarla de todos sus hijos rojos y de todos sus hijos peligrosos. Esto significa que para cada hijo blanco tenemos dos opciones:&lt;/p>
&lt;ul>
&lt;li>Hacer que el hijo sea seguro (verde) y no cortar la arista que lo une con la raíz (puede ser costoso hacerlo seguro, pero con eso nos ahorramos el costo de separarlo de la raíz)&lt;/li>
&lt;li>Hacer que el hijo sea peligroso (amarillo) y cortar la arista que lo une con la raíz (puede ser barato dejarlo inseguro, pero pagamos al separarlo de la raíz)&lt;/li>
&lt;/ul>
&lt;p>Lo anterior resuelve el caso en que la raíz es roja.&lt;/p>
&lt;p>Ahora, si la raíz no es roja, debemos calcular dos soluciones: la solución segura (dejar la raíz verde) y la solución peligrosa (dejar la raíz amarilla). Notemos que la solución segura es exactamente igual al caso anterior. Por otro lado, para la solución peligrosa, debemos dejar la raíz conectada a exactamente un hijo que sea rojo o peligroso. Para elegir cuál de todos los hijos rojos o peligrosos dejaremos conectado, basta iterar sobre todos los hijos y elegir la mejor opción. El código queda como sigue:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559253.js">&lt;/script></description></item><item><title>Solución a "Los Bloques de Link"</title><link>https://blog.omegaup.com/solution/solucion-a-los-bloques-de-link/</link><pubDate>Mon, 07 Jan 2013 16:54:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-los-bloques-de-link/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Es claro que no es posible probar todas las sucesiones posibles de movimientos de los bloques para encontrar la solución (a excepción de casos muy simples). El número de tales sucesiones puede ser infinito en caso de que se puedan formar ciclos de movimientos (lo cual sucede en muchos de lo casos de prueba), y aún en casos donde el número sea finito puede suceder que no se tenga tiempo para probarlos todos.&lt;/p>
&lt;p>Una primera observación crucial es que, en el estado del mapa, solo nos interesa saber donde están los bloques de hielo en cada paso, es decir, su ubicación es lo que determina lo que nos interesa del estado. No nos interesan los pasos previos que los llevaron a su posición, solo que sea el número mínimo posible. Tenemos un problema que puede ser resuelto realizando una búsqueda en amplitud.&lt;/p>
&lt;p>¿Cuántos estados es posible alcanzar? El mapa es a lo más de 40x40 espacios y las orillas siempre están bloqueadas, así que realmente tenemos 38x38=1444 espacios a los que quizá es posible llevar a los bloques. Tenemos dos bloques de hielo, así que hay (1444x1443)/2=1,041,846 formas de colocarlos en el mapa (hemos considerado aquí ya el hecho de que son indistinguibles). Para fines de la búsqueda el número que hemos calculado es en realidad una cota superior muy mala (mala en el sentido de que la cota superior mínima es muy inferior, es decir, calculamos “de más”), pues por la forma en que se mueven los bloques es claro que aún en el peor de los casos posibles la cantidad de estados a los que se puede acceder es mucho menor (¿cuál es el peor de los casos?). Es posible entonces emplear una búsqueda en amplitud común para resolver el problema, el espacio de búsqueda no es muy grande y es claro que podemos recorrerlo por completo.&lt;/p>
&lt;p>Para representar los estados requerimos tener la posición de ambos bloques, y nada más. Podemos emplear una arreglo de bool&amp;rsquo;s (boolean&amp;rsquo;s en pascal) de cuatro dimensiones para marcar los estados a los que se ha accedido. Para la cola, en el código que se anexa más abajo, empleamos un arreglo de dos dimensiones (una matriz) donde además de guardar la posición de los bloques de los estados guardamos la cantidad de movimientos realizados para llegar a cada estado. Para ver a que estados podemos llegar desde un estado dado basta con ver en que direcciones es posible mover los bloques y a qué posición llegarán.&lt;/p>
&lt;p>Para optimizar la búsqueda podemos hacer dos observaciones. La primera es que con nuestra representación de los estados podríamos llegar dos veces al mismo estado, ya que los dos bloques de hielo son para nuestros fines iguales. En el código de abajo es por ello que al llegar a un estado nuevo se marcan dos valores en el arreglo de bools como verdaderos, pues ambos representan en realidad el mismo estado.&lt;/p>
&lt;p>Otra observación es que para averiguar eficientemente a que estados se puede llegar desde un estado dado podemos precalcular, antes de realizar la búsqueda, para cada espacio vacío o con bloque de hielo, cuál es la posición del espacio bloqueado (con numeral # o con el botón A) más cercano en cada dirección. Así solo habrá que comparar esa posición con la del otro bloque de hielo para ver a dónde llegará el bloque tras su movimiento. Esto puede mejorar el tiempo de ejecución para un caso dado, aunque no siempre es así. En este problema para obtener los 100 puntos no hacen falta optimizaciones de este tipo, aunque es bueno tener este tipo de ideas en mente para problemas más complejos.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559163.js">&lt;/script></description></item><item><title>Solución a "Mario Reloaded"</title><link>https://blog.omegaup.com/solution/solucion-a-mario-reloaded/</link><pubDate>Mon, 07 Jan 2013 16:08:32 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mario-reloaded/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:paspartu@gmail.com" >Pavel Herrera Dominguez&lt;/a>)&lt;/p>
&lt;h2>Observaciones&lt;span class="hx-absolute -hx-mt-20" id="observaciones">&lt;/span>
&lt;a href="#observaciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Lo primero es ver como se modelan los estados del problema sin pensar en que Mario puede tomar los atajos, únicamente pensar en las llaves, claramente existen $latex n\times2^m$ estados, pues no importa el orden en que se toman las llaves solo las llaves que se tienen al llegar a cada puerta. A partir de aquí nos referiremos como estado a la puerta y las llaves que trae Mario.&lt;/p>
&lt;p>La segunda observación es ver como afecta llegar a una puerta con cierto juego de llaves, osea a cada estado. Cada vez que visitamos un estado todos los estados ya visitados que tienen el mismo juego de llaves se actualiza instantáneamente. Esto se puede entender como si únicamente el juego de llaves definiera el estado, lo que nos lleva a pensar que el problema es saber que puertas pertenecen a qué juego de llaves.&lt;/p>
&lt;p>De la observación anterior podemos pensar que si mantenemos una lista de puertas ya visitadas para cada juego de llaves, cuando algún estado (puerta, juego de llaves) se visita con un menor tiempo, todas las puertas alcanzadas con ese juego de llaves deben ser actualizadas y sus respectivos vecinos.&lt;/p>
&lt;h2>Idea&lt;span class="hx-absolute -hx-mt-20" id="idea">&lt;/span>
&lt;a href="#idea" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>La idea es hacer una especie de búsqueda en amplitud la cual tome en cuenta las observaciones anteriores. Esto es una búsqueda que visite los estados (puerta, llave) y conserve una lista de las puertas alcanzables con cada juego de llaves.&lt;/p>
&lt;h2>Implementacion&lt;span class="hx-absolute -hx-mt-20" id="implementacion">&lt;/span>
&lt;a href="#implementacion" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559138.js">&lt;/script>
&lt;h2>Tarea&lt;span class="hx-absolute -hx-mt-20" id="tarea">&lt;/span>
&lt;a href="#tarea" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Pensar si es posible hacer la búsqueda sin usar los estados (puerta, juego de llaves).&lt;/p></description></item></channel></rss>