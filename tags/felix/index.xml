<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Felix</title><link>https://blog.omegaup.com/tags/felix/</link><description>Recent content in Felix on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 02 Mar 2017 06:29:09 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/felix/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Los Callejones de Guanajuato"</title><link>https://blog.omegaup.com/solution/solucion-a-los-callejones-de-guanajuato/</link><pubDate>Thu, 02 Mar 2017 06:29:09 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-los-callejones-de-guanajuato/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/callejones/" target="_blank" rel="noopener">Los Callejones de Guanajuato&lt;/a>.&lt;/p>
&lt;p>En este problema se nos está pidiendo que, dado &lt;a href="https://es.wikipedia.org/wiki/Grafo_conexo" target="_blank" rel="noopener">un grafo conexo no dirigido&lt;/a>, encontrar un &lt;a href="https://es.wikipedia.org/wiki/Camino_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">camino&lt;/a> tal que pasemos por todas las aristas.&lt;/p>
&lt;p>Esta es una aplicación directa de un problema conocido de grafos, aunque no es tan común como otros problemas, estoy hablando de los &lt;a href="https://es.wikipedia.org/wiki/Ciclo_euleriano" target="_blank" rel="noopener">ciclos Eulerianos&lt;/a>.&lt;/p>
&lt;p>La teoría nos dice que un grafo tendrá un camino euleriano si y sólo sí el &lt;a href="https://es.wikipedia.org/wiki/Grado_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">grado&lt;/a> de todos sus nodos menos dos es par; es decir, solo dos de sus nodos tienen un número impar de aristas saliendo de él, mientras que todos los demás tienen un número par de aristas.&lt;/p>
&lt;p>Esto es fácil de imaginar si nos ponemos a pensar que todo camino que entre a un nodo por una arista debe de tener otra arista por donde salir, a excepción claro del nodo inicial y el nodo final, que sólamente interactúan con el camino una vez.&lt;/p>
&lt;p>Es posible visitar un nodo más de una vez, pero por cada vez que entremos, tenemos que salir una vez, manteniendo su grado par. También es posible visitar el nodo inicio y fin más de una vez, pero por cada vez extra que entremos a estos nodos, tendremos que salir, manteniendo su grado impar.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/cKkd6nh.png" alt="" loading="lazy" />&lt;/p>
&lt;p>También es posible crear un ciclo euleriano (que a diferencia de un camino, empieza y termina en el mismo nodo) si todos los nodos del grafo tienen grado par.&lt;/p>
&lt;p>De nuevo imaginemos un poco: en un grafo con un ciclo de euler podemos agregar una arista más entre nodo inicio y fin; ahora todos los nodos tienen grado par, y el camino de euler se volvió un ciclo.&lt;/p>
&lt;p>En ningún otro caso se puede formar un camino o ciclo de eurler. En los grafos siguientes, se puede apreciar que cada uno tiene más de dos nodos con un grado impar y por lo tanto, no habrá ningún camino o ciclo de euler, no importa cuanto lo intentes.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/o7OKuIc.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Lo primero que viene a mente luego de leer esta teroría es que aunque es trivial saber si existe o no camino, ¿cómo lo vamos a encontrar si un grafo tiene ciclos? ¿cómo saber qué arista tomar para que al llegar al nodo final, hayamos pasado por todos?&lt;/p>
&lt;p>Veremos que este algoritmo es también muy fácil.&lt;/p>
&lt;p>Imaginemos el siguiente grafo, en forma de casita, que es muy popular para este problema, tan popular, que hasta en las primarias se ve (aunque claro, a esa edad no se nos decía lo que estábamos haciendo).&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/0VQqGVK.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Lo primero que hay que hacer es, usando un algoritmo de &lt;a href="https://es.wikipedia.org/wiki/B%C3%BAsqueda_en_profundidad" target="_blank" rel="noopener">búsqueda en profundidad&lt;/a>, encontramos un camino, el que sea, entre los nodos inicio y fin, se pueden repetir nodos, pero no aristas.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/b8wtLgL.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora, si todos las aristas ya fueron visitadas, entonces ya terminamos, pero si no es así (lo cual es lo más probable), hay que buscar un nodo cualquiera, dentro del camino.&lt;/p>
&lt;p>Siempre que haya un nodo sin visitar, este va a tener al menos dos aristas disponibles (pues ya se explicó que siempre tendrán grado par), por lo tanto, ahora hay que hacer una segunda búsqueda, esta vez empezando desde el nodo con aristas disponibles, sin pasar por una arista que ya hemos visitado.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/C8l96lD.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Si el grafo tiene un camino de Euler, eventualmente vamos a regresar al nodo del que partimos. Siempre. Esto es verdad debido a que, como no nos quedan aristas con grado impar, una de las aristas en ese nodo debe de formar un ciclo con otra de las aristas que salen de ese nodo. Si no hubiera ciclo sería porque el camino termina abruptamente en un nodo, lo cual sería imposible porque esto significaría que ese nodo al final tendría grado impar, y ya usamos nuestros dos nodos impar.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/r9rDfW3.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Si seguimos este algoritmo para todos los nodos que aún tengan aristas sin visitar, eventualmente visitaremos todas, lo único que hay que hacer ahora es tomar las aristas en el orden correcto para hacer las llamadas a la función.&lt;/p>
&lt;p>En el caso en que todos los nodos tengan grado par, se sigue exactamente el mismo algoritmo, con la diferencia de que el nodo inicio y el nodo fin son el mismo.&lt;/p>
&lt;p>Como nota cultural, existe un problema similar, el cual en vez de visitar todos las aristas, te pide visitar todos los nodos. Este problema se llama &lt;a href="https://es.wikipedia.org/wiki/Camino_hamiltoniano" target="_blank" rel="noopener">Camino Hamiltoniano&lt;/a>, y a diferencia de el camino de euler, este problema es &lt;a href="https://es.wikipedia.org/wiki/NP-completo" target="_blank" rel="noopener">NP completo&lt;/a>,  lo cual significa que no existe una solución que resuelva el problema en tiempo polinomial.&lt;/p></description></item><item><title>Solución a "Splatoon"</title><link>https://blog.omegaup.com/solution/solucion-a-splatoon/</link><pubDate>Mon, 05 Oct 2015 08:20:43 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-splatoon/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/splatoon/" target="_blank" rel="noopener">Splatoon&lt;/a>.&lt;/p>
&lt;p>Este problema pide llevar a un inkling desde el inicio de una calle hasta el final siguiendo sus reglas de movimiento.&lt;/p>
&lt;p>Ignoremos por un momento el hecho de que los inklings pueden pintar el piso y con ello alterar la calle en donde se realiza la carrera. Si los inklings no tuvieran esta habilidad, se puede hacer un algoritmo de fuerza bruta intentando todas las operaciones posibles, es decir, hacer una búsqueda en amplitud para encontrar el camino más corto, en donde el estado está representado únicamente por la posición en donde se encuentre el inkling.&lt;/p>
&lt;p>&lt;strong>Recuerda que en las búsquedas es importante marcar visitados para que la complejidad del algoritmo no se vuelva exponencial.&lt;/strong>&lt;/p>
&lt;p>Para cada posición, se tienen dos posibles operaciones, saltar, o caminar, ambas toman 1 segundo y la distancia a la que se llega depende directamente del color sobre el que se está parado. El movimiento de saltar es muy fácil pues solo hay una casilla donde se puede caer, pero el movimiento de avanzar difiere cada vez pues depende directamente del color de las siguientes casillas.&lt;/p>
&lt;p>Es posible hacer un ciclo para ver hasta donde puedes llegar avanzando desde la casilla en donde estás, y agregar a la búsqueda el lugar más lejano a donde puedas llegar. Sin embargo, si únicamente registramos la última casilla a donde se puede llegar, casos como el siguiente se nos escaparán:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/t1iBoPQ.png" alt="" loading="lazy" />&lt;/p>
&lt;p>En la solución superior, primero se avanza todo lo que se puede en la pintura naranja hasta llegar a la casilla azul, de ahi ya sea saltando o avanzando únicamente se puede llegar a la casilla blanca, y de ahí, no importa lo que hagas, te tomará dos segundos llegar al final.&lt;/p>
&lt;p>En cambio, en la solución inferior, se avanza solo 3 casillas en la pintura naranja, lo cual es 1 casilla menos del máximo, de ahí se hace un salto el cual nos deja de nuevo en pintura naranja, desde donde podemos llegar caminando hasta el final en un total de tan solo 3 segundos, 1 segundo menos que la solución anterior.&lt;/p>
&lt;p>Por lo tanto, no es suficiente visitar la distancia máxima, también hace falta visitar la distancia máxima - 1. Si intentamos hacer cosas similares con otro color de pintura, o más deteniéndonos todavía más atrás del máximo, no hay realmente ninguna ventaja, por lo que el caso presentado anteriormente es el único caso especial.&lt;/p>
&lt;p>Una búsqueda en amplitud bien hecha que considere este caso sacará 30 puntos, una que no considere este caso sacará únicamente 5 puntos. Da perfectamente en tiempo y memoria porque a lo más tendremos un total de 1000 estados. Sin embargo, la parte interesante de este problema es que los inklings son capaces de alterar el estado de la calle usando la pintura que traen en su tanque para poder recorrer más rápido la calle, utilizando hasta D disparos de tinta.&lt;/p>
&lt;p>En este caso, necesitamos agregar una segunda dimensión al estado de nuestra búsqueda, ahora no sólamente es suficiente con guardar el lugar en donde estamos, sino que es necesario guardar también cuanta tinta queda en el tanque. En este caso, agregamos una operación más, la cual es pintar, la cual cuesta 0 segundos, nos avanza 0 casillas y nos quita una unidad D de pintura.&lt;/p>
&lt;p>Si hacemos esto, nuestro espacio de búsqueda crece del N que era en la solución de 30 puntos, a N x D, lo cual es 1000 x 1000 y aún da en tiempo y memoria.&lt;/p>
&lt;p>No obstante, la operación de pintar altera el mapa, por lo que si no guardamos también en el estado que las casillas siguientes ahora son de otro color, pintar no servirá de nada. Podríamos agregar una dimensión más a la búsqueda para considerar este caso, pero esto solo le agregaría complejidad innecesaria a la búsqueda.&lt;/p>
&lt;p>La clave está en que pintar toma 0 segundos, por lo que podemos convertir la operación de pintar en una operación compuesta, que sea pintar y avanzar.&lt;/p>
&lt;p>Pintar y avanzar toma 1 segundo, y nos permite avanzar 4 casillas hacia adelante &lt;strong>siempre&lt;/strong>, por lo que hacer una operación de pintar y avanzar nos lleva del estado &lt;em>(i, d)&lt;/em> al estado &lt;em>(i + 4, d - 1)&lt;/em> con un costo de 1 segundo.&lt;/p>
&lt;p>El detalle con esta solución, es que estamos ignorando de nuevo el caso especial explicado en la solución de 30 puntos, por lo que si se nos olvida que es posible ahorrarnos un segundo en ciertas ocasiones, sacaremos entre 35 y 90 puntos dependiendo de la implementación.&lt;/p>
&lt;p>Para sacar los 100 puntos, es necesario agregar una operación más, la cual es pintar, avanzar y saltar, la cual nos lleva del estado &lt;em>(i, d),&lt;/em>  al estado &lt;em>(i + 6, d - 1)&lt;/em> con un costo de 2 segundos. Y como esta operación toma 2 segundos en vez de tan solo 1, no es suficiente con utilizar una cola común y corriente para hacer la búsqueda en amplitud, sino que es necesario utilizar una estructura de datos más avanzada, como una cola de prioridad o un montículo que nos ayude a ordenar los estados y elegir siempre con el tiempo más pequeño.&lt;/p></description></item><item><title>Solución a "Los Chocolates del Agente Nieves"</title><link>https://blog.omegaup.com/solution/chocolates/</link><pubDate>Wed, 05 Aug 2015 07:02:46 +0000</pubDate><guid>https://blog.omegaup.com/solution/chocolates/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/chocolates" target="_blank" rel="noopener">Los Chocolates del Agente Nieves&lt;/a>&lt;/p>
&lt;p>En este problema tenemos un tubo de chocolates los cuales se van a vender uno cada día, pudiendo vender únicamente los que están en ese momento en los extremos. El precio por vender un chocolate es igual al precio base de chocolate multiplicado por el número de días que se han vendido chocolates (empezando en 1).&lt;/p>
&lt;p>El objetivo es encontrar la mayor ganancia posible al vender todos los chocolates.&lt;/p>
&lt;p>Si lo quisiéramos resolver como una búsqueda, ¿qué tendríamos que considerar? En una búsqueda, nos importa obtener dos cosas, el espacio de búsqueda (es decir, cómo estará representado nuestro estado y qué valores puede tener), y las operaciones en nuestra búsqueda.&lt;/p>
&lt;p>En cuanto a nuestros estados en la búsqueda, nos importa saber qué chocolates aún tenemos disponibles y cuántos días han pasado. Podríamos empezar teniendo N valores booleanos por cada chocolate y un número para saber cuántos días han pasado, por ejemplo, si tenemos 3 chocolates y aún no vendemos nada, tendríamos el estado (1, 1, 1, 1), si ya vendimos el primer chocolate, tendríamos (0, 1, 1, 2), si vendimos el tercer chocolate tendríamos (1, 1, 0, 2) y si vendemos los chocolates 1 y 2, tendríamos (0, 0, 1, 3). Sin embargo, esta representación es un poco inútil, ya que en el peor de los casos, tendríamos 1000 chocolates, lo cual hace un estado de 1000 posibles valores.&lt;/p>
&lt;p>Podemos mejorar esto solo guardando únicamente los índices a los extremos del tubo, ya que ya sabemos que aún tenemos todos los chocolates entre estos dos valores. Eso transforma los estados anteriores a los siguientes estados respectivamente: (1, 3, 1), (2, 3, 2), (1, 2, 2). y (3, 3, 3). Esto vuelve al estado muchísimo más manejable, pues cada valor puede valer únicamente entre 1 y 1000.&lt;/p>
&lt;p>Ya que tenemos nuestro estado, definimos las operaciones que hay que hacer para ir entre estado y estado, y estas operaciones son únicamente 2, vender el chocolate de la izquierda, o vender el chocolate de la derecha, si estamos en el estado (1, 3, 1) y vendemos el de la izquierda, nos lleva al estado (2, 3, 2), y si vendemos el de la derecha, nos lleva al estado (1, 2, 2). Podemos continuar estas instrucciones recursivamente sobre los estados que resulta y generar un árbol de búsqueda:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/SXmtBPI.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Una vez teniendo el árbol de búsqueda, podemos proceder a darle valor a cada uno de los nodos. Del nodo inicial (1, 3, 1), si decides vender el chocolate de la izquierda, obtendrás una ganancia igual a lo que te de el nodo (2, 3, 2) más el precio del chocolate 1 multiplicado por el número de días, que en este caso es 1, y si decides vender el chocolate de la derecha, la ganancia será lo que de el nodo (1, 2, 2) más el precio del chocolate 3 (múltiplicado por 1). De las dos opciones, tomaremos el máximo.&lt;/p>
&lt;p>Llenemos ahora el resto del árbol de búsqueda con estos datos:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/HseaiuL.png" alt="" loading="lazy" />&lt;/p>
&lt;p>De aquí podemos ver dos cosas, la primera es que los nodos de hasta abajo, que son nuestros nodos hoja, tienen el mismo valor en el chocolate izquierdo como en el derecho, por lo que el valor máximo que podemos obtener de ellos es el precio de ese único chocolate por el número de días que llevamos. Y la segunda cosa es que tenemos nodos repetidos, por lo que cuando hagamos nuestra búsqueda, necesitamos guardar cálculos que ya hayamos hecho para no calcular un mismo estado más de una vez.&lt;/p>
&lt;p>Nuestro árbol de búsqueda ya está terminado, así que es hora de convertirlo a una función matemática. Nuestra función recibe como entrada un estado, en este caso el chocolate más a la izquierda que nos queda, el más a la derecha y el nivel en el que estamos, y dado lo que aprendimos de nuestro árbol de búsqueda, regresará el siguiente valor:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/s3XYfw9.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Con esto, y considerando que debemos evitar repetir valores duplicados, es más que suficiente para resolver el problema con el método que más te guste, ya sea dinámica o memorización, aunque hay un pequeño problema para guardar los valores visitados.&lt;/p>
&lt;p>Vamos a necesitar un arreglo de 1000 x 1000 x 1000 si es que queremos guardar un arreglo que se identifique de esta forma:&lt;/p>
&lt;p>arreglo[izquierda][derecha][nivel]&lt;/p>
&lt;p>Y esto es mucho más de lo que cabe en memoria, por lo que tenemos que encontrar una forma de reducir la memoria que necesitamos.&lt;/p>
&lt;p>Lo que nos tenemos que dar cuenta es que la variable nivel es innecesaria, pues puede calcularse utilizando el número de chocolates que nos quedan en el tubo y el número de chocolates que teníamos originalmente:&lt;/p>
&lt;p>nivel = total - chocolates_en_el_tubo + 1&lt;/p>
&lt;p>Y para calcular el número de chocolates que nos quedan en el tubo solo se necesitan el índice del chocolate más a la izquierda, y más a la derecha, que ya tenemos en nuestro estado.&lt;/p>
&lt;p>chocolates_en_el_tubo = derecha - izquierda + 1&lt;/p>
&lt;p>Despejando:&lt;/p>
&lt;p>nivel = total - derecha + izquierda - 1 + 1&lt;/p>
&lt;p>nivel = total - derecha + izquierda&lt;/p>
&lt;p>De esta forma, podemos eliminar el nivel de todos nuestros estados y cambiar el valor de nivel de todas las fórmulas por el valor de arriba. Esto simplifica nuestro arreglo de visitados de 1000 x 1000 x 1000 a un arreglo de tan solo 1000 x 1000, lo cuál es suficiente en tiempo y memoria.&lt;/p></description></item><item><title>Solución a "Temblor"</title><link>https://blog.omegaup.com/solution/solucion-a-temblor/</link><pubDate>Fri, 24 Jul 2015 07:07:00 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-temblor/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/temblor" target="_blank" rel="noopener">Temblor&lt;/a>&lt;/p>
&lt;p>Primero que nada, tratemos de entender qué es lo que se nos pide, pues es un problema poco tradicional: Dado un mapa de a lo más 4x4, hay que dar una serie de instrucciones que, sin importar en donde te encuentres en el mapa, logre llevarte a una salida; esta secuencia además, debe de ser la más pequeña posible.&lt;/p>
&lt;p>Este es el caso de ejemplo:&lt;/p>
&lt;p>&lt;img src="http://2.bp.blogspot.com/-_cxWM1TGYS4/T32p22oRTxI/AAAAAAAACVg/xtv0PTznyo8/s1600/mapa.png" alt="mapa" loading="lazy" />&lt;/p>
&lt;p>La solución correcta es ONNEE, pues con esas instrucciones, podemos salir no importando en que lugar estemos (el lugar inicial está marcado con un punto rojo):&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/QD8Rlaz.png" alt="" loading="lazy" />&lt;/p>
&lt;ul>
&lt;li>En el caso 1, las instrucciones ONN no hacen nada pues hay paredes, y las instrucciones EE nos sacan del mapa.&lt;/li>
&lt;li>En el caso 2, ONN no hacen nada de nuevo y la primera E nos saca del mapa (la última E ya no importa).&lt;/li>
&lt;li>En el caso 3, O no hace nada, pues hay pared, N nos sube un lugar, la segunda N no hace nada, y EE nos saca del mapa.&lt;/li>
&lt;li>El caso 4, O nos lleva a la izquierda, donde se vuelve el mismo caso que el caso 3.&lt;/li>
&lt;li>En el caso 5, O no hace nada, y NN nos lleva al caso 1.&lt;/li>
&lt;li>Y finalmente, en el caso 6, O nos lleva al caso 5 y de ahí podemos salir.&lt;/li>
&lt;/ul>
&lt;p>Es mucho más fácil ver la solución si vemos a todos los olímpicos moverse al mismo tiempo:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/UWonMkj.png" alt="" loading="lazy" /> Esto ejemplifica dos cosas: en primer lugar, el camino no debe de ser óptimo para cada uno, sino para todos en general, por ejemplo, el punto que inicia en la esquina superior derecha (cerca de la salida), podría salir yendo hacia la derecha, y saliendo en un único movimiento, pero si lo primero que hacemos es un &amp;ldquo;este&amp;rdquo;, estaremos complicando más las cosas para el resto de los olímpicos atrapados. En segundo lugar, puede haber más de un olímpico en un mismo lugar, y una vez que hay dos olímpicos en un mismo lugar, no importa realmente cuántos hay, sino que hay al menos 1 olímpico en ese lugar:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/fNMNkXW.png" alt="" loading="lazy" />&lt;/p>
&lt;p>O bien, si lo vemos como unos y ceros:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/mE1ISfk.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Donde 1 significa hay al menos un olímpico ahí y 0 significa no hay ningún olímpico ahí.&lt;/p>
&lt;p>Por lo tanto podemos concluir que nuestra tarea es convertir un tablero lleno de 1&amp;rsquo;s en un tablero lleno de 0&amp;rsquo;s.&lt;/p>
&lt;p>A estas alturas, ya tenemos lo suficiente como para hacer una búsqueda en amplitud sobre el problema. Los estados de nuestro espacio de búsqueda están representados por un mapa de NxM lleno de 1&amp;rsquo;s y 0&amp;rsquo;s y las transiciones entre un estado y otro son las operaciones Norte, Sur, Este y Oeste.&lt;/p>
&lt;p>Nuestro árbol de búsqueda empezaría más o menos así:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/PE9EBdZ.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Solo tendríamos que hacer una búsqueda en amplitud hasta llegar al mapa con puros ceros y reconstruir la solución para resolver el problema.&lt;/p>
&lt;p>Sin embargo, representar un mapa entero como un estado puede ser algo problemático, pues podemos tener hasta 16 casillas. Como puede haber un total de 2^16 estados, eso quiere decir que tendremos un arreglo de 17 dimensiones y estaremos usando 2^32 casillas de enteros, lo cual es completamente absurdo, pues aunque nos cupiera en memoria, dudo mucho que un compilador soporte tantas dimensiones y mucho menos que vaya a ser fácil manipularlas.&lt;/p>
&lt;p>Lo que nos tenemos que dar cuenta es que como nuestro estado son únicamente 1&amp;rsquo;s y 0&amp;rsquo;s podemos olvidarnos de la representación del arreglo, pues podemos convertir cada estado en un número binario. Por ejemplo, a continuación presentamos diferentes mapas y su representación binaria: &lt;img src="http://i.imgur.com/MY4v6m4.png" alt="" loading="lazy" /> Esto simplifica muchísimo nuestro espacio de búsqueda, ya que en vez de necesitar dieciséis enteros para representar un estado, ahora solo necesitamos 1, donde cada bit del estado representa una casilla del mapa.&lt;/p>
&lt;p>La pregunta que nos tenemos que hacer ahora es si es posible representar todos los estados con nuestra representación numérica, y la respuesta es que sí, pues solo son hasta 16 casillas en el mapa, o lo que es igual a 16 bits, y sabemos que un entero en la mayoría de los lenguajes modernos soporta hasta 32 bits, por lo tanto nos alcanza y nos sobra para representar todos los enteros.&lt;/p>
&lt;p>La siguiente pregunta que nos tenemos que hacer es si nos va a alcanzar la memoria. Y la respuesta también es sí, pues tenemos hasta 2^16 estados, lo cual es alrededor de 65,000 casillas, cada una de ellas puede guardar ya sea la operación que se hizo para llegar a ella, o el estado del que se llegó, ¡o incluso se pueden guardar ambas cosas! Pues solo necesitamos 16 bits para representar el estado de donde vienes y otros 2 para representar la operación que hiciste. Pero la implementación del problema ya se la dejamos a los competidores. En todo caso, necesitamos únicamente 65,000 enteros lo cual cabe en menos de 300 KB.&lt;/p>
&lt;p>De esta forma, nuestro árbol de búsqueda se transforma, y se vuelve más fácil de manipular:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/UzvlkDg.png" alt="" loading="lazy" /> Una vez hecha la conversión con bits, esto se vuelve una búsqueda en amplitud común y corriente desde un número con NxM bits prendidos, hasta 0. Una búsqueda así debe de ser fácil de hacer para cualquier competidor.&lt;/p></description></item><item><title>Solución a "Comesolo"</title><link>https://blog.omegaup.com/solution/solucion-a-comesolo/</link><pubDate>Sat, 14 Sep 2013 05:21:32 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-comesolo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/comesolo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://lhchavez.com" target="_blank" rel="noopener">lhchavez&lt;/a> &lt;strong>Fuente&lt;/strong>: Félix&lt;/p>
&lt;p>Este problema es especial porque es el primero en omegaUp de solo salida! Usualmente lo que debes esperar cuando te enfrentes con uno de esos problemas es que sea un problema NP que no tiene una solución rápida, y usualmente te pedirán que te aproximes lo más posible a la solución óptima. Esto significa que te vas a tener que valer de técnicas ad-hoc y heurísticas para sacar puntos.&lt;/p>
&lt;p>La solución del problema es bastante sencilla de explicar: haz una búsqueda en profundidad intentando todos los posibles movimientos por fuerza bruta hasta que te salga una solución aceptable e imprímela. El problema es que esta estrategia es $latex O(n!)$, y como $latex n$ puede valer hasta 30x30, puedes esperar que el programa corra varios milenios antes de encontrar la solución óptima. Hay tres trucos (en orden de importancia) para obtener una solución decente en un tiempo razonable:&lt;/p>
&lt;ul>
&lt;li>No repetir estados.&lt;/li>
&lt;li>No &amp;ldquo;clavarse&amp;rdquo; con soluciones que parece que son muy buenas, pero en realidad llevan a callejones sin salida.&lt;/li>
&lt;li>Encontrar una manera de darle prioridad a los estados que tengan más probabilidad de llegar a una solución buena.&lt;/li>
&lt;/ul>
&lt;p>La estrategia que yo personalmente seguí fue que cada que encontraba un nuevo estado, obtenía su &lt;a href="http://es.wikipedia.org/wiki/Funci%C3%B3n_hash" target="_blank" rel="noopener">hash&lt;/a> (que resultaba en un entero de 64 bits) y verificaba si no lo había visitado usando una tabla de hash&lt;a href="#note" >*&lt;/a>. Si no la había visitado, encontraba todos los estados vecinos (todos los tableros que resultaban de hacer un movimiento válido) y los guardaba en una fila de acuerdo a la cantidad de puntos (entre más puntos, más adelante en la fila). Luego, elegía aleatoriamente un estado de la fila dándole prioridad a los que estaban más adelante (pues son los que tienen mayor probabilidad de llegar a una buena solución), lo cual también me evitaba seguir un único camino donde me podría atorar. Repetí eso hasta que se me terminó la memoria de la computadora e imprimí la mejor solución.&lt;/p>
&lt;p>A continuación, el pseudocódigo de la solución:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Estado&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_init&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Estado&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tablero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Puedes usar cualquier algoritmo que genere un entero de 64 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># a partir de tablero y puntos. Este es el más sencillo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">53&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">hash&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">siguientes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todas las celdas (i, j) del tablero...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si la celda tiene una pieza...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todos los vecinos contiguos (i+k, j+l)...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Asegúrate que se haya movido \_algo\_.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que pueda brincar dentro del tablero.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="n">or&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nl">N&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que haya brincado una pieza.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que el lugar a donde brinca esté desocupado.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hijo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Estado&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Aumenta la puntuación del hijo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Borra la ficha original y la &amp;#34;comida&amp;#34;.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega la ficha en su posición final.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrégala a la cola correspondiente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">def&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Número aleatorio entre 0 y 1.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">RAND&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_MAX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># El índice de la última cola que estuvo llena.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La cola que se está considerando.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Elige la cola con mayores puntos que no esté vacía como
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># primera opción.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La primer cola tiene probabilidad de 31% de ser elegida.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># La segunda cola tiene probabilidad de 21%, la tercera 14%,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># la cuarta 10% y así sucesivamente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*=&lt;/span> &lt;span class="mf">1.45&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">lastfull&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">hashtable&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">lee&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">estado&lt;/span> &lt;span class="n">original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Estado&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_se&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_haya&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_terminado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_la&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_memoria&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si ya no hay más estados por visitar,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># encontramos la respuesta óptima en algún punto.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nl">Null&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Actualiza |mejor| si hay una respuesta mejor.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">mejor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">puntos&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Repetir estados es malo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="nl">_visitados&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega todos los vecinos.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">siguiente&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="n">partir&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">este&lt;/span> &lt;span class="n">punto&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">mejor&lt;/span>&lt;span class="o">|&lt;/span> &lt;span class="n">contiene&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="n">solución&lt;/span>&lt;span class="p">.&lt;/span> &lt;span class="n">Podemos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># saber qué movimiento se hizo para llegar a él comparando las
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># diferencias entre el tablero de |mejor.padre| y |mejor|. Ya solo es
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># cuestión de imprimir el resultado y listo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Aquí&lt;/span> &lt;span class="n">mucha&lt;/span> &lt;span class="n">gente&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">va&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">quejar&lt;/span> &lt;span class="n">porque&lt;/span> &lt;span class="n">solo&lt;/span> &lt;span class="n">guardar&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">abre&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">puerta&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">haya&lt;/span> &lt;span class="n">dos&lt;/span> &lt;span class="n">estados&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">puede&lt;/span> &lt;span class="n">tener&lt;/span> &lt;span class="n">hasta&lt;/span> &lt;span class="mi">900&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">tengan&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">mismo&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="mi">64&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">por&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">principio&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">palomar&lt;/span>&lt;span class="p">](&lt;/span>&lt;span class="nl">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="c1">//es.wikipedia.org/wiki/Principio_del_palomar)) y esté considerando que ya se visitó un estado que en realidad es nuevo. Si haces las cuentas, la probabilidad de colisión es negligible: la cantidad de estados que podía visitar en mi computadora (27 millones) es significativamente más pequeña que el número de estados necesarios para que la probabilidad de colisión sea de 1% ($latex \\approx 10^{135}$, por la [paradoja del cumpleaños](http://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os)).
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "El collar de perlas"</title><link>https://blog.omegaup.com/solution/solucion-a-el-collar-de-perlas/</link><pubDate>Thu, 03 Jan 2013 16:01:37 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-el-collar-de-perlas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://goldendarknut.blogspot.mx/" target="_blank" rel="noopener">Félix Rafael Horta Cuadrilla&lt;/a>&lt;/p>
&lt;p>En una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.&lt;/p>
&lt;p>Para resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero &lt;em>i&lt;/em> en cualquier lista representa al enano &lt;em>i&lt;/em>.&lt;/p>
&lt;p>Durante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.&lt;/p>
&lt;p>En algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.&lt;/p>
&lt;p>&lt;strong>Problema&lt;/strong>&lt;/p>
&lt;p>Escribe un programa que ayude a los enanos verdes a obtener el diamante, sabiendo de antemano las listas de todos los enanos. Puedes asumir que los enanos rojos juegan de manera optima. Se garantiza que siempre habra una forma en la que los enanos verdes puedan ganar si juegan optimamente.&lt;/p>
&lt;p>&lt;strong>Entrada&lt;/strong>&lt;/p>
&lt;p>La primer linea contiene la longitud &lt;strong>L&lt;/strong> del collar, el numero &lt;strong>N&lt;/strong> de enanos y el numero &lt;strong>F&lt;/strong> que representa el enano que empieza con el collar.&lt;/p>
&lt;p>La segunda linea contiene &lt;strong>L&lt;/strong> caracteres (seguidos, es decir, &lt;strong>NO&lt;/strong> hay espacios entre ellos) que representan el collar, estos caracteres pueden ser una letra &lt;strong>B&lt;/strong> que significa que es una perla blanca, una letra &lt;strong>N&lt;/strong> que significa que es una perla negra o una &lt;strong>D&lt;/strong> que indica que es el diamante. Solo habra un diamante y este siempre estara al final del collar.&lt;/p>
&lt;p>Las siguientes &lt;strong>N&lt;/strong> lineas describen a los enanos y sus listas. Cada linea esta formada por un numero &lt;strong>C&lt;/strong> que representa el color del enano (0 si es verde y 1 si es rojo) seguido por la longitud &lt;strong>LN&lt;/strong> de la lista negra y de &lt;strong>LN&lt;/strong> numeros, representando cada uno de los numeros en la lista negra del enano. Finalmente, en la misma linea, el numero &lt;strong>LB&lt;/strong> que indica la longitud de la lista blanca del enano y de &lt;strong>LB&lt;/strong> numeros indicando los elementos de dicha lista.&lt;/p>
&lt;p>&lt;strong>Límites&lt;/strong>&lt;/p>
&lt;p>1 &amp;lt;= L &amp;lt;= 1000&lt;/p>
&lt;p>1 &amp;lt;= N &amp;lt;= 1000&lt;/p>
&lt;p>&lt;strong>Interacción&lt;/strong>&lt;/p>
&lt;p>Este problema es interactivo y deberas escribir una funcion llamada &lt;em>juega()&lt;/em> que lea de pantalla el problema los datos de entrada y se cominique con tres funciones en una libreria.&lt;/p>
&lt;p>Las tres funciones con las que hay que interactuar son las siguientes:&lt;/p>
&lt;p>    void pasaCollar(int enano);&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos verdes posea el collar, tu programa mande el collar al enano especificado como parametro. Llamar a &lt;em>pasaCollar&lt;/em> cuando no le corresponde o pasar el collar a un enano que no este en la lista correspondiente resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>    int recibeCollar();&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos rojos posea el collar, tu programa llame a esta funcion para saber a que enano paso el collar el evaluador. Llamar a esta funcion cuando no le corresponde el turno a un enano rojo resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>void termina();&lt;/p>
&lt;p>Debe ser llamada una vez cuando en el collar solo quede el diamante. Si se llama en otro momento o si se llama y el collar esta en posesion de un enano rojo obtendras cero puntos en ese caso. Solo recibiras puntos si llamas a la funcion &lt;em>termina()&lt;/em> cuando el collar este en posesion de un enano verde y el collar solo posea al diamante.&lt;/p>
&lt;p>&lt;strong>Ejemplo&lt;/strong>&lt;/p>
&lt;p>Entrada&lt;/p>
&lt;p>6 4 2&lt;br>
NBBNND&lt;br>
0 1 2 1 4&lt;br>
0 2 1 3 1 1&lt;br>
1 1 4 1 4&lt;br>
1 2 2 3 1 1&lt;/p>
&lt;p>Salida&lt;/p>
&lt;p>pasaCollar(1)&lt;br>
pasaCollar(4)&lt;br>
recibeCollar() -&amp;gt; 1&lt;br>
pasaCollar(2)&lt;br>
pasaCollar(1)&lt;br>
termina()&lt;/p>
&lt;p>&lt;strong>Compilación&lt;/strong>&lt;/p>
&lt;p>Se proporcionan plantillas para facilitar la codificación del problema, de esa forma sólo necesitas codificar el archivo perlas.c/perlas.cpp/perlas.pas. Las plantillas son solo para facilitar la codificación y las pruebas, &lt;strong>no se garantiza que se evaluará con las mismas&lt;/strong>.&lt;/p>
&lt;p>Utilizando la plantilla proporcionada, puedes compilar este programa correctamente en C++ de la siguiente forma:&lt;/p>
&lt;p>    g++ main.cpp perlas.cpp -o perlas&lt;/p>
&lt;p>En C, se hace de la siguiente forma:&lt;/p>
&lt;p>    g++ main.c perlas.c -o perlas&lt;/p>
&lt;p>Mientras que para Pascal:&lt;/p>
&lt;p>fpc main.pas&lt;/p>
&lt;p>De la misma forma, las opciones de compilación pueden ser diferentes en la evaluación, sin embargo, si tu programa compila con las plantillas, también debería de hacerlo en el evaluador.&lt;/p>
&lt;p>&lt;strong>Descarga las plantillas &lt;a href="https://www.dropbox.com/sh/nux63uknmdyzgej/sfqTP9Tng8/plantillas.rar" target="_blank" rel="noopener">aquí&lt;/a> .&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Solución&lt;/strong>&lt;/p>
&lt;p>Una manera sencilla de tratar de ganar en este juego, es hacer una búsqueda sobre las listas de los enanos verdes y siempre pasar el collar sobre los enanos verdes, lo cual resolvería un par de casos. Sin embargo, en la mayor parte de los casos, es necesario pasar el collar a un enano rojo que eventualmente lo regresará a un enano verde. Y este es precisamente el problema, saber cuándo pasar a un enano rojo y a qué enano rojo, y como se necesita de la interacción de los enanos rojos para llegar a la solución, un gran problema se presenta.&lt;/p>
&lt;p>Aunque este problema podría resolverse fácilmente con una búsqueda memorizada haciendo las llamadas a las funciones durante la búsqueda, no puede hacerse de esta forma porque cuando se hace una búsqueda se requiere poder ir hacia adelante y hacia atrás en el árbol de búsqueda, y como se necesita de la interacción de los enanos rojos, se tiene que lograr la solución en la primera pasada.&lt;/p>
&lt;p>Por lo tanto hay que calcular todas las posibles tiradas antes de jugar, considerando las mejores tiradas de los enanos rojos. De esta forma, una vez que se tiene  una jugada para ganar el juego para &lt;strong>cualquier estado posible&lt;/strong>, se puede jugar teniendo seguro el triunfo.&lt;/p>
&lt;p>Ahora, aunque sabemos que no se puede resolver con una búsqueda, sí podemos utilizar un árbol de búsqueda para resolver el problema, pero ¿cómo tomar en cuenta las elecciones de los enanos rojos?, la respuesta a esto es jugar para ambos equipos y usar el mismo cósigo para ello, eligendo siempre la mejor opción para &lt;strong>el color de enano&lt;/strong> en cada turno, es decir, cuando la búsqueda esté sobre un enano rojo, hay que elegir la opción que haga que los enanos rojos ganen, y cuando la búsqueda esté sobre un enano verde, hay que elegir la opción que haga ganar a los enanos verdes.&lt;/p>
&lt;p>Es evidente que cuando las hojas del árbol terminan en un enano verde, se gana el juego (esos estados son estados ganadores), y cuando termina en un enano rojo el juego se pierde (esos estados son estados perdedores), eso es fácil, lo difícil son los siguientes niveles.&lt;/p>
&lt;p>Tomando en cuenta esto necesitamos etiquetar todos los estados como estados ganadores o estados perdedores, debido a que ya sabemos qué son los estados hojas, podemos deducir qué son los estados anteriores a las hojas de la siguiente forma: Si el estado pertenece a un enano verde, nos basta con que UN y solo UN enano en su lista lleve a un estado ganador, ya que como enanos verdes podemos controlar a quien le pasamos el collar, por lo que basta con que el estado pueda llevar a un estado ganador para que también sea un estado ganador. Si el enano verde NO lleva a ningún estado ganador, entonces ese estado NO es un estado ganador, por que no importa a quien se lo pases, siempre perderás.&lt;/p>
&lt;p>Pensando de esta misma forma, si el estado pertenece a un enano rojo, necesitamos que TODOS los estados a los que conduzca sean estados ganadores, por que si hay solo un estado perdedor, los enanos rojos, que juegan con la mejor estrategia, siempre eligirán ese estado.&lt;/p>
&lt;p>De esta forma, es posible que haya enanos verdes a los que quieras evitar, y enanos rojos a los que quieras pasarle el collar.&lt;/p>
&lt;p>Entonces, para resolver el problema, hay que pasar por todos los estados y marcarlos como estados ganadores o estados perdedores con la técnica que más te guste, ya sea programación dinámica o búsqueda memorizada, pero hay que hacerlo antes de jugar. Una vez teniendo precalculado cuáles son los estados ganadores y perdedores, solo hay que hacer las llamadas de los enanos verdes siempre hacia estados ganadores.&lt;/p>
&lt;p>&lt;a href="http://elira.operamail.com/files/perlas.rar" target="_blank" rel="noopener">DESCARGAR ARCHIVOS Y SOLUCIÓN&lt;/a>&lt;/p></description></item></channel></rss>