<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Freddy</title><link>https://blog.omegaup.com/tags/freddy/</link><description>Recent content in Freddy on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Sun, 27 Jul 2014 07:08:35 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/freddy/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Poema Equino"</title><link>https://blog.omegaup.com/solution/solucion-a-poema-equino/</link><pubDate>Sun, 27 Jul 2014 07:08:35 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-poema-equino/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P5/#problems/Poema-Equino" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Los límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $ (\text{poema},\text{fila caballo}_1,\text{columna caballo}_1,\text{fila caballo}_2,\text{columna caballo}_2)$, solamente hay $ 100 \times (4 \times 10)^2 = 160,000$ estados distintos.&lt;/p>
&lt;p>Además, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.&lt;/p>
&lt;p>Varios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!&lt;/p>
&lt;p>La siguiente solución implementa las simplificaciones descritas anteriormente.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/3f4d3496fe0e3aadd12b.js">&lt;/script></description></item><item><title>Solución a "Carretera"</title><link>https://blog.omegaup.com/solution/solucion-a-carretera/</link><pubDate>Fri, 25 Jul 2014 04:28:19 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-carretera/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1E1/#problems/carretera" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Examen 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Para obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.&lt;/p>
&lt;p>Este código obtiene los primeros 30 puntos:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/94cddcf809bc5a583540.js">&lt;/script>
&lt;p>Para el resto de los puntos: Sea $ f(t)$ el ancho necesario para la fotografía en el segundo $ t$. La observación crucial es que $ f$ es una función unimodal: es decir, existe un punto $ t_0$ tal que $ f$ es decreciente a la izquierda de $ t_0$ y es creciente a la derecha.&lt;/p>
&lt;p>Computar $ f(t)$ para $ t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $ t$, lo cual toma tiempo $ O(N)$. Como $ f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $ O(\lg T)$, donde $ T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $ O(N \lg T)$, suficiente para obtener todos los puntos del problema.&lt;/p>
&lt;p>El siguiente código implementa la solución anterior con búsqueda binaria.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/eee062837acde7bcd8ea.js">&lt;/script></description></item><item><title>Solución a "Suma Manhattan"</title><link>https://blog.omegaup.com/solution/solucion-a-suma-manhattan/</link><pubDate>Sat, 21 Jun 2014 14:34:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-suma-manhattan/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P1#problems/Suma-Manhattan" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Este problema requería manipular con cuidado la expresión que había que computar. Recordemos que nos piden computar&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} manhattan(S_i,S_j).$&lt;/p>
&lt;p>Para resolver la primer subtarea bastaba con iterar sobre todas las parejas de puntos y calcular su distancia. Esto corre en tiempo cuadrático y no es suficiente para obtener todos los puntos.&lt;/p>
&lt;p>La siguiente subtarea era una pista: se puede computar la distancia Manhattan de dos puntos considerando por separado sus coordenadas en $ x$ y $ y$. Ahora nos preocuparemos por calcular la siguiente expresión:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j|.$&lt;/p>
&lt;p>Donde $ a$ son las coordenadas en $ x$ o $ y$. El problema está en el valor absoluto. La manera más sencilla de deshacernos de él es ordenar la secuencia $ a$, de tal manera que $ a_i \leq a_j$. Entonces tenemos:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_j - a_i| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - a_i.$&lt;/p>
&lt;p>La primer igualdad es verdadera porque $ |x| = |-x|$ para cualquier $ x$. La segunda es porque como ahora $ a$ está ordenado, como $ a_j \geq a_i \implies a_j - a_i \geq 0$, el valor absoluto no hace nada.&lt;/p>
&lt;p>Podemos entonces separar la suma en dos términos:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_i.$&lt;/p>
&lt;p>Analicemos el primer término. Estamos sumando sobre todas las $ j$ tantas veces haya una $ i$ menor que ella. Eso quiere decir que cada $ a_j$ la vamos a sumar $ j$ veces (nota que $ a_0$ la sumamos $ 0$ veces).&lt;/p>
&lt;p>El segundo término nos dice que sumaremos todas las $ a_i$ tantas veces haya una $ j$ mayor a ella. Eso quiere decir que cada $ a_i$ la vamos a sumar $ N-i-1$ veces (nota que $ a_{N-1}$ la sumamos $ 0$ veces).&lt;/p>
&lt;p>Juntando esas ideas, entonces tenemos:&lt;/p>
&lt;p>$ \sum_{j = 0}^{N-1} j \cdot a_j - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} i \cdot a_i - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i.$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} (i - (N - i - 1)) \cdot a_i.$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} (2i - N + 1) \cdot a_i.$&lt;/p>
&lt;p>Y con eso terminamos: ahora tenemos una expresión que podemos computar fácilmente en tiempo lineal. Hay que tener cuidado al computar esto: La primera observación es que hay que estar tomando módulo después de cada operación porque en cualquier momento puede haber un &lt;em>overflow&lt;/em>. Algunos competidores obtuvieron 60 puntos en este problema por no tomar esto en cuenta. La segunda observación es que el término $ (2i - N + 1) \cdot a_i$ no necesariamente cabe en un entero signado de 32 bits &amp;ndash; hacía falta utilizar enteros de 64 bits para realizar este cálculo.&lt;/p>
&lt;p>Aquí está mi código que implementa la solución anterior.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/0614f2d1added587c2fc.js">&lt;/script></description></item><item><title>Solución a "Mocha Hojas"</title><link>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</link><pubDate>Sat, 18 Jan 2014 23:25:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Mocha-Hojas" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Alberto José Ramírez Valadez&lt;/p>
&lt;p>Para simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.&lt;/p>
&lt;p>Consideremos el caso de un árbol con un solo nivel. Ya que sólo podemos restarle a los pesos de las hojas, evidentemente el peso máximo del árbol se alcanza cuando se emparejan todas las hojas al peso de la hoja con peso mínimo.&lt;/p>
&lt;p>Ahora, consideremos un árbol con dos niveles. Si la raíz tiene $ k$ hijos, para cada hijo $ i$ sea $ h_i$ el subárbol de $ i$, $ b_i$ el número de hojas de $ h_i$, y $ c_i$ el peso del árbol obtenido de realizar el procedimiento del párrafo anterior a $ h_i$. Si todas las $ c_i$ son iguales, entonces nuestro árbol está balanceado. De lo contrario, debemos restar aún más para poder balancearlo. Sin embargo, también necesitamos que cada $ h_i$ continúe estando balanceado. La única manera que le podemos restar peso a $ h_i$ sería restarle la misma cantidad de peso a cada una de sus hojas. Entonces, a cada $ h_i$ sólo podemos restarle peso en múltiplos de $ b_i$. Como queremos maximizar el peso del árbol resultante, necesitamos encontrar el número más grande $ x$ tal que a todos los $ c_i$ les podamos restar un múltiplo de su respectivo $ b_i$ para obtener $ x$. Notemos también que $ c_i$ es un múltiplo de $ b_i$ porque los nodos internos del árbol no tienen peso. Si $ m$ es el mínimo común múltiplo de todos los $ b_i$, entonces $ x$ también es un múltiplo de $ m$. Entonces, el máximo $ x$ posible es igual al múltiplo de $ m$ más grande que sea menor o igual a todos los $ c_i$. Por lo tanto, el valor máximo obtenible del árbol completo es igual a $ kx$. Por último, si tuviéramos que restarle más peso a este árbol pero mantenerlo balanceado, es evidente que lo menos que podemos restar para mantenerlo balanceado es $ km$, y si seguimos restando $ km$ continuará balanceado.&lt;/p>
&lt;p>De esta observación podemos obtener la solución para cualquier árbol. Reusando la notación del párrafo anterior, $ k$ es la cantidad de hijos de la raíz, $ h_i$ el subárbol del $ i$ésimo hijo, y $ c_i$ el peso del árbol obtenido de realizar recursivamente el procedimiento de éste párrafo a $ h_i$ (o el del anterior si $ h_i$ tiene 2 niveles). Ahora $ b_i$ es igual a lo mínimo que le podemos restar a $ h_i$ y que continúe balanceado. El análisis del párrafo anterior también es correcto para la nueva definición de $ b_i$ y $ c_i$.&lt;/p>
&lt;p>El código siguiente implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8498208.js">&lt;/script></description></item><item><title>Solución alternativa a "Decepción"</title><link>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</link><pubDate>Fri, 17 Jan 2014 02:14:47 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P8#problems/decepcion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Esta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $ O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.&lt;/p>
&lt;p>Podemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $ f(n,m)$ cuenta de cuántas maneras se pueden poner $ n$ torres de tal manera de que sólo $ m$ se pueden ver de un lado, la respuesta que queremos es $ \sum_{i=0}^{N-1} ({N-1 \choose i} * f(i,F-1) * f(N-i-1,B-1))$.&lt;/p>
&lt;p>En otras palabras, esta expresión es la suma de las maneras de cumplir las condiciones originales del problema colocando la torre más alta en la posición $ i$. Es decir, hay $ {N-1 \choose i}$ maneras de distribuir el resto de las torres a la izquierda o derecha de la torre más alta (porque la única cosa que importa es el orden relativo de las torres y todas las alturas son distintas), las cuales multiplicamos por las maneras de hacer que se cumpla la condición sobre el lado izquierdo y lo mismo con el lado derecho.&lt;/p>
&lt;p>Ahora, para computar $ f$, podemos reusar la misma observación. Cuando colocamos la torre más alta en el índice $ i$, cualquier torre que pongamos después de $ i$ ya no se podrá ver. Del lado visible, necesitamos reordenar las torres restantes de tal manera que sólo se puedan ver $ m-1$. Además, podemos reordenar el lado oculto de la manera que queramos. Con esto tenemos que&lt;/p>
&lt;p>$ f(0,0) = 1$ $ f(n,m) = \begin{cases} 0 &amp;amp; \text{si } m &amp;gt; n\\ \sum_{i=0}^{n-1}({n-1 \choose i} * f(i,m-1) * (n-i-1)!) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>con lo que resolvemos el problema en tiempo $ O(N^3)$ y memoria $ O(N^2)$.&lt;/p>
&lt;p>Esto se puede mejorar aún más observando que $ f(n,m)$ está computando los números de Stirling de primera clase, para los cuales hay una recurrencia que se puede utilizar para calcularlos en tiempo $ O(N^2)$.&lt;/p>
&lt;p>Los números de Stirling de primera clase cuentan las permutaciones de $ n$ elementos con $ m$ ciclos. Considere una permutación con $ m$ ciclos de los $ n$ edificios. Cada ciclo debe tener un elemento máximo. Además podemos ordenar los ciclos entre sí por su elemento mayor. De esta manera, tenemos $ m$ edificios visibles. Ya que estamos contando todas las permutaciones con $ m$ ciclos, cada posible ordenamiento con $ m$ edificios visibles será considerada. Esto se debe a que cada ciclo tiene únicamente un ordenamiento en el cual sólo uno de sus elementos es visible: el que comienza con el edificio más grande.&lt;/p>
&lt;p>Aquí está el código que implementa esta solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8467347.js">&lt;/script></description></item><item><title>Solución a "DP Genérica"</title><link>https://blog.omegaup.com/solution/solucion-a-dp-generica/</link><pubDate>Wed, 25 Sep 2013 06:00:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-dp-generica/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P13#problems/DP-Generica" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 13&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Project Euler&lt;/p>
&lt;p>Podemos tratar este problema de varias maneras distintas, 3 de las cuales discutiré en esta solución.&lt;/p>
&lt;h2>Análisis 1
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero, una idea que hubiera obtenido 50 puntos.&lt;/p>
&lt;p>Podemos observar que el problema es equivalente a encontrar de cuántas maneras se le puede asignar un número $ n_i$ del conjunto $ \{0,1,2\}$ a cada potencia de 2 tal que $ \sum_{i=0}^{\infty} n_i 2^i = x$. Esto también es equivalente a encontrar cuántos números $ a$ y $ b$ hay tales que $ a + b = x$ y no haya ningún bit encendido en $ b$ que no esté encendido en $ a$.&lt;/p>
&lt;p>Consideremos la expansión binaria de $ a = \sum_{i=0}^{\infty} a_i 2^i$ y $ b = \sum_{i=0}^{\infty} b_i 2^i$ , donde cada $ a_i$ y $ b_i$ es 1 o 0. Al sumar $ a + b = \sum_{i=0}^{\infty} (a_i + b_i) 2^i$ tenemos que $ 0 \le n_i = a_i + b_i \le 2$, como se necesita. Para contar solamente una vez cada configuración distinta de la secuencia $ n$, añadimos la restricción de que cualquier $ b_i$ puede ser 1 sólo si $ a_i$ también lo es.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Para esta subtarea es suficiente probar todas las $ a$ y $ b$ posibles, revisando con un loop para cada bit si la condición sobre $ b$ se cumple. Este algoritmo corre en tiempo $ O(N^2 \log N)$.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Para esta subtarea podemos hacer una observación sencilla: a cada $ a$ sólo le puede corresponder una $ b$, igual a $ x - a$, lo que reduce la complejidad en tiempo del algoritmo a $ O(N \log N)$.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos comprobar si $ b$ cumple la condición en tiempo constante utilizando operaciones de bits. Si &lt;code>~a &amp;amp; b&lt;/code> es igual a 0, $ b$ no tiene ningún bit encendido que $ a$ no tenga encendido. Ahora tenemos un algoritmo lineal. Desafortunadamente, ya no podemos mejorar nuestra solución fácilmente continuando con esta idea.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702819.js">&lt;/script>
&lt;h2>Análisis 2
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-1">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos hacer programación dinámica de forma &lt;em>top-down&lt;/em>. En ésta, contamos la cantidad de maneras de escribir $ x$ como pide el problema incluyendo o no cada una de las potencias distintas.&lt;/p>
&lt;p>Consideremos la función $ f(n,p)$, que cuenta de cuántas maneras podemos escribir $ n$ utilizando potencias de 2 menores o iguales a $ p$ no más de 2 veces cada una. Es evidente que la respuesta se encontraría evaluando $ f(x,63)$.&lt;/p>
&lt;p>Sabemos que $ f(n,p) = 0$ si $ n$ es negativo o si $ p$ es negativo. Del mismo modo, $ f(n,p) = 1$ si $ n = 0$. De lo contrario, es igual a la suma de $ f(n,p-1)$, $ f(n-2^p,p-1)$ y $ f(n-2^{p+1},p-1)$, que corresponden a poner 0, 1, o 2 veces la potencia $ 2^p$.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Aplicando directamente el análisis anterior, la subtarea 1 queda resuelta.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Varios de estos estados se repiten, así que convendría memorizarlos. Utilizando un contenedor como &lt;code>std::map&lt;/code>, la solución se vuelve lo suficientemente rápida para resolver esta subtarea.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos determinar en algunos casos rápidamente si la función se evaluará a 0. Sabemos que $ \sum_{i=0}^{k} 2^i = 2^{k+1} - 1$. Entonces, el número más grande que podemos escribir sólo usando potencias de 2 menores o iguales a $ p$ a lo más dos veces es $ 2\sum_{i=0}^{p} 2^p = 2 (2^{p+1} - 1) = 2^{p+2} - 2$. Por lo tanto, $ f(n,p) = 0$ si $ n &amp;gt; 2^{p+2} - 2$.&lt;/p>
&lt;p>Esa optimización por sí misma (sin memorización), resuelve la subtarea 3.&lt;/p>
&lt;h1>Subtarea 4&lt;/h1>&lt;p>Combinando las ideas de las dos subtareas anteriores, el algoritmo es lo suficientemente rápido para resolver todos los casos. Específicamente, la cantidad de estados que no podemos determinar como no viables instantáneamente es proporcional a $ \log x$, y cada estado lo podemos evaluar en tiempo $ O(\log \log x)$ por nuestro &lt;code>std::map&lt;/code>, dándonos una complejidad total de $ O(\log x \log \log x)$. Esta cota puede quedar más clara después de describir la tercera solución.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702849.js">&lt;/script>
&lt;h2>Análisis 3
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-2">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución es equivalente a la anterior, pero no precisa de un &lt;code>std::map&lt;/code>.&lt;/p>
&lt;p>Consideremos la función $ n(k)$, que definimos como el número que obtenemos tomando los bits $ 0..k$ de $ x$. En otras palabras, si $ x = \sum_{i=0}^{\infty} x_i 2^i$ donde $ x_i$ es el $ i$-ésimo bit de $ x$, $ n(k) = \sum_{i=0}^k x_i 2^i$. Ahora, definimos la función $ g(i,r)$, que cuenta de cuántas maneras se puede escribir el número $ n(i) + r2^i$, utilizando potencias de 2 menores o iguales a $ i$ a lo más 2 veces. La respuesta, por lo tanto, se obtendría evaluando $ g(63,0)$.&lt;/p>
&lt;p>Ahora, sabemos que $ g(i,r) = 1$ si $ i &amp;lt; 0$ y $ r = 0$, porque podemos escribir sólo de una manera 0. Recordando que $ x_i$ es el $ i$-ésimo bit de $ x$, podemos decir que $ g(i,r)$ cuenta la cantidad de formas que se puede escribir el número $ (r+x_i)2^i + n(i-1)$. De ahora en adelante, por conveniencia, $ t = r + x_i$.&lt;/p>
&lt;p>Usando esto, podemos definir $ g(i,r)$ recursivamente:&lt;/p>
&lt;p>$ g(i,r) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \text{ y } r = 0 \\ \sum_{k=0}^{min(t,2)}g(i-1,2(t-k)) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>En otras palabras, si tenemos que poner $ t$ veces la potencia $ i$, podemos elegir ponerla hasta $ min(t,2)$ veces, y contar las maneras de escribir el resto usando potencias de 2 menores a $ p$. Pero como dejamos $ t-k$ veces la potencia $ i$ sin poner, es igual a poner $ 2(t-k)$ veces la potencia $ i-1$.&lt;/p>
&lt;p>La siguiente observación es que si $ t$ es mayor a 3, $ g(i,r) = 0$ porque $ 2\sum_{k=0}^{i} 2^k &amp;lt; 4 \times 2^{i}$. Entonces, sólo nos interesan los casos en los que $ 0 \le t \le 3$. En total, sólo hay 4 valores posibles para $ t$ en los que $ g(i,r)$ no es 0: 0, 1, 2, y 3. Enumerémoslos:&lt;/p>
&lt;p>$ g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,4) + g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,6) + g(i-1,4) + g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Pero $ g(i,r) = 0$ si $ t &amp;gt; 3$, y como $ t \ge r$, nos quedamos con:&lt;/p>
&lt;p>$ g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Tomando en cuenta que $ r$ sólo puede ser 0 o 2, y $ x_i$ sólo 0 o 1:&lt;/p>
&lt;p>$ (g(i,0),g(i,2)) = \begin{cases} (g(i-1,0),g(i-1,2)+g(i-1,0)) &amp;amp; \text{si } x_i = 0 \\ (g(i-1,2)+g(i-1,0),g(i-1,2)) &amp;amp; \text{si } x_i = 1 \end{cases}$&lt;/p>
&lt;p>El siguiente código implementa esta solución, que corre en tiempo $ O(\log n)$ y espacio constante:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702863.js">&lt;/script>
&lt;p>Como podemos observar, esta solución considera los mismos estados que la anterior, sólo que aquí evitamos computarlos, mientras que la otra los descarta inmediatamente.&lt;/p>
&lt;h2>Consideraciones
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-3">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Varios competidores no consideraron que $ x$ no cabe en un entero signado de 64 bits. Si bien la &lt;em>respuesta&lt;/em> cabe en uno, en los límites del problema se especifica que $ x &amp;lt; 2^{64}$.&lt;/p>
&lt;h2>Análisis adicional:
aliases: [&amp;rsquo;/solucion-a-dp-generica']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-dp-generica-4">&lt;/span>
&lt;a href="#aliases-solucion-a-dp-generica-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;a href="https://omegaup.com/profile/DiegoRoque" target="_blank" rel="noopener">Diego Roque&lt;/a> escribió una solución distinta, la cual detallaré a continuación.&lt;/p>
&lt;p>Consideremos la función $ f(x)$ como la define el problema: la cantidad de maneras de escribir $ x$ como una suma de potencias no negativas de 2 sin usar cada una más de 2 veces.&lt;/p>
&lt;p>Enfoquémonos en la paridad de $ x$ (es decir, el último bit de $ x$). Si $ x$ es impar, necesariamente tenemos que poner una vez la potencia $ 2^0$, porque las otras dos opciones: ponerla 0 veces o ponerla 2 veces cambiarían la paridad de $ x$. Por lo tanto, $ f(x) = f(\frac{x-1}{2})$ si $ x$ es impar. En cambio, si es par, podemos elegir poner la potencia $ 2^0$ 0 o 2 veces, lo que nos deja con $ f(x) = f(\frac{x}{2}) + f(\frac{x}{2}-1)$. Sólo falta definir los casos base: $ f(0) = f(1) = 1$.&lt;/p>
&lt;p>Aquí está su código que implementa esta solución, que corre en tiempo $ O(\log^2 x \log \log^2 x):$&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702891.js">&lt;/script></description></item><item><title>Solución a "La Venganza de Silvio"</title><link>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</link><pubDate>Thu, 08 Aug 2013 02:02:51 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/VenganzaDeSilvio" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Freddy&lt;/p>
&lt;p>Este problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.&lt;/p>
&lt;h2>Subtarea 1
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para obtener el primer grupo de puntos, sólo basta calcular $ N^M$ multiplicando a $ N$ por sí mismo $ M$ veces, teniendo cuidado de que no haya overflow.&lt;/p>
&lt;h2>Subtarea 2
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-1">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar &lt;a href="http://es.wikipedia.org/wiki/Exponenciaci%c3%b3n_binaria" target="_blank" rel="noopener">exponenciación binaria&lt;/a>.&lt;/p>
&lt;p>Sabemos que $ x^0 = 1$, que $ (x^n)^2 = x^{2n}$, y que $ x * x^{n-1} = x^n$ para toda $ x$ y $ n$, por lo que podemos escribir la siguiente relación:&lt;/p>
&lt;p>$ \text{potencia}(N,M) = \begin{cases} 1 &amp;amp; \text{si } M = 0 \\ (potencia(N,M/2))^2 &amp;amp; \text{si } M \text{ es par} \\ N * (potencia(N,(M-1)/2))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>Aplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $ O(log M)$, ya que en cada paso $ M$ se reduce a la mitad.&lt;/p>
&lt;h2>Subtarea 3
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-2">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $ M$. Para ello requerimos una observación adicional. Dividir entre $ 2$ en base $ 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.&lt;/p>
&lt;p>Podemos aprovechar esta observación guardando $ M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $ A$ es el arreglo donde guardamos los bits de $ M$, está $ 0$-indexado, tiene $ k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $ potencia2(N,k-1)$, donde $ potencia2$ es:&lt;/p>
&lt;p>$ \text{potencia2}(N,i) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \\ (potencia2(N,i-1))^2 &amp;amp; \text{si } A[i] = 0 \\ N * (potencia2(N,i-1))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;h2>Subtarea 4
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-3">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.&lt;/p>
&lt;p>Por conveniencia, definamos $ f(i)$ como el número que se obtiene tomando los elementos $ [0..i]$ del arreglo $ A$, y $ f(-1) = 0$. Recordando que multiplicar por $ 2$ en base $ 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $ f(i) = 2f(i-1) + A[i]$.&lt;/p>
&lt;p>Ahora, es simple notar que $ potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $ potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.&lt;/p>
&lt;p>Por lo tanto, podemos escribir un ciclo en vez de utilizar recursión.&lt;/p>
&lt;p>Este algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.&lt;/p>
&lt;p>Aquí está la implementación del algoritmo anterior:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559240.js">&lt;/script>
&lt;h2>Consideraciones
aliases: [&amp;rsquo;/solucion-a-la-venganza-de-silvio']&lt;span class="hx-absolute -hx-mt-20" id="aliases-solucion-a-la-venganza-de-silvio-4">&lt;/span>
&lt;a href="#aliases-solucion-a-la-venganza-de-silvio-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Hay que tener cuidado de que no haya overflow. Cuando un entero de $ k$ bits se eleva al cuadrado, puede ahora tener a lo más $ 2k$ bits. Como $ m$ puede tener hasta $ 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.&lt;/p>
&lt;p>También, varios competidores no consideraron el caso en el que se pide calcular $ N^0 \pmod 1$.&lt;/p></description></item></channel></rss>