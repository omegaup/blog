<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Liga Omegaup</title><link>https://blog.omegaup.com/tags/liga-omegaup/</link><description>Recent content in Liga Omegaup on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es-MX</language><lastBuildDate>Sun, 19 Apr 2020 08:05:15 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/liga-omegaup/index.xml" rel="self" type="application/rss+xml"/><item><title>Soluciones de la Fase 2 de la Liga de Programación omegaUp</title><link>https://blog.omegaup.com/posts/soluciones-a-liga-omegaup-fase-2/</link><pubDate>Sun, 19 Apr 2020 08:05:15 +0000</pubDate><guid>https://blog.omegaup.com/posts/soluciones-a-liga-omegaup-fase-2/</guid><description>
&lt;ol>
&lt;li>&lt;strong>&lt;a href="https://omegaup.com/arena/problem/No-se-molesto-en-escribir-uno" target="_blank" rel="noopener">Problema A&lt;/a>&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>Las siguientes observaciones son claves para resolver el problema.&lt;/p>
&lt;ol>
&lt;li>Si $p \leq n$, entonces $(w$ % $p) &amp;lt; n$. Así que el máximo residuo posible es $n - 1$.&lt;/li>
&lt;li>Si $w$ satisface la condición del enunciado, entonces hay $n - 1$ diferentes residuos, luego los residuos son un subconjunto de $n - 1$ elementos, de la colección $\lbrace 0, 1, \ldots , n - 1\rbrace$.&lt;/li>
&lt;li>El mínimo común múltiplo de $1, 2, \ldots , n$ es mayor o igual al producto de los primos menores o iguales a $ n$.&lt;/li>
&lt;li>El producto de los primos menores o iguales a $50$ es mayor a $10^{18}$&lt;/li>
&lt;/ol>
&lt;p>Veamos el caso donde $0$ no forma parte de los residuos. De &lt;strong>1&lt;/strong>, vemos que&lt;/p>
&lt;p>$w$ % $n = n - 1$&lt;/p>
&lt;p>$w$ % $n - 1 = n - 2$&lt;/p>
&lt;p>$\ldots$&lt;/p>
&lt;p>$w$ % $2= 1$ .&lt;/p>
&lt;p>Entonces $w + 1$ es un común múltiplo de $2, 3, 4,  \ldots,  n$.&lt;/p>
&lt;p>$(*)$ Luego, de la observación &lt;strong>3&lt;/strong> vemos que&lt;/p>
&lt;p>$mcm(2, 3, 4,  \ldots,  n) \geq P_n$&lt;/p>
&lt;p> Donde $P_n$ es el producto de los primos menores o iguales a $n$.&lt;/p>
&lt;p>$(*)$ Pero $P_{50} &amp;gt; 10^{18}$. Así que si $w + 1$ es un común múltiplo de $2, 3, 4,  \ldots,  n$ entonces $n \leq 50$.&lt;/p>
&lt;p>Ahora el caso donde $0$ sí forma parte de los residuos. Se sigue que existe $1 &amp;lt; k \leq n$ tal que $w$ % $k = 0$. Con la misma lógica, de &lt;strong>1&lt;/strong>, vemos qué&lt;/p>
&lt;p>$w$ % $k - 1 = k - 2$&lt;/p>
&lt;p>$\ldots$&lt;/p>
&lt;p>$w$ % $2= 1$ .&lt;/p>
&lt;p>Con ayuda de  $(*)$, vemos que $k \leq 50$.  ¿Cuál es el orden de los residuos mayores a $k$?. Para esto, consideremos el mismo orden que usamos en el caso donde $0$ no forma parte de los residuos.&lt;/p>
&lt;p>El residuo $k - 1$ que originalmente pertenecía a $k$ tiene dos direcciones: ser el residuo de un numero mayor que $k$, o $k - 1$ es el residuo que queda  descartado.&lt;/p>
&lt;p>Sea $M - 1$ el residuo que queda descartado, entonces $w + 1$ debe ser común múltiplo de $n, n - 1, n - 2, \ldots , M + 1$, y para esto,&lt;/p>
&lt;p>$(w + 1) \geq n * (n - 1) * (n - 2)  * \ldots * (M + 1)$&lt;/p>
&lt;p>Lo cual sería imposible si $n - M  \geq 50$.&lt;/p>
&lt;p>Ahora, si no descartamos los residuos de $k + 1, \ldots , k + 50$, entonces $w + 1 \geq  (k + 1) * \ldots  * (k + 50)$ lo cual sería de nuevo imposible.&lt;/p>
&lt;p>Por lo tanto, $M + 50 &amp;gt; n$ y $M - 50 &amp;lt; 1$.&lt;/p>
&lt;p>De modo que, si $n &amp;gt; 100$, la respuesta es &amp;ldquo;No&amp;rdquo;.  El problema ahora se limíta a $n \leq 100$ y $w \leq 10^{18}$.&lt;/p>
&lt;p>Para éste problema, podemos guardar todos los residuos de $w$ con los números menores o iguales a $n$ en una estructura que nos maneje operaciones básicas de conjuntos, como un set. Usando el set, la respuesta es &amp;ldquo;Si&amp;rdquo;, si el tamaño del set después de añadir los residuos es $n - 1$, y &amp;ldquo;No&amp;rdquo; en caso contrario.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://omegaup.com/arena/problem/La-fiesta-de-Filiberto" target="_blank" rel="noopener">Problema B&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Tratemos cada query de manera independientemente, y nos tomamos $a_1, a_2, \ldots, a_k$ como los puntos dados en la query.&lt;/p>
&lt;p>El problema es equivalente a encontrar un círculo con el menor radio $r$ posible, tal que todos los puntos de la query están dentro de él.  La respuesta sería el radio $r$.&lt;/p>
&lt;p>Él cuál es un problema equivalente a encontrar el menor radio $r$ tal que existe al menos un punto contenido en cada círculo con centro $a_1, a_2, \ldots a_n$ y radio $r$.&lt;/p>
&lt;p>Si dicho punto $p$ existe, entonces existe al menos un par de círculos que se intersecten en algun punto $T$. Por supuesto, la distancia de $p$ a $T$ es menor o igual a $r$.&lt;/p>
&lt;p>Por lo tanto, la respuesta puede ser encontrada con una búsqueda binaria.&lt;/p>
&lt;ol>
&lt;li>Fíjamos el radio $r$, el cual mandamos a la búsqueda binaria.&lt;/li>
&lt;li>Enumeramos los $k$ círculos.&lt;/li>
&lt;li>Encontramos y enumeramos las intersecciones para cada par de círculos.&lt;/li>
&lt;li>Para cada intersección, recorremos cada centro. Si hay un centro $a_i$que tiene una distancia menor o igual a $r$ entonces el menor radio que buscamos sí es menor o igual a $r$.&lt;/li>
&lt;/ol>
&lt;p>El costo de cada chequeo en la búsqueda binaria es $O(k^3)$. Y la búsqueda binaria tiene un costo de aproximádamente $50$ operaciones. Pero precalculando las soluciones, de &lt;strong>4&lt;/strong>, para todos los $l$ puntos antes de contestar las preguntas, reducimos el costo del chequeo a $O(k^2)$, lo cual ya es suficiente para resolver el problema.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://omegaup.com/arena/problem/La-fiesta-de-Briares" target="_blank" rel="noopener">Problema C&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Lo que buscamos, es la cantidad de subconjuntos tales que su $\&amp;amp;$  es igual a $0$. Esta cantidad puede verse como la cantidad de subconjuntos totales, menos la cantidad de subconjuntos tales que su $\&amp;amp;$ es diferente de $0$. Ahora, esta cantidad puede verse como la cantidad de subconjuntos cuyo  $\&amp;amp;$ tienen exactamente un bit prendido, más la cantidad de subconjuntos cuyo $\&amp;amp;$ tienen exactamente dos bits prendidos, $\ldots$, más la cantidad de subconjuntos cuyo $\&amp;amp;$ tienen exactamente $20$ bits prendidos (esto ya que $10^6 \leq 2^{20}$).&lt;/p>
&lt;p>Para esto usaremos el principio de inclusión - exclusión. De modo que la cantidad que buscamos esta dada por&lt;/p>
&lt;p>$S_ 0 - S_1 + S_2 - S_3 + \ldots + S_{20}$&lt;/p>
&lt;p>Donde $S_i$ nos dice cuantos subconjuntos tienen  un &lt;del>and&lt;/del> con al menos $i$ bits prendidos.&lt;/p>
&lt;p>Ahora, $S_i$ puede ser calculado con la ayuda de una SOS (Sum Over Subsets) DP.&lt;/p>
&lt;p>Para esto,  sea $mask$ alguna máscara de bits en $[1, 2^{20}]$, y definamos $m$ como el &lt;del>and&lt;/del> de algún subconjunto del arreglo, tal que $mask \&amp;amp; m = mask$. Es decir, $mask$ es una submáscara de $m$. Entonces, DP[mask] nos dice cuántas diferentes $m$ existen. (dos $m$ se consideran diferentes, si las posiciones de los elementos en el arreglo que la componen no son todas iguales). Está DP puede calcularse de la siguiente manera.&lt;/p>
&lt;ol>
&lt;li>Los casos base los formamos añadiendo la cantidad de ocurrencias de $x$ en el arreglo, a $DP[x]$.&lt;/li>
&lt;li>Fíjamos $bit \in [1, 20]$, de izquierda a derecha.&lt;/li>
&lt;li>Para cada mask en $[0, 2^{20}]$, tal que mask tiene el $bit$-ésimo bit apagado  (mas formalmente, $mask \&amp;amp; (1 &amp;laquo; bit)  = 0$ ) se hace la transición DP[mask | (1 &amp;laquo; bit)] += DP[mask].&lt;/li>
&lt;/ol>
&lt;p>De modo que $S_i = 2^{DP[m]}$, para cada $m$ una máscara con al menos $i$ bits prendidos.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://omegaup.com/arena/problem/Saltos-de-rana" target="_blank" rel="noopener">Problema D&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Sean $p_1, p_2, \ldots, p_m$ las posiciones de la cadena en donde hay un $1$.&lt;/p>
&lt;p>Definimos $r$ cómo la posición donde yace la rana, y $b$ como la cantidad de brincos que ha dado hasta el momento. Inicialmente, $r = p_1$ y $b = 0$. La respuesta puede encontrarse mediante siguiente algoritmo.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Encontrar $j$ tal que $p_j - r \leq k$ y $p_{j + 1} &amp;gt; k$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hacemos&lt;/p>
&lt;p>$b = b + 1$ y $r = p_j$&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Repetimos mientras $r \neq p_m$.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>La respuesta final es $b$. El algoritmo se puede implementar con complejidad lineal usando la técnica de two pointers (usando $r$ y $j$ como los pointers).&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://omegaup.com/arena/problem/Analizar-palabra" target="_blank" rel="noopener">Problema E&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Rescatando la cantidad de ocurrencias para cada vocal (no hay que olvidarse de contar las mayúsculas) mientras recorremos la cadena, estamos listos para imprimir las tres respuestas. Las cuales son&lt;/p>
&lt;p>**(a) ** Tamaño de la cadena.&lt;/p>
&lt;p>&lt;strong>(b)&lt;/strong>  Suma de las ocurrencias de cada vocal.&lt;/p>
&lt;p>&lt;strong>(c)&lt;/strong>  Imprimir la cadena de derecha a izquierda.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://omegaup.com/arena/problem/Suma-de-vectores" target="_blank" rel="noopener">Problema F&lt;/a>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Salvemos los dos vectores dados $a_1, a_2, \ldots , a_n$ y $b_1, b_2, \ldots , b_n$, y generemos un nuevo vector $c_1 = (a_1 + b_1), \ldots, c_n = (a_n + b_n)$. La solucion es imprimir $c_1, c_2, \ldots, c_n$.&lt;/p></description></item><item><title>Soluciones de la Fase 1 de la Liga de Programación omegaUp</title><link>https://blog.omegaup.com/posts/soluciones-a-liga-omegaup-fase-1/</link><pubDate>Wed, 01 Apr 2020 18:08:10 +0000</pubDate><guid>https://blog.omegaup.com/posts/soluciones-a-liga-omegaup-fase-1/</guid><description>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Rango-simple" target="_blank" rel="noopener">Problema A&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-ahttpsomegaupcomarenaproblemrango-simple">&lt;/span>
&lt;a href="#problema-ahttpsomegaupcomarenaproblemrango-simple" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para este problema, consideramos un arreglo de ocurrencias $O$ sobre los elementos del arreglo. De modo que la respuesta está dada por&lt;/p>
&lt;p>$\sum\limits_{i=A}^B O_{i}$&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/df979afcf721ba5aee429f948350e051.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/A-contar-lapices" target="_blank" rel="noopener">Problema B&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-bhttpsomegaupcomarenaproblema-contar-lapices">&lt;/span>
&lt;a href="#problema-bhttpsomegaupcomarenaproblema-contar-lapices" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Si consideramos el mismo arreglo de ocurrencias $O$ sobre los elementos del arreglo, la respuesta está dada por $O_k$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/2380189d0e29c2e29ab52771f353ebbe.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/nofib" target="_blank" rel="noopener">Problema C&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-chttpsomegaupcomarenaproblemnofib">&lt;/span>
&lt;a href="#problema-chttpsomegaupcomarenaproblemnofib" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos generar todos los elementos de la secuencia de Fibonacci hasta $30000$, y guardarlos en un mapa $M$, de modo que $M_k = 1$ si $k$ es un elemento de Fibonnaci, y $M_k = 0$ en caso contrario. Generamos la respuesta simplemente iterando desde $i = 4$ hasta $i = N - 1$, e imprimimos $i$ si $M_i = 0$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/7d2a6b7afb388ceb9b22cf2f077670f5.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Posicion-Fibonacci" target="_blank" rel="noopener">Problema D&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-dhttpsomegaupcomarenaproblemposicion-fibonacci">&lt;/span>
&lt;a href="#problema-dhttpsomegaupcomarenaproblemposicion-fibonacci" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>La clave para este problema, es usar variables que no provoquen un desbordamiento, por ejemplo, unsigned long long. Luego, es conocido que la serie de Fibonacci crece rápidamente, lo suficiente, como para generar la secuencia con todos sus elementos menores o iguales a $N$, guardando por cada uno su respectiva posición en ella. Por lo tanto, basta con checar si $N$ es un elemento, e imprimir su posición. En caso de no serlo, imprimimos $-1$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/00ea7419ff9454b86d63b052d44d0337.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/estacion" target="_blank" rel="noopener">Problema E&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-ehttpsomegaupcomarenaproblemestacion">&lt;/span>
&lt;a href="#problema-ehttpsomegaupcomarenaproblemestacion" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Este tipo de problema es conocido como straight-forward. Podemos guardar las estaciones de radio, y checar cuál estación es la mas cercana a la frecuencia dada, con una simple resta. En caso de haber dos estaciones con la misma distancia, la respuesta es la mayor. Solo debemos cuidar que la frecuencia esté dentro del rango permitido.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/f1fb91811095dee376d6961c65b8e017.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Tu-y-tu-Futuro" target="_blank" rel="noopener">Problema F&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-fhttpsomegaupcomarenaproblemtu-y-tu-futuro">&lt;/span>
&lt;a href="#problema-fhttpsomegaupcomarenaproblemtu-y-tu-futuro" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>En este problema lo que tenemos es un grafo dirigido acíclico con aristas pesadas (intuitivamente, es un árbol, sin la propiedad de que cualquier par de nodos estan conectados por un único camino). Los vértices son los eventos temporales, las aristas son dirigidas de $p_i$ a $i$, y su peso es $d_i$. Además, cada vértice contiene un valor extra $r_i$. Un grafo que podemos asociar al primer caso de ejemplo es el siguiente.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example_graph_correct.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Sean $v_1$ y $v_k$ dos vértices distintos, tales que $v_1$ es ancestro de $v_k$. Es decir, existe un camino $v_1 \rightarrow v_2 \rightarrow \ldots \rightarrow v_k$ en el grafo. Definimos $S(v_1, v_k)$ como&lt;/p>
&lt;p>$\sum\limits_{i=1}^{k - 1} d_{v_i}$&lt;/p>
&lt;p>Es decir, la suma de los pesos en las aristas del camino. De modo que el problema se convierte en: Para cada vertice $v$, contar cuántos vértices $u$ en su &amp;ldquo;subárbol&amp;rdquo; $\;$ existen tales que&lt;/p>
&lt;p>$r_u - S(v, u) \geq 0 $&lt;/p>
&lt;p>Porque esto siginifica que tenemos suficientes segundos para viajar por el tiempo desde $u$ hasta $v$.&lt;/p>
&lt;p>Consideremos un arreglo $E$, donde la entrada $E_v$ guarda cuántos descendientes $u$ de $v$ satisfacen&lt;/p>
&lt;p>$r_u - S(v, u) \geq 0 $&lt;/p>
&lt;p>Pero&lt;/p>
&lt;p>$r_u - S(p_v, u) &amp;lt; 0 $&lt;/p>
&lt;p>Donde $p_v$ es el padre de $v$. Si $v = 0$, entonces no hace falta considerar a su padre, puesto que no podemos viajar por el tiempo a algún ancestro de $0$ (ya que ni siquiera existe alguno).&lt;/p>
&lt;p>En otras palabras, $E_v$ guarda cuántos descendientes de $v$ llegan a lo mas al vértice $v$.&lt;/p>
&lt;p>También consideremos un arreglo $D$, donde la entrada $D_v$ guarda cuántos descendientes $u$ de $v$ satisfacen&lt;/p>
&lt;p>$ r_u - S(v, u) &amp;lt; 0 $&lt;/p>
&lt;p>Es decir, $D_v$ guarda cuántos descendientes de $v$ no pueden llegar al vertice $v$.&lt;/p>
&lt;p>Y además mantengamos un arreglo $T$, donde la entrada $T_v$ guarda el tamaño del &amp;ldquo;subárbol&amp;rdquo; de $v$ (incluyendo a $v$). En otras palabras, cuántos descendientes tiene $v$ en total mas el mismo.&lt;/p>
&lt;p>Por lo tanto, la respuesta final para el vértice $v$ está dada por&lt;/p>
&lt;p>$(T_v - 1) - \sum\limits_{v \rightarrow u} (E_u + D_u)$&lt;/p>
&lt;p>donde $u$ es un hijo directo de $v$. Ya que esto calcula cuántos descendientes de $v$ si pueden llegar a $v$.&lt;/p>
&lt;p>Para el cálculo de nuestros arreglos, hacemos una dfs sobre el &amp;ldquo;árbol&amp;rdquo;  (partiendo del vertice 0). Para cada vértice $u$, hacemos una búsqueda binaria sobre un arreglo que mantenga la suma acumulada de los costos sobre las aristas que forman parte del camino de $0$ a $u$, que nos devuelva el máximo ancestro $v$ al que podemos llegar desde $u$.  Lo que nos dice que  $E_v$ actualiza su valor a $E_v + 1$ (inicialmente, $E_1 = E_2  = \ldots = E_n = 0$). Esto se puede hacer usando un arreglo global. La idea es añadir la suma acumulada, luego explorar recursivamente el subárbol de $u$, y luego quitar la suma acumulada que añadimos. Esto es particularmente sencillo si usamos un vector de la STL para el arreglo global.&lt;/p>
&lt;p>El arreglo $T$ se calcula facilmente en la misma dfs, ya que&lt;/p>
&lt;p>$T_v = 1 + \sum\limits_{v \rightarrow u} (T_u)$&lt;/p>
&lt;p>Ahora podemos generar $D$, al estilo de programacion dinámica usando $E$. Notemos que&lt;/p>
&lt;p>$D_v = \sum\limits_{v \rightarrow u} (E_ u + D_u)$&lt;/p>
&lt;p>Lo que se puede hacer en la misma DFS.&lt;/p>
&lt;p>Por lo tanto, nuestro algoritmo tiene complejidad $O(Nlog(N))$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/230bf4f852d80fba75be9f2c322124b4.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Karel-y-los-quebrados" target="_blank" rel="noopener">Problema G&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-ghttpsomegaupcomarenaproblemkarel-y-los-quebrados">&lt;/span>
&lt;a href="#problema-ghttpsomegaupcomarenaproblemkarel-y-los-quebrados" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero reescribamos la expresión dada como&lt;/p>
&lt;p>$k = \dfrac{xy}{x + y}$&lt;/p>
&lt;p>De donde podemos despejar $y$ como&lt;/p>
&lt;p>$y = \dfrac{xk}{x - k}$&lt;/p>
&lt;p>Sin perdida de generalidad, supongamos $x \leq y$, entonces se tiene&lt;/p>
&lt;p>$x \leq \dfrac{xk}{x - k}$&lt;/p>
&lt;p>$x^2 \leq 2xk$&lt;/p>
&lt;p>$x \leq 2k$&lt;/p>
&lt;p>Por lo tanto, podemos iterar $x$ desde $1$ hasta $2k$, obtenemos $y$, y verificamos que $k = \dfrac{xy}{x + y}, y &amp;gt; 0$.&lt;/p>
&lt;p>Guardamos las parejas que satisfazcan dichas condiciones y las imprimimos en el orden requerido, cuidando no repetir alguna respuesta.&lt;/p>
&lt;p>Lo que nos deja con un algoritmo de complejidad $O(k)$.&lt;/p>
&lt;p>Una solución alternativa es la siguiente:&lt;/p>
&lt;p>Te puedes dar cuenta que $x, y &amp;gt; k$, entonces el problema se convierte a  buscar $a$ y $b$ que cumplan&lt;/p>
&lt;p>$\dfrac{1}{k} = \dfrac{1}{k + a} + \dfrac{1}{k + b}$&lt;/p>
&lt;p>con $a,b &amp;gt; 0$. Si simplificas la igualdad llegas a que $k^2 = ab$, así que todo se reduce a encontrar las parejas de divisores $a, b$ de $k^2$.  Lo que deja también un algoritmo de complejidad $O(k)$.&lt;/p>
&lt;p>Nota: Agradezco a José Tapia y a Carlos Galeana por su colaboración en el problema $G$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/1bf8bac6ba8c1040befc7b4b64900ac2.js">&lt;/script></description></item></channel></rss>