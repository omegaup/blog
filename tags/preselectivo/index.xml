<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Preselectivo</title><link>https://blog.omegaup.com/tags/preselectivo/</link><description>Recent content in Preselectivo on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 02 Mar 2017 06:29:09 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/preselectivo/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Los Callejones de Guanajuato"</title><link>https://blog.omegaup.com/posts/solucion-a-los-callejones-de-guanajuato/</link><pubDate>Thu, 02 Mar 2017 06:29:09 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-los-callejones-de-guanajuato/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/callejones/" target="_blank" rel="noopener">Los Callejones de Guanajuato&lt;/a>.&lt;/p>
&lt;p>En este problema se nos está pidiendo que, dado &lt;a href="https://es.wikipedia.org/wiki/Grafo_conexo" target="_blank" rel="noopener">un grafo conexo no dirigido&lt;/a>, encontrar un &lt;a href="https://es.wikipedia.org/wiki/Camino_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">camino&lt;/a> tal que pasemos por todas las aristas.&lt;/p>
&lt;p>Esta es una aplicación directa de un problema conocido de grafos, aunque no es tan común como otros problemas, estoy hablando de los &lt;a href="https://es.wikipedia.org/wiki/Ciclo_euleriano" target="_blank" rel="noopener">ciclos Eulerianos&lt;/a>.&lt;/p>
&lt;p>La teoría nos dice que un grafo tendrá un camino euleriano si y sólo sí el &lt;a href="https://es.wikipedia.org/wiki/Grado_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">grado&lt;/a> de todos sus nodos menos dos es par; es decir, solo dos de sus nodos tienen un número impar de aristas saliendo de él, mientras que todos los demás tienen un número par de aristas.&lt;/p>
&lt;p>Esto es fácil de imaginar si nos ponemos a pensar que todo camino que entre a un nodo por una arista debe de tener otra arista por donde salir, a excepción claro del nodo inicial y el nodo final, que sólamente interactúan con el camino una vez.&lt;/p>
&lt;p>Es posible visitar un nodo más de una vez, pero por cada vez que entremos, tenemos que salir una vez, manteniendo su grado par. También es posible visitar el nodo inicio y fin más de una vez, pero por cada vez extra que entremos a estos nodos, tendremos que salir, manteniendo su grado impar.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/cKkd6nh.png" alt="" loading="lazy" />&lt;/p>
&lt;p>También es posible crear un ciclo euleriano (que a diferencia de un camino, empieza y termina en el mismo nodo) si todos los nodos del grafo tienen grado par.&lt;/p>
&lt;p>De nuevo imaginemos un poco: en un grafo con un ciclo de euler podemos agregar una arista más entre nodo inicio y fin; ahora todos los nodos tienen grado par, y el camino de euler se volvió un ciclo.&lt;/p>
&lt;p>En ningún otro caso se puede formar un camino o ciclo de eurler. En los grafos siguientes, se puede apreciar que cada uno tiene más de dos nodos con un grado impar y por lo tanto, no habrá ningún camino o ciclo de euler, no importa cuanto lo intentes.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/o7OKuIc.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Lo primero que viene a mente luego de leer esta teroría es que aunque es trivial saber si existe o no camino, ¿cómo lo vamos a encontrar si un grafo tiene ciclos? ¿cómo saber qué arista tomar para que al llegar al nodo final, hayamos pasado por todos?&lt;/p>
&lt;p>Veremos que este algoritmo es también muy fácil.&lt;/p>
&lt;p>Imaginemos el siguiente grafo, en forma de casita, que es muy popular para este problema, tan popular, que hasta en las primarias se ve (aunque claro, a esa edad no se nos decía lo que estábamos haciendo).&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/0VQqGVK.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Lo primero que hay que hacer es, usando un algoritmo de &lt;a href="https://es.wikipedia.org/wiki/B%C3%BAsqueda_en_profundidad" target="_blank" rel="noopener">búsqueda en profundidad&lt;/a>, encontramos un camino, el que sea, entre los nodos inicio y fin, se pueden repetir nodos, pero no aristas.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/b8wtLgL.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora, si todos las aristas ya fueron visitadas, entonces ya terminamos, pero si no es así (lo cual es lo más probable), hay que buscar un nodo cualquiera, dentro del camino.&lt;/p>
&lt;p>Siempre que haya un nodo sin visitar, este va a tener al menos dos aristas disponibles (pues ya se explicó que siempre tendrán grado par), por lo tanto, ahora hay que hacer una segunda búsqueda, esta vez empezando desde el nodo con aristas disponibles, sin pasar por una arista que ya hemos visitado.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/C8l96lD.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Si el grafo tiene un camino de Euler, eventualmente vamos a regresar al nodo del que partimos. Siempre. Esto es verdad debido a que, como no nos quedan aristas con grado impar, una de las aristas en ese nodo debe de formar un ciclo con otra de las aristas que salen de ese nodo. Si no hubiera ciclo sería porque el camino termina abruptamente en un nodo, lo cual sería imposible porque esto significaría que ese nodo al final tendría grado impar, y ya usamos nuestros dos nodos impar.&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/r9rDfW3.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Si seguimos este algoritmo para todos los nodos que aún tengan aristas sin visitar, eventualmente visitaremos todas, lo único que hay que hacer ahora es tomar las aristas en el orden correcto para hacer las llamadas a la función.&lt;/p>
&lt;p>En el caso en que todos los nodos tengan grado par, se sigue exactamente el mismo algoritmo, con la diferencia de que el nodo inicio y el nodo fin son el mismo.&lt;/p>
&lt;p>Como nota cultural, existe un problema similar, el cual en vez de visitar todos las aristas, te pide visitar todos los nodos. Este problema se llama &lt;a href="https://es.wikipedia.org/wiki/Camino_hamiltoniano" target="_blank" rel="noopener">Camino Hamiltoniano&lt;/a>, y a diferencia de el camino de euler, este problema es &lt;a href="https://es.wikipedia.org/wiki/NP-completo" target="_blank" rel="noopener">NP completo&lt;/a>,  lo cual significa que no existe una solución que resuelva el problema en tiempo polinomial.&lt;/p></description></item><item><title>Solución a "Splatoon"</title><link>https://blog.omegaup.com/posts/solucion-a-splatoon/</link><pubDate>Mon, 05 Oct 2015 08:20:43 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-splatoon/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/splatoon/" target="_blank" rel="noopener">Splatoon&lt;/a>.&lt;/p>
&lt;p>Este problema pide llevar a un inkling desde el inicio de una calle hasta el final siguiendo sus reglas de movimiento.&lt;/p>
&lt;p>Ignoremos por un momento el hecho de que los inklings pueden pintar el piso y con ello alterar la calle en donde se realiza la carrera. Si los inklings no tuvieran esta habilidad, se puede hacer un algoritmo de fuerza bruta intentando todas las operaciones posibles, es decir, hacer una búsqueda en amplitud para encontrar el camino más corto, en donde el estado está representado únicamente por la posición en donde se encuentre el inkling.&lt;/p>
&lt;p>&lt;strong>Recuerda que en las búsquedas es importante marcar visitados para que la complejidad del algoritmo no se vuelva exponencial.&lt;/strong>&lt;/p>
&lt;p>Para cada posición, se tienen dos posibles operaciones, saltar, o caminar, ambas toman 1 segundo y la distancia a la que se llega depende directamente del color sobre el que se está parado. El movimiento de saltar es muy fácil pues solo hay una casilla donde se puede caer, pero el movimiento de avanzar difiere cada vez pues depende directamente del color de las siguientes casillas.&lt;/p>
&lt;p>Es posible hacer un ciclo para ver hasta donde puedes llegar avanzando desde la casilla en donde estás, y agregar a la búsqueda el lugar más lejano a donde puedas llegar. Sin embargo, si únicamente registramos la última casilla a donde se puede llegar, casos como el siguiente se nos escaparán:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/t1iBoPQ.png" alt="" loading="lazy" />&lt;/p>
&lt;p>En la solución superior, primero se avanza todo lo que se puede en la pintura naranja hasta llegar a la casilla azul, de ahi ya sea saltando o avanzando únicamente se puede llegar a la casilla blanca, y de ahí, no importa lo que hagas, te tomará dos segundos llegar al final.&lt;/p>
&lt;p>En cambio, en la solución inferior, se avanza solo 3 casillas en la pintura naranja, lo cual es 1 casilla menos del máximo, de ahí se hace un salto el cual nos deja de nuevo en pintura naranja, desde donde podemos llegar caminando hasta el final en un total de tan solo 3 segundos, 1 segundo menos que la solución anterior.&lt;/p>
&lt;p>Por lo tanto, no es suficiente visitar la distancia máxima, también hace falta visitar la distancia máxima - 1. Si intentamos hacer cosas similares con otro color de pintura, o más deteniéndonos todavía más atrás del máximo, no hay realmente ninguna ventaja, por lo que el caso presentado anteriormente es el único caso especial.&lt;/p>
&lt;p>Una búsqueda en amplitud bien hecha que considere este caso sacará 30 puntos, una que no considere este caso sacará únicamente 5 puntos. Da perfectamente en tiempo y memoria porque a lo más tendremos un total de 1000 estados. Sin embargo, la parte interesante de este problema es que los inklings son capaces de alterar el estado de la calle usando la pintura que traen en su tanque para poder recorrer más rápido la calle, utilizando hasta D disparos de tinta.&lt;/p>
&lt;p>En este caso, necesitamos agregar una segunda dimensión al estado de nuestra búsqueda, ahora no sólamente es suficiente con guardar el lugar en donde estamos, sino que es necesario guardar también cuanta tinta queda en el tanque. En este caso, agregamos una operación más, la cual es pintar, la cual cuesta 0 segundos, nos avanza 0 casillas y nos quita una unidad D de pintura.&lt;/p>
&lt;p>Si hacemos esto, nuestro espacio de búsqueda crece del N que era en la solución de 30 puntos, a N x D, lo cual es 1000 x 1000 y aún da en tiempo y memoria.&lt;/p>
&lt;p>No obstante, la operación de pintar altera el mapa, por lo que si no guardamos también en el estado que las casillas siguientes ahora son de otro color, pintar no servirá de nada. Podríamos agregar una dimensión más a la búsqueda para considerar este caso, pero esto solo le agregaría complejidad innecesaria a la búsqueda.&lt;/p>
&lt;p>La clave está en que pintar toma 0 segundos, por lo que podemos convertir la operación de pintar en una operación compuesta, que sea pintar y avanzar.&lt;/p>
&lt;p>Pintar y avanzar toma 1 segundo, y nos permite avanzar 4 casillas hacia adelante &lt;strong>siempre&lt;/strong>, por lo que hacer una operación de pintar y avanzar nos lleva del estado &lt;em>(i, d)&lt;/em> al estado &lt;em>(i + 4, d - 1)&lt;/em> con un costo de 1 segundo.&lt;/p>
&lt;p>El detalle con esta solución, es que estamos ignorando de nuevo el caso especial explicado en la solución de 30 puntos, por lo que si se nos olvida que es posible ahorrarnos un segundo en ciertas ocasiones, sacaremos entre 35 y 90 puntos dependiendo de la implementación.&lt;/p>
&lt;p>Para sacar los 100 puntos, es necesario agregar una operación más, la cual es pintar, avanzar y saltar, la cual nos lleva del estado &lt;em>(i, d),&lt;/em>  al estado &lt;em>(i + 6, d - 1)&lt;/em> con un costo de 2 segundos. Y como esta operación toma 2 segundos en vez de tan solo 1, no es suficiente con utilizar una cola común y corriente para hacer la búsqueda en amplitud, sino que es necesario utilizar una estructura de datos más avanzada, como una cola de prioridad o un montículo que nos ayude a ordenar los estados y elegir siempre con el tiempo más pequeño.&lt;/p></description></item><item><title>Solución a "Los Chocolates del Agente Nieves"</title><link>https://blog.omegaup.com/posts/chocolates/</link><pubDate>Wed, 05 Aug 2015 07:02:46 +0000</pubDate><guid>https://blog.omegaup.com/posts/chocolates/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/chocolates" target="_blank" rel="noopener">Los Chocolates del Agente Nieves&lt;/a>&lt;/p>
&lt;p>En este problema tenemos un tubo de chocolates los cuales se van a vender uno cada día, pudiendo vender únicamente los que están en ese momento en los extremos. El precio por vender un chocolate es igual al precio base de chocolate multiplicado por el número de días que se han vendido chocolates (empezando en 1).&lt;/p>
&lt;p>El objetivo es encontrar la mayor ganancia posible al vender todos los chocolates.&lt;/p>
&lt;p>Si lo quisiéramos resolver como una búsqueda, ¿qué tendríamos que considerar? En una búsqueda, nos importa obtener dos cosas, el espacio de búsqueda (es decir, cómo estará representado nuestro estado y qué valores puede tener), y las operaciones en nuestra búsqueda.&lt;/p>
&lt;p>En cuanto a nuestros estados en la búsqueda, nos importa saber qué chocolates aún tenemos disponibles y cuántos días han pasado. Podríamos empezar teniendo N valores booleanos por cada chocolate y un número para saber cuántos días han pasado, por ejemplo, si tenemos 3 chocolates y aún no vendemos nada, tendríamos el estado (1, 1, 1, 1), si ya vendimos el primer chocolate, tendríamos (0, 1, 1, 2), si vendimos el tercer chocolate tendríamos (1, 1, 0, 2) y si vendemos los chocolates 1 y 2, tendríamos (0, 0, 1, 3). Sin embargo, esta representación es un poco inútil, ya que en el peor de los casos, tendríamos 1000 chocolates, lo cual hace un estado de 1000 posibles valores.&lt;/p>
&lt;p>Podemos mejorar esto solo guardando únicamente los índices a los extremos del tubo, ya que ya sabemos que aún tenemos todos los chocolates entre estos dos valores. Eso transforma los estados anteriores a los siguientes estados respectivamente: (1, 3, 1), (2, 3, 2), (1, 2, 2). y (3, 3, 3). Esto vuelve al estado muchísimo más manejable, pues cada valor puede valer únicamente entre 1 y 1000.&lt;/p>
&lt;p>Ya que tenemos nuestro estado, definimos las operaciones que hay que hacer para ir entre estado y estado, y estas operaciones son únicamente 2, vender el chocolate de la izquierda, o vender el chocolate de la derecha, si estamos en el estado (1, 3, 1) y vendemos el de la izquierda, nos lleva al estado (2, 3, 2), y si vendemos el de la derecha, nos lleva al estado (1, 2, 2). Podemos continuar estas instrucciones recursivamente sobre los estados que resulta y generar un árbol de búsqueda:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/SXmtBPI.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Una vez teniendo el árbol de búsqueda, podemos proceder a darle valor a cada uno de los nodos. Del nodo inicial (1, 3, 1), si decides vender el chocolate de la izquierda, obtendrás una ganancia igual a lo que te de el nodo (2, 3, 2) más el precio del chocolate 1 multiplicado por el número de días, que en este caso es 1, y si decides vender el chocolate de la derecha, la ganancia será lo que de el nodo (1, 2, 2) más el precio del chocolate 3 (múltiplicado por 1). De las dos opciones, tomaremos el máximo.&lt;/p>
&lt;p>Llenemos ahora el resto del árbol de búsqueda con estos datos:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/HseaiuL.png" alt="" loading="lazy" />&lt;/p>
&lt;p>De aquí podemos ver dos cosas, la primera es que los nodos de hasta abajo, que son nuestros nodos hoja, tienen el mismo valor en el chocolate izquierdo como en el derecho, por lo que el valor máximo que podemos obtener de ellos es el precio de ese único chocolate por el número de días que llevamos. Y la segunda cosa es que tenemos nodos repetidos, por lo que cuando hagamos nuestra búsqueda, necesitamos guardar cálculos que ya hayamos hecho para no calcular un mismo estado más de una vez.&lt;/p>
&lt;p>Nuestro árbol de búsqueda ya está terminado, así que es hora de convertirlo a una función matemática. Nuestra función recibe como entrada un estado, en este caso el chocolate más a la izquierda que nos queda, el más a la derecha y el nivel en el que estamos, y dado lo que aprendimos de nuestro árbol de búsqueda, regresará el siguiente valor:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/s3XYfw9.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Con esto, y considerando que debemos evitar repetir valores duplicados, es más que suficiente para resolver el problema con el método que más te guste, ya sea dinámica o memorización, aunque hay un pequeño problema para guardar los valores visitados.&lt;/p>
&lt;p>Vamos a necesitar un arreglo de 1000 x 1000 x 1000 si es que queremos guardar un arreglo que se identifique de esta forma:&lt;/p>
&lt;p>arreglo[izquierda][derecha][nivel]&lt;/p>
&lt;p>Y esto es mucho más de lo que cabe en memoria, por lo que tenemos que encontrar una forma de reducir la memoria que necesitamos.&lt;/p>
&lt;p>Lo que nos tenemos que dar cuenta es que la variable nivel es innecesaria, pues puede calcularse utilizando el número de chocolates que nos quedan en el tubo y el número de chocolates que teníamos originalmente:&lt;/p>
&lt;p>nivel = total - chocolates_en_el_tubo + 1&lt;/p>
&lt;p>Y para calcular el número de chocolates que nos quedan en el tubo solo se necesitan el índice del chocolate más a la izquierda, y más a la derecha, que ya tenemos en nuestro estado.&lt;/p>
&lt;p>chocolates_en_el_tubo = derecha - izquierda + 1&lt;/p>
&lt;p>Despejando:&lt;/p>
&lt;p>nivel = total - derecha + izquierda - 1 + 1&lt;/p>
&lt;p>nivel = total - derecha + izquierda&lt;/p>
&lt;p>De esta forma, podemos eliminar el nivel de todos nuestros estados y cambiar el valor de nivel de todas las fórmulas por el valor de arriba. Esto simplifica nuestro arreglo de visitados de 1000 x 1000 x 1000 a un arreglo de tan solo 1000 x 1000, lo cuál es suficiente en tiempo y memoria.&lt;/p></description></item><item><title>Solución a "Temblor"</title><link>https://blog.omegaup.com/posts/solucion-a-temblor/</link><pubDate>Fri, 24 Jul 2015 07:07:00 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-temblor/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/temblor" target="_blank" rel="noopener">Temblor&lt;/a>&lt;/p>
&lt;p>Primero que nada, tratemos de entender qué es lo que se nos pide, pues es un problema poco tradicional: Dado un mapa de a lo más 4x4, hay que dar una serie de instrucciones que, sin importar en donde te encuentres en el mapa, logre llevarte a una salida; esta secuencia además, debe de ser la más pequeña posible.&lt;/p>
&lt;p>Este es el caso de ejemplo:&lt;/p>
&lt;p>&lt;img src="http://2.bp.blogspot.com/-_cxWM1TGYS4/T32p22oRTxI/AAAAAAAACVg/xtv0PTznyo8/s1600/mapa.png" alt="mapa" loading="lazy" />&lt;/p>
&lt;p>La solución correcta es ONNEE, pues con esas instrucciones, podemos salir no importando en que lugar estemos (el lugar inicial está marcado con un punto rojo):&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/QD8Rlaz.png" alt="" loading="lazy" />&lt;/p>
&lt;ul>
&lt;li>En el caso 1, las instrucciones ONN no hacen nada pues hay paredes, y las instrucciones EE nos sacan del mapa.&lt;/li>
&lt;li>En el caso 2, ONN no hacen nada de nuevo y la primera E nos saca del mapa (la última E ya no importa).&lt;/li>
&lt;li>En el caso 3, O no hace nada, pues hay pared, N nos sube un lugar, la segunda N no hace nada, y EE nos saca del mapa.&lt;/li>
&lt;li>El caso 4, O nos lleva a la izquierda, donde se vuelve el mismo caso que el caso 3.&lt;/li>
&lt;li>En el caso 5, O no hace nada, y NN nos lleva al caso 1.&lt;/li>
&lt;li>Y finalmente, en el caso 6, O nos lleva al caso 5 y de ahí podemos salir.&lt;/li>
&lt;/ul>
&lt;p>Es mucho más fácil ver la solución si vemos a todos los olímpicos moverse al mismo tiempo:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/UWonMkj.png" alt="" loading="lazy" /> Esto ejemplifica dos cosas: en primer lugar, el camino no debe de ser óptimo para cada uno, sino para todos en general, por ejemplo, el punto que inicia en la esquina superior derecha (cerca de la salida), podría salir yendo hacia la derecha, y saliendo en un único movimiento, pero si lo primero que hacemos es un &amp;ldquo;este&amp;rdquo;, estaremos complicando más las cosas para el resto de los olímpicos atrapados. En segundo lugar, puede haber más de un olímpico en un mismo lugar, y una vez que hay dos olímpicos en un mismo lugar, no importa realmente cuántos hay, sino que hay al menos 1 olímpico en ese lugar:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/fNMNkXW.png" alt="" loading="lazy" />&lt;/p>
&lt;p>O bien, si lo vemos como unos y ceros:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/mE1ISfk.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Donde 1 significa hay al menos un olímpico ahí y 0 significa no hay ningún olímpico ahí.&lt;/p>
&lt;p>Por lo tanto podemos concluir que nuestra tarea es convertir un tablero lleno de 1&amp;rsquo;s en un tablero lleno de 0&amp;rsquo;s.&lt;/p>
&lt;p>A estas alturas, ya tenemos lo suficiente como para hacer una búsqueda en amplitud sobre el problema. Los estados de nuestro espacio de búsqueda están representados por un mapa de NxM lleno de 1&amp;rsquo;s y 0&amp;rsquo;s y las transiciones entre un estado y otro son las operaciones Norte, Sur, Este y Oeste.&lt;/p>
&lt;p>Nuestro árbol de búsqueda empezaría más o menos así:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/PE9EBdZ.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Solo tendríamos que hacer una búsqueda en amplitud hasta llegar al mapa con puros ceros y reconstruir la solución para resolver el problema.&lt;/p>
&lt;p>Sin embargo, representar un mapa entero como un estado puede ser algo problemático, pues podemos tener hasta 16 casillas. Como puede haber un total de 2^16 estados, eso quiere decir que tendremos un arreglo de 17 dimensiones y estaremos usando 2^32 casillas de enteros, lo cual es completamente absurdo, pues aunque nos cupiera en memoria, dudo mucho que un compilador soporte tantas dimensiones y mucho menos que vaya a ser fácil manipularlas.&lt;/p>
&lt;p>Lo que nos tenemos que dar cuenta es que como nuestro estado son únicamente 1&amp;rsquo;s y 0&amp;rsquo;s podemos olvidarnos de la representación del arreglo, pues podemos convertir cada estado en un número binario. Por ejemplo, a continuación presentamos diferentes mapas y su representación binaria: &lt;img src="http://i.imgur.com/MY4v6m4.png" alt="" loading="lazy" /> Esto simplifica muchísimo nuestro espacio de búsqueda, ya que en vez de necesitar dieciséis enteros para representar un estado, ahora solo necesitamos 1, donde cada bit del estado representa una casilla del mapa.&lt;/p>
&lt;p>La pregunta que nos tenemos que hacer ahora es si es posible representar todos los estados con nuestra representación numérica, y la respuesta es que sí, pues solo son hasta 16 casillas en el mapa, o lo que es igual a 16 bits, y sabemos que un entero en la mayoría de los lenguajes modernos soporta hasta 32 bits, por lo tanto nos alcanza y nos sobra para representar todos los enteros.&lt;/p>
&lt;p>La siguiente pregunta que nos tenemos que hacer es si nos va a alcanzar la memoria. Y la respuesta también es sí, pues tenemos hasta 2^16 estados, lo cual es alrededor de 65,000 casillas, cada una de ellas puede guardar ya sea la operación que se hizo para llegar a ella, o el estado del que se llegó, ¡o incluso se pueden guardar ambas cosas! Pues solo necesitamos 16 bits para representar el estado de donde vienes y otros 2 para representar la operación que hiciste. Pero la implementación del problema ya se la dejamos a los competidores. En todo caso, necesitamos únicamente 65,000 enteros lo cual cabe en menos de 300 KB.&lt;/p>
&lt;p>De esta forma, nuestro árbol de búsqueda se transforma, y se vuelve más fácil de manipular:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/UzvlkDg.png" alt="" loading="lazy" /> Una vez hecha la conversión con bits, esto se vuelve una búsqueda en amplitud común y corriente desde un número con NxM bits prendidos, hasta 0. Una búsqueda así debe de ser fácil de hacer para cualquier competidor.&lt;/p></description></item><item><title>Solución a "Contraseña Binaria"</title><link>https://blog.omegaup.com/posts/solucion-a-contrasena-binaria/</link><pubDate>Thu, 14 Aug 2014 16:06:31 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-contrasena-binaria/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P7/#problems/contrasena-binaria" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 7&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:orlandoisay@gmail.com" >Orlando Isay Mendoza Garcia&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="mailto:chadancito@gmail.com" >Christian Adan Hernández Sánchez&lt;/a>&lt;/p>
&lt;p>Podemos ayudarnos de la imagen para comprender mejor esta explicación:&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img1.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img1.png" title="img1" alt="" loading="lazy" />
&lt;figcaption>img1&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>En ella aparecen de forma descendente a la izquierda los números pares comenzando desde el dos, y su representación binaria a la derecha. En la parte superior aparece el valor de cada cifra en decimal.&lt;/p>
&lt;p>Tomando en cuenta el límite del problema, sabemos que si sumamos $latex B(i)$ para cada par menor o igual a $latex N$, en el peor de los casos tendríamos que realizar 500,000,000,000,000 veces la función. Aún si lograramos calcularla en una operación nuestro programa excedería el tiempo límite.&lt;/p>
&lt;p>En cambio, haciendo cálculos notamos que: $latex 2^{50} \approx 1,000,000,000,000,000$. Lo cual significa que a lo más habrán 50 columnas en la tabla (ya que en la forma binaria cada cifra representa una potencia de 2).&lt;/p>
&lt;p>Dado que sabemos que en una suma el orden de las cantidades a sumar no importa, podemos determinar que es lo mismo sumar los valores de forma horizontal, tanto como de forma vertical. Sumando los valores de las columnas solo tomaría 50 operaciones. La columna 1 podemos ignorarla ya que al ser pares los números de la lista ninguno contendrá un 1 en la última cifra.&lt;/p>
&lt;p>Observando la siguiente imagen, vemos que la columna $latex C$ se forman grupos de tamaño $latex C$ (por ejemplo, en la columna 4 se forman grupos de cuatro elementos),que contienen una la mitad de $latex 1$s y la otra de $latex 0$s. También podemos ver que en la columna 2 no hay $latex 0$s antes del primer grupo, en columna 4 hay un 0, en la que sigue hay 2, luego 4,etc (área en color gris). Podemos notar que ese espacio aumenta en base a potencias del dos.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img2.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img2.png" title="img2" alt="" loading="lazy" />
&lt;figcaption>img2&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Teniendo el número $latex N$ habrán $latex N / 2$ números en la lista. Para calcular la cantidad de grupos completos que se forman en cada columna dividimos $latex N$ menos el espacio lleno de ceros en esa columna, entre el número de la columna en el que estemos; a su vez, esta cantidad la multiplicamos por, el número de la columna entre dos. Sin embargo, puede que nos falten de contabilizar los $latex 1$s que pudieran estar en un grupo que no se completo. Esto se arregla sumando a lo anterior, el mínimo entre el resto de la división anterior y, el número de la columna entre dos. &lt;/p>
&lt;p>Código:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/e13fe6f396e2b48755b7.js">&lt;/script></description></item><item><title>Solución a "Poema Equino"</title><link>https://blog.omegaup.com/posts/solucion-a-poema-equino/</link><pubDate>Sun, 27 Jul 2014 07:08:35 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-poema-equino/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P5/#problems/Poema-Equino" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Los límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $latex (\text{poema},\text{fila caballo}_1,\text{columna caballo}_1,\text{fila caballo}_2,\text{columna caballo}_2)$, solamente hay $latex 100 \times (4 \times 10)^2 = 160,000$ estados distintos.&lt;/p>
&lt;p>Además, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.&lt;/p>
&lt;p>Varios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!&lt;/p>
&lt;p>La siguiente solución implementa las simplificaciones descritas anteriormente.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/3f4d3496fe0e3aadd12b.js">&lt;/script></description></item><item><title>Solución a "Carretera"</title><link>https://blog.omegaup.com/posts/solucion-a-carretera/</link><pubDate>Fri, 25 Jul 2014 04:28:19 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-carretera/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1E1/#problems/carretera" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Examen 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Para obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.&lt;/p>
&lt;p>Este código obtiene los primeros 30 puntos:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/94cddcf809bc5a583540.js">&lt;/script>
&lt;p>Para el resto de los puntos: Sea $latex f(t)$ el ancho necesario para la fotografía en el segundo $latex t$. La observación crucial es que $latex f$ es una función unimodal: es decir, existe un punto $latex t_0$ tal que $latex f$ es decreciente a la izquierda de $latex t_0$ y es creciente a la derecha.&lt;/p>
&lt;p>Computar $latex f(t)$ para $latex t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $latex t$, lo cual toma tiempo $latex O(N)$. Como $latex f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $latex O(\lg T)$, donde $latex T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $latex O(N \lg T)$, suficiente para obtener todos los puntos del problema.&lt;/p>
&lt;p>El siguiente código implementa la solución anterior con búsqueda binaria.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/eee062837acde7bcd8ea.js">&lt;/script></description></item><item><title>Solución a "Suma Manhattan"</title><link>https://blog.omegaup.com/posts/solucion-a-suma-manhattan/</link><pubDate>Sat, 21 Jun 2014 14:34:14 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-suma-manhattan/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P1#problems/Suma-Manhattan" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Este problema requería manipular con cuidado la expresión que había que computar. Recordemos que nos piden computar&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} manhattan(S_i,S_j).$&lt;/p>
&lt;p>Para resolver la primer subtarea bastaba con iterar sobre todas las parejas de puntos y calcular su distancia. Esto corre en tiempo cuadrático y no es suficiente para obtener todos los puntos.&lt;/p>
&lt;p>La siguiente subtarea era una pista: se puede computar la distancia Manhattan de dos puntos considerando por separado sus coordenadas en $latex x$ y $latex y$. Ahora nos preocuparemos por calcular la siguiente expresión:&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j|.$&lt;/p>
&lt;p>Donde $latex a$ son las coordenadas en $latex x$ o $latex y$. El problema está en el valor absoluto. La manera más sencilla de deshacernos de él es ordenar la secuencia $latex a$, de tal manera que $latex a_i \leq a_j$. Entonces tenemos:&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_j - a_i| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - a_i.$&lt;/p>
&lt;p>La primer igualdad es verdadera porque $latex |x| = |-x|$ para cualquier $latex x$. La segunda es porque como ahora $latex a$ está ordenado, como $latex a_j \geq a_i \implies a_j - a_i \geq 0$, el valor absoluto no hace nada.&lt;/p>
&lt;p>Podemos entonces separar la suma en dos términos:&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_i.$&lt;/p>
&lt;p>Analicemos el primer término. Estamos sumando sobre todas las $latex j$ tantas veces haya una $latex i$ menor que ella. Eso quiere decir que cada $latex a_j$ la vamos a sumar $latex j$ veces (nota que $latex a_0$ la sumamos $latex 0$ veces).&lt;/p>
&lt;p>El segundo término nos dice que sumaremos todas las $latex a_i$ tantas veces haya una $latex j$ mayor a ella. Eso quiere decir que cada $latex a_i$ la vamos a sumar $latex N-i-1$ veces (nota que $latex a_{N-1}$ la sumamos $latex 0$ veces).&lt;/p>
&lt;p>Juntando esas ideas, entonces tenemos:&lt;/p>
&lt;p>$latex \sum_{j = 0}^{N-1} j \cdot a_j - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i$&lt;/p>
&lt;p>$latex = \sum_{i = 0}^{N-1} i \cdot a_i - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i.$&lt;/p>
&lt;p>$latex = \sum_{i = 0}^{N-1} (i - (N - i - 1)) \cdot a_i.$&lt;/p>
&lt;p>$latex = \sum_{i = 0}^{N-1} (2i - N + 1) \cdot a_i.$&lt;/p>
&lt;p>Y con eso terminamos: ahora tenemos una expresión que podemos computar fácilmente en tiempo lineal. Hay que tener cuidado al computar esto: La primera observación es que hay que estar tomando módulo después de cada operación porque en cualquier momento puede haber un &lt;em>overflow&lt;/em>. Algunos competidores obtuvieron 60 puntos en este problema por no tomar esto en cuenta. La segunda observación es que el término $latex (2i - N + 1) \cdot a_i$ no necesariamente cabe en un entero signado de 32 bits &amp;ndash; hacía falta utilizar enteros de 64 bits para realizar este cálculo.&lt;/p>
&lt;p>Aquí está mi código que implementa la solución anterior.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/0614f2d1added587c2fc.js">&lt;/script></description></item><item><title>Solución a "Químicos"</title><link>https://blog.omegaup.com/posts/solucion-a-quimicos/</link><pubDate>Thu, 23 Jan 2014 03:51:39 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-quimicos/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P6#problems/quimicos" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 6&lt;/a> &lt;strong>Autor:&lt;/strong>  &lt;a href="http://lhchavez.com/" target="_blank" rel="noopener">Luis Héctor Chávez (lhchavez)&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Éste es un problema que tiene una solución elegante y determinística pero requiere algoritmos avanzados bastante complicados. Lo bueno es que es posible aproximar a la solución utilizando fuerza bruta mediante backtracking.&lt;/p>
&lt;p>El problema nos pide encontrar una manera de asignar sustancias a los tubos y después mezclarlas con las dos operaciones disponibles (suma y diferencia absoluta) para terminar con un acomodo homogéneo de sustancias: la diferencia entre el tubo con más cantidad y con menos cantidad de sustancia debe ser lo más pequeña posible. Una manera de hacerlo es proponer un intervalo $latex [a,b]$ y ver si es posible asignar sustancias y aparear los tubos de manera que la cantidad de sustancia resultante de la mezcla en todos los tubos esté contenido dentro del intervalo. Para acelerar el proceso, puedes elegir los intervalos haciendo una búsqueda binaria de acuerdo a su ancho $latex b-a$, porque a fin de cuentas lo que nos pide el problema es precisamente el ancho mínimo. Para cada intervalo propuesto $latex [a,b]$, podemos hacer un grafo con $latex 2N$ nodos (uno para cada tubo), agregando un arco entre dos nodos $latex A$ y $latex B$ si $latex A+B\in[a,b]$ ó $latex |A-B|\in[a,b]$. Después, buscamos un &lt;a href="http://es.wikipedia.org/wiki/Apareamiento_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">apareamiento máximo&lt;/a> en el grafo: buscamos el conjunto de arcos con cardinalidad máxima tal que cada nodo tenga a lo más un arco incidente. Esto se puede encontrar con el &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Emparejamiento_de_Edmonds" target="_blank" rel="noopener">algoritmo de Edmonds&lt;/a> (también conocido como el Blossom algorithm por la forma de los ciclos de longitud impar) en tiempo $latex O(|2N|^4)$, lo cual encontraría todas las soluciones en solo un par de segundos.&lt;/p>
&lt;p>Lamentablemente la implementación del algoritmo de Edmonds es bastante complicada. Como este es un problema de solo-salida y todo se vale, en vez de hacer el intento por implementarlo, utilicé la librería &lt;a href="http://www.boost.org/" target="_blank" rel="noopener">Boost&lt;/a> de C++ que ya tiene muchísimos algoritmos de &lt;a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html" target="_blank" rel="noopener">grafos&lt;/a> ya implementados.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572476.js">&lt;/script>
&lt;p>Ahora, si no se te ocurre usar el algoritmo de Edmonds o no tienes acceso a Boost, aún así puedes obtener una cantidad decente de puntos usando una heurística: podemos &lt;em>intentar&lt;/em> hacer un apareamiento máximo usando fuerza bruta, rindiéndonos si el problema suena muy complicado y asumimos que no existe un apareamiento. Una fuerza bruta naïve con un contador que se decrementa cada vez que se llama la función de búsqueda es más que suficiente. Haciendo un par de modificaciones al algoritmo anterior nos da una solución que nos da el 80% de los casos bien:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572478.js">&lt;/script>
&lt;p>Claro que si te quieres ver greedy, puedes subirle al número de intentos, pero posiblemente no haya suficiente tiempo en el concurso para que termine. Si llegas a utilizar estas técnicas &amp;ldquo;impuras&amp;rdquo;, asegúrate primero de obtener cualquier solución que te de puntos antes de subirle para encontrar mejores respuestas.&lt;/p></description></item><item><title>Solución a "Crucero"</title><link>https://blog.omegaup.com/posts/solucion-a-crucero/</link><pubDate>Thu, 23 Jan 2014 03:41:06 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-crucero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P4#problems/Crucero" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:saul.g.gutierrez@gmail.com" >Saúl Germán Gutiérrez Calderón&lt;/a> &lt;strong>Fuente&lt;/strong>: USACO Enero 2009 Gold&lt;/p>
&lt;p>Como se puede notar, al trazar la ruta óptima del crucero se está desperdiciando mucho espacio, y daría lo mismo si expandiésemos la isla para que no se desperdiciara espacio entre la ruta y la orilla de ésta.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image002.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image002.jpg" title="image002" alt="" loading="lazy" />
&lt;figcaption>image002&lt;/figcaption>
&lt;/figure>&lt;/a> &lt;a href="https://blog.omegaup.com/images/image004.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image004.jpg" title="image004" alt="" loading="lazy" />
&lt;figcaption>image004&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si supiéramos cual es la ruta óptima del crucero para expandir la isla bastaría con hacer un Flood Fill para rellenar los espacios con agua que quedan dentro de la ruta.&lt;/p>
&lt;p>Resulta que el flood fill e puede hacer aun sin conocer cuál sería la ruta óptima. Si nos ponemos a hacer todos los tipos de celdas adyacentes a la celda actual en un flood fill, nos toparemos con que solo hay 2 que permiten que la isla crezca y 1 que evita que se expanda. El resto de las celdas adyacentes no nos dice nada acerca de si tenemos que poner algo ahí o no (de momento).&lt;/p>
&lt;p>Si se pone un pedazo de isla nuevo en el centro de las figura de abajo, entonces la cosa peligrosa tendría que ser rodeada de alguna manera para poder pasar, lo cual nos llevaría a tomar una ruta mas larga. Por ello, no es una buena idea poner un pedazo de isla ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image005.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image005.png" title="image005" alt="" loading="lazy" />
&lt;figcaption>image005&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si es como la de la figura de abajo,&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image006.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image006.png" title="image006" alt="" loading="lazy" />
&lt;figcaption>image006&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>ambos caminos tienen la misma longitud. Por ello, se puede poner un pedazo de isla ahí y esto nos simplifica el problema.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image007.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image007.png" title="image007" alt="" loading="lazy" />
&lt;figcaption>image007&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;a href="https://blog.omegaup.com/images/image008.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image008.png" title="image008" alt="" loading="lazy" />
&lt;figcaption>image008&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>La ruta óptima no puede pasar por el cuadro del centro ya que esto sería un desperdicio de tiempo, por lo cual podemos expandir la tierra ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image009.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image009.png" title="image009" alt="" loading="lazy" />
&lt;figcaption>image009&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Entonces, sólo hay que hacer todas las expansiones de tierra hasta que ya no se pueda más y después de esto se puede hacer una mano derecha para buscar la orilla de la isla que al mismo tiempo será la ruta óptima.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572582.js">&lt;/script></description></item><item><title>Solución a "Mocha Hojas"</title><link>https://blog.omegaup.com/posts/solucion-a-mocha-hojas/</link><pubDate>Sat, 18 Jan 2014 23:25:14 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-mocha-hojas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Mocha-Hojas" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Alberto José Ramírez Valadez&lt;/p>
&lt;p>Para simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.&lt;/p>
&lt;p>Consideremos el caso de un árbol con un solo nivel. Ya que sólo podemos restarle a los pesos de las hojas, evidentemente el peso máximo del árbol se alcanza cuando se emparejan todas las hojas al peso de la hoja con peso mínimo.&lt;/p>
&lt;p>Ahora, consideremos un árbol con dos niveles. Si la raíz tiene $latex k$ hijos, para cada hijo $latex i$ sea $latex h_i$ el subárbol de $latex i$, $latex b_i$ el número de hojas de $latex h_i$, y $latex c_i$ el peso del árbol obtenido de realizar el procedimiento del párrafo anterior a $latex h_i$. Si todas las $latex c_i$ son iguales, entonces nuestro árbol está balanceado. De lo contrario, debemos restar aún más para poder balancearlo. Sin embargo, también necesitamos que cada $latex h_i$ continúe estando balanceado. La única manera que le podemos restar peso a $latex h_i$ sería restarle la misma cantidad de peso a cada una de sus hojas. Entonces, a cada $latex h_i$ sólo podemos restarle peso en múltiplos de $latex b_i$. Como queremos maximizar el peso del árbol resultante, necesitamos encontrar el número más grande $latex x$ tal que a todos los $latex c_i$ les podamos restar un múltiplo de su respectivo $latex b_i$ para obtener $latex x$. Notemos también que $latex c_i$ es un múltiplo de $latex b_i$ porque los nodos internos del árbol no tienen peso. Si $latex m$ es el mínimo común múltiplo de todos los $latex b_i$, entonces $latex x$ también es un múltiplo de $latex m$. Entonces, el máximo $latex x$ posible es igual al múltiplo de $latex m$ más grande que sea menor o igual a todos los $latex c_i$. Por lo tanto, el valor máximo obtenible del árbol completo es igual a $latex kx$. Por último, si tuviéramos que restarle más peso a este árbol pero mantenerlo balanceado, es evidente que lo menos que podemos restar para mantenerlo balanceado es $latex km$, y si seguimos restando $latex km$ continuará balanceado.&lt;/p>
&lt;p>De esta observación podemos obtener la solución para cualquier árbol. Reusando la notación del párrafo anterior, $latex k$ es la cantidad de hijos de la raíz, $latex h_i$ el subárbol del $latex i$ésimo hijo, y $latex c_i$ el peso del árbol obtenido de realizar recursivamente el procedimiento de éste párrafo a $latex h_i$ (o el del anterior si $latex h_i$ tiene 2 niveles). Ahora $latex b_i$ es igual a lo mínimo que le podemos restar a $latex h_i$ y que continúe balanceado. El análisis del párrafo anterior también es correcto para la nueva definición de $latex b_i$ y $latex c_i$.&lt;/p>
&lt;p>El código siguiente implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8498208.js">&lt;/script></description></item><item><title>Solución alternativa a "Decepción"</title><link>https://blog.omegaup.com/posts/solucion-alternativa-a-decepcion/</link><pubDate>Fri, 17 Jan 2014 02:14:47 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-alternativa-a-decepcion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P8#problems/decepcion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Esta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $latex O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.&lt;/p>
&lt;p>Podemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $latex f(n,m)$ cuenta de cuántas maneras se pueden poner $latex n$ torres de tal manera de que sólo $latex m$ se pueden ver de un lado, la respuesta que queremos es $latex \sum_{i=0}^{N-1} ({N-1 \choose i} * f(i,F-1) * f(N-i-1,B-1))$.&lt;/p>
&lt;p>En otras palabras, esta expresión es la suma de las maneras de cumplir las condiciones originales del problema colocando la torre más alta en la posición $latex i$. Es decir, hay $latex {N-1 \choose i}$ maneras de distribuir el resto de las torres a la izquierda o derecha de la torre más alta (porque la única cosa que importa es el orden relativo de las torres y todas las alturas son distintas), las cuales multiplicamos por las maneras de hacer que se cumpla la condición sobre el lado izquierdo y lo mismo con el lado derecho.&lt;/p>
&lt;p>Ahora, para computar $latex f$, podemos reusar la misma observación. Cuando colocamos la torre más alta en el índice $latex i$, cualquier torre que pongamos después de $latex i$ ya no se podrá ver. Del lado visible, necesitamos reordenar las torres restantes de tal manera que sólo se puedan ver $latex m-1$. Además, podemos reordenar el lado oculto de la manera que queramos. Con esto tenemos que&lt;/p>
&lt;p>$latex f(0,0) = 1$ $latex f(n,m) = \begin{cases} 0 &amp;amp; \text{si } m &amp;gt; n\\ \sum_{i=0}^{n-1}({n-1 \choose i} * f(i,m-1) * (n-i-1)!) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>con lo que resolvemos el problema en tiempo $latex O(N^3)$ y memoria $latex O(N^2)$.&lt;/p>
&lt;p>Esto se puede mejorar aún más observando que $latex f(n,m)$ está computando los números de Stirling de primera clase, para los cuales hay una recurrencia que se puede utilizar para calcularlos en tiempo $latex O(N^2)$.&lt;/p>
&lt;p>Los números de Stirling de primera clase cuentan las permutaciones de $latex n$ elementos con $latex m$ ciclos. Considere una permutación con $latex m$ ciclos de los $latex n$ edificios. Cada ciclo debe tener un elemento máximo. Además podemos ordenar los ciclos entre sí por su elemento mayor. De esta manera, tenemos $latex m$ edificios visibles. Ya que estamos contando todas las permutaciones con $latex m$ ciclos, cada posible ordenamiento con $latex m$ edificios visibles será considerada. Esto se debe a que cada ciclo tiene únicamente un ordenamiento en el cual sólo uno de sus elementos es visible: el que comienza con el edificio más grande.&lt;/p>
&lt;p>Aquí está el código que implementa esta solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8467347.js">&lt;/script></description></item><item><title>Solución a "Panoramas"</title><link>https://blog.omegaup.com/posts/solucion-a-panoramas/</link><pubDate>Thu, 16 Jan 2014 17:36:38 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-panoramas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Tour" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Ángel Covarrubias &lt;strong>Fuente&lt;/strong>: Miguel Ángel Covarrubias&lt;/p>
&lt;p>El problema es un Steiner tree problem (un MST pero donde sólo hay que conectar un subconjunto de nodos) pero con costo por nodo en vez de por arista. El grafo de los panoramas es un árbol más un ciclo. Para un árbol una solución es poner como raíz a $latex s_1$ y para cada $latex s_i$ marcar los nodos en su camino hacia la raíz. Se puede usar DP o recursión para calcular el mínimo numero de vertices que conectan todos los nodos interesantes y pasan por la raíz para cada subárbol.&lt;/p>
&lt;p>$latex \mathrm{dp}_r=\mathrm{interesante}(r)\ \mathrm{si}\ \Sigma_h\mathrm{dp}_h=0$ $latex \mathrm{dp}_r = \Sigma_h\mathrm{dp}_h+1\ \mathrm{si}\ \Sigma_c\mathrm{dp}_h&amp;gt;0$&lt;/p>
&lt;p>$latex h$ es un hijo de $latex r$. La arista extra $latex (u,v)$ en el ciclo $latex c$ permite usar otros caminos a lo largo de $latex c$. Tales caminos deben conectar todos los nodos en $latex c$ que tengan nodos interesantes en su árbol después de quitar las aristas del ciclo $latex E-c$. Etiquetemos tales nodos con un uno y los demás nodos del $latex c$ con un cero. Para $latex E-(u,v)$ el ciclo sólo no cubre los últimos ceros. Para encontrar la solución sólo basta encontrar la secuencia de ceros más grande. En el siguiente diagrama, la arista que falta es $latex (u,v)$. La DP sólo no usa el último cero, pero es mejor no usar los dos ceros que están adyacentes.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">0&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">/&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">\\&lt;/span> &lt;span class="o">/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Este código implementa la solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8468920.js">&lt;/script></description></item><item><title>Solución a "Mapas de bits"</title><link>https://blog.omegaup.com/posts/solucion-a-mapas-de-bits/</link><pubDate>Sun, 06 Oct 2013 22:56:54 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-mapas-de-bits/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P12/#problems/Mapas-de-bits" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 12&lt;/a> &lt;strong>Autor:&lt;/strong> Jorge Alberto González Martínez &lt;strong>Fuente&lt;/strong>: Jorge Alberto González Martínez&lt;/p>
&lt;p>En el problema se describen dos formas de representar un mapa de bits.&lt;/p>
&lt;p>La forma bidimensional es simplemente utilizar una matriz para representar los bits. La forma por descomposición consiste en agrupar los bits similares y solo escribir el valor de los bits similares. En caso de que no sean similares todos los bits en un mapa de bits dado, se procede a dividir en cuatro secciones, imprimir la letra D y procesar cada uno de los cuartos de la misma manera, tal como se lee en la descripción del problema.&lt;/p>
&lt;p>La solución a este problema consistía en programar el método descrito. Este método inherentemente está basado en la técnica de divide y vencerás.&lt;/p>
&lt;p>A continuación, un pseudo-código que muestra la forma de llevar a cabo la transformación de un mapa de bits bidimensional a la forma reducida:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">todos&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">elementos&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">mapaDeBits&lt;/span> &lt;span class="n">son&lt;/span> &lt;span class="n">iguales&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Imprime&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">valor&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">termina&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Imprime&lt;/span> &lt;span class="n">D&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorIzquierdo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorDerecho&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorIzquierdo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorDerecho&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>El método para hacer la transformación inversa es muy parecido, sólo que para imprimir la equivalencia hay que comenzar con un mapa de bits bidimensional que nos sirva de variable auxiliar para hacer la conversión. Esta variable auxiliar se puede declarar de manera global y, cuando el método recursivo termine, simplemente imprimir su contenido:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">mapaDeBits&lt;/span> &lt;span class="n">comienza&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">un&lt;/span> &lt;span class="n">valor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Rellenar&lt;/span> &lt;span class="n">sección&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">mapa&lt;/span> &lt;span class="n">bidimensional&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">valor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorIzquierda&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorDerecha&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorIzquierda&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorDerecha&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>La primera vez que se llama a la función AmplificaMapa se debe entregar la representación de la forma por descomposición del mapa de bits en la variable mapaDeBits y la sección que se entrega inicialmente es todo el mapa de bits. Esto puede ser manejado por filas y columnas.&lt;/p>
&lt;p>A continuación se muestra una implementación en C++ que resuelve el problema. Nótese cómo se maneja la sección sobre la que se está trabajando con cuatro variables: &lt;code>tl_row&lt;/code>, &lt;code>tl_col&lt;/code>, &lt;code>br_row&lt;/code>, &lt;code>br_col&lt;/code>. El nombre de las variables proviene de top-left row, top-left colum, bottom-right row y bottom-right colum respectivamente. Representan los índices (fila,columa) de las esquinas superior izquierda e inferior derecha.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860210.js">&lt;/script></description></item><item><title>Solución a "Pista"</title><link>https://blog.omegaup.com/posts/445/</link><pubDate>Sun, 06 Oct 2013 22:48:35 +0000</pubDate><guid>https://blog.omegaup.com/posts/445/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P14#problems/pista" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 14&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente&lt;/strong>: Codeforces&lt;/p>
&lt;p>Este problema es una ligera modificación del Let&amp;rsquo;s Play Osu! que apareció en la ronda 146 en Codeforces. &lt;a href="http://codeforces.ru/blog/entry/5592" target="_blank" rel="noopener">La solución explicada la pueden encontrar en el editorial.&lt;/a>&lt;/p>
&lt;p>Para $latex N \le 10$ se pueden checar todas las $latex 2^N$ configuraciones de pistas. Para $latex N \le 1000$ funciona una dinámica $latex O(N^2)$, donde los estados son (posición, altura/profundidad que se lleva hasta el momento).&lt;/p>
&lt;p>Les dejo la implementación de DiegoRoque como un muy buen ejemplo de una solución a este problema.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860151.js">&lt;/script></description></item><item><title>Solución a "DP Genérica"</title><link>https://blog.omegaup.com/posts/solucion-a-dp-generica/</link><pubDate>Wed, 25 Sep 2013 06:00:06 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-dp-generica/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P13#problems/DP-Generica" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 13&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Project Euler&lt;/p>
&lt;p>Podemos tratar este problema de varias maneras distintas, 3 de las cuales discutiré en esta solución.&lt;/p>
&lt;h2>Análisis 1&lt;span class="hx-absolute -hx-mt-20" id="análisis-1">&lt;/span>
&lt;a href="#an%c3%a1lisis-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero, una idea que hubiera obtenido 50 puntos.&lt;/p>
&lt;p>Podemos observar que el problema es equivalente a encontrar de cuántas maneras se le puede asignar un número $latex n_i$ del conjunto $latex \{0,1,2\}$ a cada potencia de 2 tal que $latex \sum_{i=0}^{\infty} n_i 2^i = x$. Esto también es equivalente a encontrar cuántos números $latex a$ y $latex b$ hay tales que $latex a + b = x$ y no haya ningún bit encendido en $latex b$ que no esté encendido en $latex a$.&lt;/p>
&lt;p>Consideremos la expansión binaria de $latex a = \sum_{i=0}^{\infty} a_i 2^i$ y $latex b = \sum_{i=0}^{\infty} b_i 2^i$ , donde cada $latex a_i$ y $latex b_i$ es 1 o 0. Al sumar $latex a + b = \sum_{i=0}^{\infty} (a_i + b_i) 2^i$ tenemos que $latex 0 \le n_i = a_i + b_i \le 2$, como se necesita. Para contar solamente una vez cada configuración distinta de la secuencia $latex n$, añadimos la restricción de que cualquier $latex b_i$ puede ser 1 sólo si $latex a_i$ también lo es.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Para esta subtarea es suficiente probar todas las $latex a$ y $latex b$ posibles, revisando con un loop para cada bit si la condición sobre $latex b$ se cumple. Este algoritmo corre en tiempo $latex O(N^2 \log N)$.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Para esta subtarea podemos hacer una observación sencilla: a cada $latex a$ sólo le puede corresponder una $latex b$, igual a $latex x - a$, lo que reduce la complejidad en tiempo del algoritmo a $latex O(N \log N)$.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos comprobar si $latex b$ cumple la condición en tiempo constante utilizando operaciones de bits. Si &lt;code>~a &amp;amp; b&lt;/code> es igual a 0, $latex b$ no tiene ningún bit encendido que $latex a$ no tenga encendido. Ahora tenemos un algoritmo lineal. Desafortunadamente, ya no podemos mejorar nuestra solución fácilmente continuando con esta idea.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702819.js">&lt;/script>
&lt;h2>Análisis 2&lt;span class="hx-absolute -hx-mt-20" id="análisis-2">&lt;/span>
&lt;a href="#an%c3%a1lisis-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos hacer programación dinámica de forma &lt;em>top-down&lt;/em>. En ésta, contamos la cantidad de maneras de escribir $latex x$ como pide el problema incluyendo o no cada una de las potencias distintas.&lt;/p>
&lt;p>Consideremos la función $latex f(n,p)$, que cuenta de cuántas maneras podemos escribir $latex n$ utilizando potencias de 2 menores o iguales a $latex p$ no más de 2 veces cada una. Es evidente que la respuesta se encontraría evaluando $latex f(x,63)$.&lt;/p>
&lt;p>Sabemos que $latex f(n,p) = 0$ si $latex n$ es negativo o si $latex p$ es negativo. Del mismo modo, $latex f(n,p) = 1$ si $latex n = 0$. De lo contrario, es igual a la suma de $latex f(n,p-1)$, $latex f(n-2^p,p-1)$ y $latex f(n-2^{p+1},p-1)$, que corresponden a poner 0, 1, o 2 veces la potencia $latex 2^p$.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Aplicando directamente el análisis anterior, la subtarea 1 queda resuelta.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Varios de estos estados se repiten, así que convendría memorizarlos. Utilizando un contenedor como &lt;code>std::map&lt;/code>, la solución se vuelve lo suficientemente rápida para resolver esta subtarea.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos determinar en algunos casos rápidamente si la función se evaluará a 0. Sabemos que $latex \sum_{i=0}^{k} 2^i = 2^{k+1} - 1$. Entonces, el número más grande que podemos escribir sólo usando potencias de 2 menores o iguales a $latex p$ a lo más dos veces es $latex 2\sum_{i=0}^{p} 2^p = 2 (2^{p+1} - 1) = 2^{p+2} - 2$. Por lo tanto, $latex f(n,p) = 0$ si $latex n &amp;gt; 2^{p+2} - 2$.&lt;/p>
&lt;p>Esa optimización por sí misma (sin memorización), resuelve la subtarea 3.&lt;/p>
&lt;h1>Subtarea 4&lt;/h1>&lt;p>Combinando las ideas de las dos subtareas anteriores, el algoritmo es lo suficientemente rápido para resolver todos los casos. Específicamente, la cantidad de estados que no podemos determinar como no viables instantáneamente es proporcional a $latex \log x$, y cada estado lo podemos evaluar en tiempo $latex O(\log \log x)$ por nuestro &lt;code>std::map&lt;/code>, dándonos una complejidad total de $latex O(\log x \log \log x)$. Esta cota puede quedar más clara después de describir la tercera solución.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702849.js">&lt;/script>
&lt;h2>Análisis 3&lt;span class="hx-absolute -hx-mt-20" id="análisis-3">&lt;/span>
&lt;a href="#an%c3%a1lisis-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución es equivalente a la anterior, pero no precisa de un &lt;code>std::map&lt;/code>.&lt;/p>
&lt;p>Consideremos la función $latex n(k)$, que definimos como el número que obtenemos tomando los bits $latex 0..k$ de $latex x$. En otras palabras, si $latex x = \sum_{i=0}^{\infty} x_i 2^i$ donde $latex x_i$ es el $latex i$-ésimo bit de $latex x$, $latex n(k) = \sum_{i=0}^k x_i 2^i$. Ahora, definimos la función $latex g(i,r)$, que cuenta de cuántas maneras se puede escribir el número $latex n(i) + r2^i$, utilizando potencias de 2 menores o iguales a $latex i$ a lo más 2 veces. La respuesta, por lo tanto, se obtendría evaluando $latex g(63,0)$.&lt;/p>
&lt;p>Ahora, sabemos que $latex g(i,r) = 1$ si $latex i &amp;lt; 0$ y $latex r = 0$, porque podemos escribir sólo de una manera 0. Recordando que $latex x_i$ es el $latex i$-ésimo bit de $latex x$, podemos decir que $latex g(i,r)$ cuenta la cantidad de formas que se puede escribir el número $latex (r+x_i)2^i + n(i-1)$. De ahora en adelante, por conveniencia, $latex t = r + x_i$.&lt;/p>
&lt;p>Usando esto, podemos definir $latex g(i,r)$ recursivamente:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \text{ y } r = 0 \\ \sum_{k=0}^{min(t,2)}g(i-1,2(t-k)) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>En otras palabras, si tenemos que poner $latex t$ veces la potencia $latex i$, podemos elegir ponerla hasta $latex min(t,2)$ veces, y contar las maneras de escribir el resto usando potencias de 2 menores a $latex p$. Pero como dejamos $latex t-k$ veces la potencia $latex i$ sin poner, es igual a poner $latex 2(t-k)$ veces la potencia $latex i-1$.&lt;/p>
&lt;p>La siguiente observación es que si $latex t$ es mayor a 3, $latex g(i,r) = 0$ porque $latex 2\sum_{k=0}^{i} 2^k &amp;lt; 4 \times 2^{i}$. Entonces, sólo nos interesan los casos en los que $latex 0 \le t \le 3$. En total, sólo hay 4 valores posibles para $latex t$ en los que $latex g(i,r)$ no es 0: 0, 1, 2, y 3. Enumerémoslos:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,4) + g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,6) + g(i-1,4) + g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Pero $latex g(i,r) = 0$ si $latex t &amp;gt; 3$, y como $latex t \ge r$, nos quedamos con:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Tomando en cuenta que $latex r$ sólo puede ser 0 o 2, y $latex x_i$ sólo 0 o 1:&lt;/p>
&lt;p>$latex (g(i,0),g(i,2)) = \begin{cases} (g(i-1,0),g(i-1,2)+g(i-1,0)) &amp;amp; \text{si } x_i = 0 \\ (g(i-1,2)+g(i-1,0),g(i-1,2)) &amp;amp; \text{si } x_i = 1 \end{cases}$&lt;/p>
&lt;p>El siguiente código implementa esta solución, que corre en tiempo $latex O(\log n)$ y espacio constante:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702863.js">&lt;/script>
&lt;p>Como podemos observar, esta solución considera los mismos estados que la anterior, sólo que aquí evitamos computarlos, mientras que la otra los descarta inmediatamente.&lt;/p>
&lt;h2>Consideraciones&lt;span class="hx-absolute -hx-mt-20" id="consideraciones">&lt;/span>
&lt;a href="#consideraciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Varios competidores no consideraron que $latex x$ no cabe en un entero signado de 64 bits. Si bien la &lt;em>respuesta&lt;/em> cabe en uno, en los límites del problema se especifica que $latex x &amp;lt; 2^{64}$.&lt;/p>
&lt;h2>Análisis adicional:&lt;span class="hx-absolute -hx-mt-20" id="análisis-adicional">&lt;/span>
&lt;a href="#an%c3%a1lisis-adicional" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;a href="https://omegaup.com/profile/DiegoRoque" target="_blank" rel="noopener">Diego Roque&lt;/a> escribió una solución distinta, la cual detallaré a continuación.&lt;/p>
&lt;p>Consideremos la función $latex f(x)$ como la define el problema: la cantidad de maneras de escribir $latex x$ como una suma de potencias no negativas de 2 sin usar cada una más de 2 veces.&lt;/p>
&lt;p>Enfoquémonos en la paridad de $latex x$ (es decir, el último bit de $latex x$). Si $latex x$ es impar, necesariamente tenemos que poner una vez la potencia $latex 2^0$, porque las otras dos opciones: ponerla 0 veces o ponerla 2 veces cambiarían la paridad de $latex x$. Por lo tanto, $latex f(x) = f(\frac{x-1}{2})$ si $latex x$ es impar. En cambio, si es par, podemos elegir poner la potencia $latex 2^0$ 0 o 2 veces, lo que nos deja con $latex f(x) = f(\frac{x}{2}) + f(\frac{x}{2}-1)$. Sólo falta definir los casos base: $latex f(0) = f(1) = 1$.&lt;/p>
&lt;p>Aquí está su código que implementa esta solución, que corre en tiempo $latex O(\log^2 x \log \log^2 x):$&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702891.js">&lt;/script></description></item><item><title>Solución a "Comesolo"</title><link>https://blog.omegaup.com/posts/solucion-a-comesolo/</link><pubDate>Sat, 14 Sep 2013 05:21:32 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-comesolo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/comesolo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://lhchavez.com" target="_blank" rel="noopener">lhchavez&lt;/a> &lt;strong>Fuente&lt;/strong>: Félix&lt;/p>
&lt;p>Este problema es especial porque es el primero en omegaUp de solo salida! Usualmente lo que debes esperar cuando te enfrentes con uno de esos problemas es que sea un problema NP que no tiene una solución rápida, y usualmente te pedirán que te aproximes lo más posible a la solución óptima. Esto significa que te vas a tener que valer de técnicas ad-hoc y heurísticas para sacar puntos.&lt;/p>
&lt;p>La solución del problema es bastante sencilla de explicar: haz una búsqueda en profundidad intentando todos los posibles movimientos por fuerza bruta hasta que te salga una solución aceptable e imprímela. El problema es que esta estrategia es $latex O(n!)$, y como $latex n$ puede valer hasta 30x30, puedes esperar que el programa corra varios milenios antes de encontrar la solución óptima. Hay tres trucos (en orden de importancia) para obtener una solución decente en un tiempo razonable:&lt;/p>
&lt;ul>
&lt;li>No repetir estados.&lt;/li>
&lt;li>No &amp;ldquo;clavarse&amp;rdquo; con soluciones que parece que son muy buenas, pero en realidad llevan a callejones sin salida.&lt;/li>
&lt;li>Encontrar una manera de darle prioridad a los estados que tengan más probabilidad de llegar a una solución buena.&lt;/li>
&lt;/ul>
&lt;p>La estrategia que yo personalmente seguí fue que cada que encontraba un nuevo estado, obtenía su &lt;a href="http://es.wikipedia.org/wiki/Funci%C3%B3n_hash" target="_blank" rel="noopener">hash&lt;/a> (que resultaba en un entero de 64 bits) y verificaba si no lo había visitado usando una tabla de hash&lt;a href="#note" >*&lt;/a>. Si no la había visitado, encontraba todos los estados vecinos (todos los tableros que resultaban de hacer un movimiento válido) y los guardaba en una fila de acuerdo a la cantidad de puntos (entre más puntos, más adelante en la fila). Luego, elegía aleatoriamente un estado de la fila dándole prioridad a los que estaban más adelante (pues son los que tienen mayor probabilidad de llegar a una buena solución), lo cual también me evitaba seguir un único camino donde me podría atorar. Repetí eso hasta que se me terminó la memoria de la computadora e imprimí la mejor solución.&lt;/p>
&lt;p>A continuación, el pseudocódigo de la solución:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Estado&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_init&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Estado&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tablero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Puedes usar cualquier algoritmo que genere un entero de 64 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># a partir de tablero y puntos. Este es el más sencillo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">53&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">hash&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">siguientes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todas las celdas (i, j) del tablero...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si la celda tiene una pieza...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todos los vecinos contiguos (i+k, j+l)...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Asegúrate que se haya movido \_algo\_.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que pueda brincar dentro del tablero.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="n">or&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nl">N&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que haya brincado una pieza.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que el lugar a donde brinca esté desocupado.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hijo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Estado&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Aumenta la puntuación del hijo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Borra la ficha original y la &amp;#34;comida&amp;#34;.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega la ficha en su posición final.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrégala a la cola correspondiente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">def&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Número aleatorio entre 0 y 1.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">RAND&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_MAX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># El índice de la última cola que estuvo llena.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La cola que se está considerando.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Elige la cola con mayores puntos que no esté vacía como
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># primera opción.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La primer cola tiene probabilidad de 31% de ser elegida.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># La segunda cola tiene probabilidad de 21%, la tercera 14%,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># la cuarta 10% y así sucesivamente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*=&lt;/span> &lt;span class="mf">1.45&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">lastfull&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">hashtable&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">lee&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">estado&lt;/span> &lt;span class="n">original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Estado&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_se&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_haya&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_terminado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_la&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_memoria&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si ya no hay más estados por visitar,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># encontramos la respuesta óptima en algún punto.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nl">Null&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Actualiza |mejor| si hay una respuesta mejor.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">mejor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">puntos&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Repetir estados es malo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="nl">_visitados&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega todos los vecinos.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">siguiente&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="n">partir&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">este&lt;/span> &lt;span class="n">punto&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">mejor&lt;/span>&lt;span class="o">|&lt;/span> &lt;span class="n">contiene&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="n">solución&lt;/span>&lt;span class="p">.&lt;/span> &lt;span class="n">Podemos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># saber qué movimiento se hizo para llegar a él comparando las
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># diferencias entre el tablero de |mejor.padre| y |mejor|. Ya solo es
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># cuestión de imprimir el resultado y listo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Aquí&lt;/span> &lt;span class="n">mucha&lt;/span> &lt;span class="n">gente&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">va&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">quejar&lt;/span> &lt;span class="n">porque&lt;/span> &lt;span class="n">solo&lt;/span> &lt;span class="n">guardar&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">abre&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">puerta&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">haya&lt;/span> &lt;span class="n">dos&lt;/span> &lt;span class="n">estados&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">puede&lt;/span> &lt;span class="n">tener&lt;/span> &lt;span class="n">hasta&lt;/span> &lt;span class="mi">900&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">tengan&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">mismo&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="mi">64&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">por&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">principio&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">palomar&lt;/span>&lt;span class="p">](&lt;/span>&lt;span class="nl">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="c1">//es.wikipedia.org/wiki/Principio_del_palomar)) y esté considerando que ya se visitó un estado que en realidad es nuevo. Si haces las cuentas, la probabilidad de colisión es negligible: la cantidad de estados que podía visitar en mi computadora (27 millones) es significativamente más pequeña que el número de estados necesarios para que la probabilidad de colisión sea de 1% ($latex \\approx 10^{135}$, por la [paradoja del cumpleaños](http://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os)).
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "Colección"</title><link>https://blog.omegaup.com/posts/solucion-a-coleccion/</link><pubDate>Sat, 14 Sep 2013 05:16:07 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-coleccion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/coleccion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> Alexis Cervantes / César Cepeda &lt;strong>Fuente:&lt;/strong> Alexis Cervantes / César Cepeda&lt;/p>
&lt;p>&lt;strong>_Estructura de la solución: _&lt;/strong>¿Qué nos están pidiendo? El problema nos esta pidiendo que encontremos un subconjunto de las tarjetas tal que la suma de todos los puntajes de las tarjetas de ese subconjunto sea la maxima posible, y la suma de sus precios sea menor o igual al dinero con el que cuentas.  En otras palabras lo que se esta buscando es que:&lt;/p>
&lt;p>la suma &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_51.webm" type="video/mp4">
&lt;/video>
sea maxima siempre y cuando &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_52.webm" type="video/mp4">
&lt;/video>
&lt;/p>
&lt;p>donde &lt;em>Xi&lt;/em>** = &lt;strong>{1 si se compró la tarjeta _i&lt;/strong>, **_y 0 si no se compró}&lt;/p>
&lt;p>**_Modelo del espacio de búsqueda como árbol: _**Al final de cuentas, incluso el nombre lo indica, este problema se puede reducir a asignarle a cada tarjeta un 0 ó un 1 dependiendo de si la vamos a comprar o no, por lo que una forma de modelar el espacio de búsqueda sería formar un número binario de &lt;strong>&lt;em>N&lt;/em>&lt;/strong> dígitosy crear todos los valores posibles para dicho número.&lt;/p>
&lt;p>Para formar todos los números, podemos pensar que en el nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> del árbol vamos a decidir si compramos la tarjeta &lt;strong>&lt;em>j&lt;/em>&lt;/strong>, por lo tanto todos los nodos del nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> tendrán dos hijos, uno de ellos indicando que si compramos la tarjeta y el otro indicando que no la compramos.  El árbol de búsqueda queda como se muestra a continuación.&lt;/p>
&lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_53.webm" type="video/mp4">
&lt;/video>
&lt;p>_**Técnica de búsquda a utilizar: **_Dado que tenemos que entregar como resultado el camino con el mayor puntaje de todos , es preciso que revisemos el 100% de los caminos.  &lt;/p>
&lt;p>Una forma de resolver el problema es utilizar búsqued en profundidad, sin embargo el espacio de búsqueda es un árbol binario con &lt;strong>&lt;em>N&lt;/em>&lt;/strong> niveles por tanto de _**2N **_estados.  Para nuestro problema &lt;strong>&lt;em>N=500&lt;/em>&lt;/strong> por lo que el espacio de búsqueda es indescriptiblemente grande, aunque claro que se pueden podar las ramas en las que el precio ya superó a la cantidad de dinero que tenemos, el aplicar la técnica de búsqueda en profundidad en este problema dificilmente alcanzaría para una **_N _**mayor que 24 ó 25.&lt;/p>
&lt;p>Necesitamos por tanto encontrar una poda mucho más agresiva.&lt;/p>
&lt;p>Anteriormente, en el ejemplo de los Tanques, utilizamos la búsqueda en profundidad para encontrar un camino mínimo, por lo tanto, debido a que cada nivel que descendemos el coste aumenta, se podía aplicar la poda de que si obteniamos algún mínimo se podían cortar todas las ramas cuyo coste fuera mayor o igual que el mínimo actual.  Sin embargo al querer encontrar un máximo, esto no es posible, ya que el coste por rama siempre aumenta y lo que queremos es es encontrar el máximo, así que no sabemos si el camino nos va a llevar a algo mejor a menos que lo recorramos todo!&lt;/p>
&lt;p>Pero que pasaría si tuvieramos una función tal que nos permitiera saber cual es el máximo posible que podemos obtener por una cierta rama?  En ese caso, podríamos cortar cualquier rama si supieramos que por ese camino es imposible lograr algo mejor que lo que ya tenemos.&lt;/p>
&lt;p>Esta técnica se conoce como de &amp;ldquo;acotamiento y poda&amp;rdquo;.  La idea es buscar una función que para cada estado del espacio de búsqueda nos de cotas del máximo posible al que se puede llegar por dicho camino y de mínimo seguro que podemos obtener también por ese camino.&lt;/p>
&lt;p>Esta técnica es increíblemente poderosa y conviene que mediten un momento sobre la misma.  Vale la pena hacer notar que no siempre es sencillo encontrar la función de acotamiento correcta.  Ya que una función que de una cota muy alta no nos sirve de mucho, ya que las podas serian pocas, pero una cota incorrecta nos puede hacer que entreguemos resultados incorrectos.  Por lo tanto al utilizar esta técnica, siempre debemos buscar la función que acote lo más posible pero estando siempre 100% seguros de que el resultado que obtuvimos es efectivamente mayor o igual al máximo posible.&lt;/p>
&lt;p>Para este problema voy a definir las dos funciones de acotamiento, llamemos &lt;strong>&lt;em>a(c)&lt;/em>&lt;/strong> a la función que nos da el máximo posible que se puede obtener estando en el nodo **&lt;em>c&lt;/em>**y &lt;em>&lt;strong>b(c)&lt;/strong>&lt;/em> a la función que nos da el mínimo asegurado que tenemos también al estar en el nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  El demostrar que ambas funciones son válidas queda como tarea para el alumno.&lt;/p>
&lt;p>Lo primero que tenemos que hacer es ordenar las tarjetas de acuerdo a la relación &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong>, es decir, cuantos puntos nos dan por cada peso gastado.  Como queremos obtener el máximo puntaje por nuestro dinero obviamente son mejores las tarjetas que nos dan muchos puntos por peso comparadas con las tarjetas que nos dan pocos puntos por cada peso gastado. &lt;em>&lt;strong>OJO: esto no implica que la solución correcta deba tomar siempre las mejores tarjetas, únicamente quiere decir que comparadas individualmente, para nuestro objetivo son mejores las tarjetas que dan más puntos por peso.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Una vez que tengamos todas las tarjetas ordenadas en base a este criterio, iremos decidiendo si las tomamos o no, en ese respectivo orden.  Para cada nodo, nuestras funciones de acotamiento estarán definidas de la siguiente manera:&lt;/p>
&lt;p>&lt;em>&lt;strong>b(c):&lt;/strong>&lt;/em>  Para calcular la cota mínima asegurada del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong> vamos tomando las tarjetas que aún no hemos utilizado según el ordenamiento mientras aún tengamos dinero, en el momento en el que no tengamos más dinero para comprar ahi nos detenemos.  Ese es el mínimo que seguro podemos obtener.&lt;/p>
&lt;p>_**a(c):  **_Para calcular la cota alta, hacemos el mismo procedimiento que en &lt;strong>&lt;em>b&lt;/em>&lt;/strong> (o mejor tomamos el resultado de &lt;strong>&lt;em>b&lt;/em>&lt;/strong> para no recalcular) y con la primera tarjeta que no pudimos tomamos su relacion &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong> y la multiplicamos por el dinero que aún tenemos disponible y lo sumamos a &lt;strong>&lt;em>b&lt;/em>&lt;/strong>.  Así obtenemos el máximo posible que se puede lograr en el subárbol del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  La operación que efectuamos al final fue la de utilizar el dinero que aún tenemos disponible para comprar un &amp;ldquo;pedazo&amp;rdquo; de la mejor tarjeta aún queda, obviamente esto no es posible ya que no podemos comprar pedazos de tarjeta, sin embargo nos sirve para calcular el máximo posible.  &lt;/p>
&lt;p>Demostrar que &lt;strong>&lt;em>b&lt;/em>&lt;/strong> es válida es trivial, sin embargo queda para el lector demostrar que &lt;strong>&lt;em>a&lt;/em>&lt;/strong> es una cota que siempre dará un número mayor o igual al máximo posible que se puede obtener por ese camino.&lt;/p>
&lt;p>Obviamente una vez que tengamos las funciones de acotamiento, podemos hacer nuestra búsqueda almacenando cual es el mejor mínimo asegurado que hemos obtenido hasta el momento y eliminando todas las ramas cuyo máximo asegurado es menor o igual que éste.&lt;/p>
&lt;p>**_Detalles de implementación: _**Para la implementación queda un último detalle que resolver, y este es como vamos a buscar?  Como casi siempre tenemos dos opciones, la primera es la de la búsqueda en profundidad, para la cual se implementa una rutina recursiva y no se requiere de mantener arreglos de memoria externos.  Y la segunda es una búsqueda por amplitud, para la cual requieres de una cola que te permita almacenar los estados proximos a ser evaluados.&lt;/p>
&lt;p>Si optamos por la búsqueda en profundidad, hay un detalle de implementación muy sútil que puede ser de gran ayuda.  Supongan que modelamos el árbol de búsqueda como el que se muestra en la figura de arriba.  Y supongan que nuestro algoritmo de búsqueda revisa primero la rama izquierda, de ser asi, la cota mínima asegurada y la cota máxima del hijo de la izquierda es exactamente igual a la de su padre, por lo que bajariamos un nivel en la búsqueda sin obtener ninguna información nueva, si, en cambio, revisamos primero el hijo de la derecha, entonces estaríamos obteniendo nuevas cotas con información probablemente últil.&lt;/p>
&lt;p>Si se opta por la búsqueda en amplitud, se tiene una ventaja, y esta es que la cola se puede sustituir por un monticulo de modo que se priorice la búsqueda según el nodo que tiene el mejor mínimo asegurado.  Sin embargo aunque esto podría efectivamente reducir la búsqueda bastante no estamos seguros del tamaño que puede llegar a tener la cola y requeririamos que al llenarse la cola el programa pudiera cambiar a una técnica de búsqueda en profundidad, lo cual haría el código más enredado.  Sin embargo si se desea llegar a límites aún mas grandes, esta sería la opción a seguir.  &lt;/p>
&lt;p>&lt;strong>&lt;em>Implementación:&lt;/em>&lt;/strong>  &lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558998.js">&lt;/script></description></item><item><title>Solución a "Ubongo 3D"</title><link>https://blog.omegaup.com/posts/solucion-a-ubongo-3d/</link><pubDate>Sat, 14 Sep 2013 05:04:59 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-ubongo-3d/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/ubongo-3d" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente:&lt;/strong> Miguel Covarrubias&lt;/p>
&lt;p>La solución pone piezas de manera recursiva mientras quepan en el tablero y no se empalmen.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">P&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">regresa&lt;/span> &lt;span class="err">“&lt;/span>&lt;span class="n">Si&lt;/span>&lt;span class="err">”&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">rotación&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">casilla&lt;/span> &lt;span class="n">g&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">cubo&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">al&lt;/span> &lt;span class="n">poner&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">sobre&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">queda&lt;/span> &lt;span class="n">dentro&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">primeros&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="n">niveles&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">empalma&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">otra&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">ya&lt;/span> &lt;span class="n">puesta&lt;/span> &lt;span class="n">entonces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">marca&lt;/span> &lt;span class="n">las&lt;/span> &lt;span class="n">posiciones&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">como&lt;/span> &lt;span class="n">ocupados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">desmarca&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Para rotar una pieza se puede rotar por $latex 0^o$, $latex 90^o$, $latex 180^o$ o $latex 270^o$ alrededor de cada eje. El número de operaciones es aproximadamente (número de rotaciones * número de casillas del tablero * número de cubos de una pieza)$latex ^3 \le (24 * 7 * 5)^3 &amp;lt; 600,000,000$. En los casos de prueba y en el juego todas las soluciones tocan la base del tablero, si no fuera así, solo hay que duplicar el 7 a 14. Para checar si una pieza se puede poner en cierta posición se pueden usar mascaras de bits para los niveles del tablero y para las posiciones ocupadas. Para poner la última pieza se puede comparar todas las rotaciones de los cubos no ocupados contra la última pieza y la complejidad cubica de la solución se reduce a cuadrática.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558928.js">&lt;/script></description></item><item><title>Solución a "Bloqueo"</title><link>https://blog.omegaup.com/posts/solucion-a-bloqueo/</link><pubDate>Tue, 10 Sep 2013 19:35:59 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-bloqueo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/bloqueo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.cimat.mx/~omar" target="_blank" rel="noopener">Khayyam&lt;/a> &lt;strong>Fuente&lt;/strong>: Khayyam&lt;/p>
&lt;p>La primera observación que hay que hacer es que si todas las carreteras son bidireccionales y entre cada par de ciudades existe exactamente un camino que las conecta (usando una o mas carreteras) entonces la representación gráfica del problema es un árbol: los nodos representan las ciudades y las aristas representan las carreteras. La siguiente figura, muestra el árbol que representa el caso de prueba dado como ejemplo. Los nodos rojos representan las ciudades ocupadas, el esfuerzo necesario para destruir cada carretera se muestra junto a la arista correspondiente. Entonces queremos eliminar un subconjunto de aristas de peso total mínimo de tal forma que los nodos rojos queden separados.&lt;/p>
&lt;p>Caso de ejemplo&lt;/p>
&lt;p>Solución&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example_solution.png" alt="" loading="lazy" />&lt;/p>
&lt;p>En problemas relacionados con árboles, es muy natural tratar de dividir el problema en problemas más pequeños que están dados por los sub-árboles del árbol original. Esto además sugiere usar recursión: &amp;ldquo;para resolver un árbol, primero resolvemos recursivamente sus sub-árboles y luego combinamos las sub-soluciones&amp;rdquo;.&lt;/p>
&lt;p>Comencemos con los casos sencillos. Si hay solamente un nodo (el árbol tiene altura 0), entonces no habrá aristas y el esfuerzo total necesario es cero.&lt;/p>
&lt;p>Consideremos ahora un árbol de altura 1 como el de la siguiente figura. Como la raiz no es roja, basta con eliminar una de las dos aristas: elegimos la que requiera menos esfuerzo.&lt;/p>
&lt;p>Caso sencillo: altura 1&lt;/p>
&lt;p>Solución (suponemos que la arista izquierda requiere menos esfuerzo)&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple0.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple1.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Si la raiz fuera roja, entonces tendríamos que eliminar ambas aristas. Con lo anterior nos damos cuenta de que hay dos casos que debemos considerar:&lt;/p>
&lt;ol>
&lt;li>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/li>
&lt;li>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos: la solución óptima es dejar conectado el nodo rojo asociado a la arista mas costosa.&lt;/li>
&lt;/ol>
&lt;p>Lo anterior se ilustra en la siguiente figura (aquí suponemos que la arista de la derecha es la mas costosa de todas):&lt;/p>
&lt;p>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/p>
&lt;p>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora que tenemos la solución para los casos pequeños, veamos si podemos usar estas soluciones para construir la solución del problema general, como en la siguiente figura.&lt;/p>
&lt;p>Si la raiz es roja y el nodo blanco está conectado&lt;br>
a algun descendiente rojo, la solución ya no es correcta&lt;/p>
&lt;p>Aún si la raiz es blanca, no podemos dejar conectado el nodo blanco&lt;br>
ya que si está conectado con un descendiente rojo, la solución sería incorrecta&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Supongamos que ya tenemos la solución para todos los hijos directos de la raíz, es decir, que ya cortamos de manera óptima las aristas de todos los subárboles, de modo que ningún par de nodos rojos se conectan en el sub-árbol. Usando sólo esta información, ¿podemos construir la solución del problema general?. Desafortunadamente, esto no es suficiente: nos gustaría dejar conectados a los hijos blancos, pero si existe un nodo rojo debajo de ellos, entonces tendríamos que desconectarlo también. Lo que necesitamos saber es precisamente si un hijo blanco está conectado con uno de sus descendientes rojos, de ser así diremos que el nodo blanco es &amp;ldquo;peligroso&amp;rdquo;. Si el nodo blanco está desconectado de todos sus descendientes rojos, entonces diremos que es &amp;ldquo;seguro&amp;rdquo;. Entonces tenemos tres tipos de nodos: ocupados, peligrosos y seguros, que representamos como nodos rojos, amarillos y verdes, respectivamente.Con este nuevo concepto, vemos que tenemos dos tipos de soluciones distintas para una raíz blanca: tenemos soluciones peligrosas y soluciones seguras. Es fácil ver que no existen &amp;ldquo;hojas peligrosas&amp;rdquo;, ya que las hojas están ocupadas (rojas) o son seguras (verdes).&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootOneGreen.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/yellowRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/greenRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Reformulemos nuestra solución con este concepto. Si la raíz es roja, entonces debemos desconectarla de todos sus hijos rojos y de todos sus hijos peligrosos. Esto significa que para cada hijo blanco tenemos dos opciones:&lt;/p>
&lt;ul>
&lt;li>Hacer que el hijo sea seguro (verde) y no cortar la arista que lo une con la raíz (puede ser costoso hacerlo seguro, pero con eso nos ahorramos el costo de separarlo de la raíz)&lt;/li>
&lt;li>Hacer que el hijo sea peligroso (amarillo) y cortar la arista que lo une con la raíz (puede ser barato dejarlo inseguro, pero pagamos al separarlo de la raíz)&lt;/li>
&lt;/ul>
&lt;p>Lo anterior resuelve el caso en que la raíz es roja.&lt;/p>
&lt;p>Ahora, si la raíz no es roja, debemos calcular dos soluciones: la solución segura (dejar la raíz verde) y la solución peligrosa (dejar la raíz amarilla). Notemos que la solución segura es exactamente igual al caso anterior. Por otro lado, para la solución peligrosa, debemos dejar la raíz conectada a exactamente un hijo que sea rojo o peligroso. Para elegir cuál de todos los hijos rojos o peligrosos dejaremos conectado, basta iterar sobre todos los hijos y elegir la mejor opción. El código queda como sigue:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559253.js">&lt;/script></description></item><item><title>Solución a "La Venganza de Silvio"</title><link>https://blog.omegaup.com/posts/solucion-a-la-venganza-de-silvio/</link><pubDate>Thu, 08 Aug 2013 02:02:51 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-la-venganza-de-silvio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/VenganzaDeSilvio" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Freddy&lt;/p>
&lt;p>Este problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.&lt;/p>
&lt;h2>Subtarea 1&lt;span class="hx-absolute -hx-mt-20" id="subtarea-1">&lt;/span>
&lt;a href="#subtarea-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para obtener el primer grupo de puntos, sólo basta calcular $latex N^M$ multiplicando a $latex N$ por sí mismo $latex M$ veces, teniendo cuidado de que no haya overflow.&lt;/p>
&lt;h2>Subtarea 2&lt;span class="hx-absolute -hx-mt-20" id="subtarea-2">&lt;/span>
&lt;a href="#subtarea-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar &lt;a href="http://es.wikipedia.org/wiki/Exponenciaci%c3%b3n_binaria" target="_blank" rel="noopener">exponenciación binaria&lt;/a>.&lt;/p>
&lt;p>Sabemos que $latex x^0 = 1$, que $latex (x^n)^2 = x^{2n}$, y que $latex x * x^{n-1} = x^n$ para toda $latex x$ y $latex n$, por lo que podemos escribir la siguiente relación:&lt;/p>
&lt;p>$latex \text{potencia}(N,M) = \begin{cases} 1 &amp;amp; \text{si } M = 0 \\ (potencia(N,M/2))^2 &amp;amp; \text{si } M \text{ es par} \\ N * (potencia(N,(M-1)/2))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>Aplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $latex O(log M)$, ya que en cada paso $latex M$ se reduce a la mitad.&lt;/p>
&lt;h2>Subtarea 3&lt;span class="hx-absolute -hx-mt-20" id="subtarea-3">&lt;/span>
&lt;a href="#subtarea-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $latex M$. Para ello requerimos una observación adicional. Dividir entre $latex 2$ en base $latex 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.&lt;/p>
&lt;p>Podemos aprovechar esta observación guardando $latex M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $latex A$ es el arreglo donde guardamos los bits de $latex M$, está $latex 0$-indexado, tiene $latex k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $latex potencia2(N,k-1)$, donde $latex potencia2$ es:&lt;/p>
&lt;p>$latex \text{potencia2}(N,i) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \\ (potencia2(N,i-1))^2 &amp;amp; \text{si } A[i] = 0 \\ N * (potencia2(N,i-1))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;h2>Subtarea 4&lt;span class="hx-absolute -hx-mt-20" id="subtarea-4">&lt;/span>
&lt;a href="#subtarea-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.&lt;/p>
&lt;p>Por conveniencia, definamos $latex f(i)$ como el número que se obtiene tomando los elementos $latex [0..i]$ del arreglo $latex A$, y $latex f(-1) = 0$. Recordando que multiplicar por $latex 2$ en base $latex 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $latex f(i) = 2f(i-1) + A[i]$.&lt;/p>
&lt;p>Ahora, es simple notar que $latex potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $latex potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.&lt;/p>
&lt;p>Por lo tanto, podemos escribir un ciclo en vez de utilizar recursión.&lt;/p>
&lt;p>Este algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.&lt;/p>
&lt;p>Aquí está la implementación del algoritmo anterior:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559240.js">&lt;/script>
&lt;h2>Consideraciones&lt;span class="hx-absolute -hx-mt-20" id="consideraciones">&lt;/span>
&lt;a href="#consideraciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Hay que tener cuidado de que no haya overflow. Cuando un entero de $latex k$ bits se eleva al cuadrado, puede ahora tener a lo más $latex 2k$ bits. Como $latex m$ puede tener hasta $latex 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.&lt;/p>
&lt;p>También, varios competidores no consideraron el caso en el que se pide calcular $latex N^0 \pmod 1$.&lt;/p></description></item><item><title>Solución a "Cueva"</title><link>https://blog.omegaup.com/posts/solucion-a-cueva/</link><pubDate>Mon, 14 Jan 2013 16:27:54 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-cueva/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P4" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>Después de comprender el problema podemos deducir dos cosas:&lt;/p>
&lt;ul>
&lt;li>Los &lt;strong>N&lt;/strong> puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán &lt;strong>N-1&lt;/strong> aristas y siempre hay un camino entre cualquier par de nodos.&lt;/li>
&lt;li>Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las &lt;strong>Q&lt;/strong> preguntas, ¿el nodo A es un ancestro del nodo &lt;strong>B&lt;/strong>?”, de modo que necesitamos encontrar una manera óptima de saberlo.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Subtarea 1&lt;/strong>&lt;/em>. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si &lt;strong>A&lt;/strong> es ancestro de &lt;strong>B&lt;/strong>, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo &lt;strong>A&lt;/strong> encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo &lt;strong>B&lt;/strong>, si existe un camino del nodo &lt;strong>A&lt;/strong> al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo &lt;strong>A&lt;/strong> es el mismo nodo &lt;strong>B&lt;/strong>, en ambos casos la respuesta es 0.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NQ)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>&lt;em>Subtarea 2.&lt;/em>&lt;/strong> Es notable que esta vez el número de preguntas es mucho mayor, por ello la solución anterior tardaría demasiado. Cambiemos nuestra estrategia, esta vez realicemos una búsqueda en profundidad desde el nodo 1 hasta los demás &lt;strong>N&lt;/strong> nodos, llevando una lista &lt;strong>L&lt;/strong> de los nodos que forman parte del camino desde el nodo 1 hasta el nodo &lt;strong>K&lt;/strong>, incluyendo los nodos 1 y &lt;strong>K&lt;/strong>, esto puede lograrse mediante recursividad.&lt;/p>
&lt;p>La tabla &lt;strong>ancestro[K][M]&lt;/strong> nos permitirá saber si el nodo &lt;strong>M&lt;/strong> es un ancestro del nodo &lt;strong>K&lt;/strong>, dándonos cuenta que todos los ancestros de &lt;strong>K&lt;/strong> se encuentran en la lista &lt;strong>L&lt;/strong> cuando la búsqueda en profundidad llega al nodo &lt;strong>K&lt;/strong>, podemos llenar la tabla &lt;strong>ancestro[K][M]&lt;/strong> durante la búsqueda en profundidad. Con la tabla anterior es fácil responder las preguntas, pues la respuesta depende de &lt;strong>ancestro[B][A]&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N2+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 3&lt;/strong>&lt;/em>. Para obtener los puntos de esta subtarea podemos utilizar cualquier algoritmo para resolver el clásico problema del ancestro común de dos nodos en un árbol, puesto que la respuesta es 1 si el ancestro común entre los nodos &lt;strong>A&lt;/strong> y &lt;strong>B&lt;/strong> es el nodo &lt;strong>A&lt;/strong>. Este problema ya ha sido estudiado ampliamente y tiene diversas formas de ser resuelto con complejidad &lt;strong>O(NlogN)&lt;/strong>, en el foro de tutoriales de TopCoder podemos encontrar un buen artículo con algunos de los algoritmos que pueden ser utilizados:&lt;/p>
&lt;p>&lt;a href="http://community.topcoder.com/tc?module=Static&amp;amp;d1=tutorials&amp;amp;d2=lowestCommonAncestor" target="_blank" rel="noopener">TopCoder Lowest Common Ancestor&lt;/a>&lt;/p>
&lt;p>El algoritmo que utiliza programación dinámica es el más recomendado, puesto que se puede responder a las &lt;strong>Q&lt;/strong> preguntas en un tiempo constante.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NlogN+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 4&lt;/strong>&lt;/em>. Para empezar, notemos que la solución anterior no funciona para este conjunto de puntos porque utiliza demasiada memoria, el simple hecho de almacenar los nodos y las aristas ocupa bastante espacio en memoria (aproximadamente 100Mb) y una solución para la subtarea 3 requeriría al menos 50Mb más, por lo tanto no es posible completar la subtarea 4 con una solución como la anterior, para obtener los 100 puntos en este problema necesitamos una idea mucho más creativa.&lt;/p>
&lt;p>Renombremos todos los nodos del árbol enumerandolos del 1 al &lt;strong>N&lt;/strong> siguiendo el orden establecido por el recorrido en postorden del árbol comenzando por el nodo 1, después, para cada nodo, con su respectivo número &lt;strong>Y&lt;/strong>, hay que obtener el menor número presente en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>, denotemos este número menor como &lt;strong>X&lt;/strong>, con los números &lt;strong>X&lt;/strong> y &lt;strong>Y&lt;/strong> definimos entonces un intervalo cerrado &lt;strong>[X,Y]&lt;/strong> que nos representa que en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong> se contienen todos los nodos cuyo número se encuentra en el intervalo &lt;strong>[X,Y]&lt;/strong>. Podemos interpretar esta información de una manera más conveniente, un nodo con número &lt;strong>Y&lt;/strong> es ancestro de un nodo con número &lt;strong>K&lt;/strong> si &lt;strong>X ≤ K ≤ Y&lt;/strong>, lo cual nos permitirá responder las preguntas planteadas.&lt;/p>
&lt;p>Es recomendable que el olímpico experimente y se convenza que la propiedad del intervalo &lt;strong>[X,Y]&lt;/strong> es siempre correcta debido a que el recorrido en postorden establecerá que el nodo con el número &lt;strong>X&lt;/strong>, que establece la cota inferior del intervalo, siempre será una hoja del subárbol y el nodo con valor &lt;strong>Y&lt;/strong>, que establece la cota superior del intervalo, siempre será la raíz del subárbol, cualquier otro valor fuera del intervalo estará excluido del subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N+Q)&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>Solución a "Chilly Rapero"</title><link>https://blog.omegaup.com/posts/solucion-a-chilly-rapero/</link><pubDate>Sat, 12 Jan 2013 19:41:11 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-chilly-rapero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>La clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.&lt;/p>
&lt;p>Crear las aristas entre los nodos tiene una complejidad de O(LN2) y la manera más simple de almacenar dichas aristas es mediante una matriz de adyacencia. Ya que tenemos el grafo planteado, buscaremos la manera más rápida de cambiar de palabra entre cualquier par de palabras, esto puede conseguirse usando el algoritmo de &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Floyd-Warshall" target="_blank" rel="noopener">Floyd-Warshall&lt;/a> con una complejidad de O(N3) que es suficiente para el problema.&lt;/p>
&lt;p>Finalmente, para obtener la respuesta sumamos el mínimo número de cambios requeridos entre todos los pares de palabras consecutivas en el rap, este número de cambios fue obtenido mediante el algoritmo de Floyd-Warshall. El número total de cambios lo multiplicamos por 0.2 y será la respuesta para el problema.&lt;/p>
&lt;p>Complejidad de la solución: O(LN2+N3)&lt;/p></description></item><item><title>Solución a "Cambio"</title><link>https://blog.omegaup.com/posts/solucion-a-cambio/</link><pubDate>Tue, 08 Jan 2013 17:18:25 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-cambio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Lo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.&lt;/p>
&lt;h2>Solución de 30, 50 puntos&lt;span class="hx-absolute -hx-mt-20" id="solución-de-30-50-puntos">&lt;/span>
&lt;a href="#soluci%c3%b3n-de-30-50-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.&lt;/p>
&lt;h2>Solución de 100 puntos&lt;span class="hx-absolute -hx-mt-20" id="solución-de-100-puntos">&lt;/span>
&lt;a href="#soluci%c3%b3n-de-100-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Consideremos la solución anterior y tratemos de calcularlo de abajo hacia arriba, habría que crear una función que nos dijera para una cantidad dada y un set de monedas que se pueden usar (para no repetir) nos diga cuantas formas distintas hay de completar dicha cantidad. Si se logra construir dicha función la solución al problema es simple puesto que se reduce a llamar dicha función con la cantidad que nos piden y el set completo de monedas. Lo interesante radica en cómo se compone dicha función, suponiendo que la función funciona hay que tratar de construirla, primero hay que considerar los casos especiales, si la cantidad es cero significa que no hay que hacer nada y entonces hay una forma de lograrlo (es una combinación válida), si la cantidad es mayor a cero hay que sumar las combinaciones de tomar una moneda de la primera denominación disponible con las de dejar de tomar monedas de dicha denominación.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Para calcular las combinaciones de tomar una moneda de dicha denominación se puede usar la función a partir de la cantidad restante (la cantidad buscada menos la denominación de la moneda) y el mismo set de monedas.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Para calcular las combinaciones de dejar de tomar monedas de cierta denominación de igual forma se puede usar la función con la misma cantidad pero con un set de monedas que no incluya la denominación que decidimos dejar de tomar.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Si se toma la moneda sin considerar si la denominación es más grande que la cantidad entonces existe el caso donde la cantidad es negativa y en ese caso la respuesta debiera ser cero puesto que es una combinación no válida.&lt;/p>
&lt;p>De igual forma si el set de denominaciones disponibles está vacío significa que ya no hay más denominaciones para probar y por lo tanto no hay ninguna forma de lograrlo.&lt;/p>
&lt;p>Como podemos notar dicha función es recursiva y se llama a si misma hasta que la cantidad se vuelve cero, negativa y/o el set de denominaciones queda vació, y si lo analizamos un poco podemos darnos cuenta de que funciona. La forma simple de saber que set de monedas es usable es guardar el índice de la primera moneda usable y eliminarlas en orden. Hay que notar que hasta el momento no hemos mejorado en nada la solución anterior, y la complejidad de esto es similar a la de nuestra idea anterior.&lt;/p>
&lt;p>Lo que hay que notar es que la cantidad no tendrá más de 10,000 valores distintos y que nunca habrá más de 100 sets distintos, por lo tanto dicha función solo se puede mandar a llamar 1,000,000 de veces con parámetros distintos. Sin embargo sabemos que la cantidad de combinaciones puede llegar a ser mucho mayor. Entonces ¿Qué sucede?, pues es sencillo darse cuenta que dicha función se mandará a llamar más de una vez con los mismos parámetros y en todos esos casos siempre deberá entregar la misma solución, es por esto que podemos guardar las respuestas para cada uno de los casos en un array y así nunca tener que calcularlos más de una vez, esto hace que nuestro programa pueda correr en tiempo.&lt;/p>
&lt;p>&lt;em>El asunto de los módulos creo que es algo que debiesen saber sin embargo les digo que el modulo se puede aplicar al sumar el tomar y el no tomar, puesto que (A + B) modulo X es igual a (A modulo X + B modulo X ) modulo X.&lt;/em>&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559217.js">&lt;/script></description></item><item><title>Solución a "Minecraft"</title><link>https://blog.omegaup.com/posts/solucion-a-minecraft/</link><pubDate>Tue, 08 Jan 2013 17:14:15 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-minecraft/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Este problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.&lt;/p>
&lt;h2>Para los primeros 50 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-primeros-50-puntos">&lt;/span>
&lt;a href="#para-los-primeros-50-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.&lt;/p>
&lt;h2>Para los 75 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-75-puntos">&lt;/span>
&lt;a href="#para-los-75-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.&lt;/p>
&lt;h2>Para los 100 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-100-puntos">&lt;/span>
&lt;a href="#para-los-100-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución era para aquellos que supieran hacer una búsqueda utilizando una cola de prioridad. La idea es que al sacar un elemento de la cola siempre nos dé aquel al que se puede llegar con la menor cantidad de movimientos. Este procedimiento es idéntico a una búsqueda en amplitud solo que se utiliza una cola de prioridad. En la solución hago uso de un montículo como cola de prioridad.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559202.js">&lt;/script></description></item><item><title>Solución a "Metro"</title><link>https://blog.omegaup.com/posts/solucion-a-metro/</link><pubDate>Mon, 07 Jan 2013 17:22:45 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-metro/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>El problema en cuestión se reduce a encontrar un árbol de expansión mínima. La solución es una aplicación directa de alguno de los algoritmos existentes para ello (bien implementada), por lo que hablaré brevemente sobre una de las posibilidades y daré referencias donde puedan encontrar información más detallada.&lt;/p>
&lt;p>Para encontrar el costo mínimo de unir todas las estaciones debemos encontrar el árbol de expansión mínima de la gráfica en cuestión (es decir, una subgráfica conexa que una todos los vértices de la gráfica original y cuyo peso (la suma de los costos de todas sus aristas) sea el mínimo posible (siempre es un árbol)). Para ello una opción es usar el algoritmo de Kruskal: Ordenamos las aristas por su peso y vamos agregando cada arista de peso mínimo que no cree un ciclo en la gráfica. Hacemos esto hasta haber conectado todos los vértices de nuestra gráfica. Por la cantidad de aristas que tenemos requerimos ordenar eficientemente y verificar si las aristas forman un ciclo o no eficientemente en cada paso, de lo contrario el programa no correrá en tiempo.&lt;/p>
&lt;p>Para verificar si se forma o no un ciclo agregando una determinada arista empleamos el algoritmo conocido como Union Find, que se explica ampliamente en las secciones 16.7, 16.8 y 16.9 del libro Problemas y Algoritmos de Luis E. Vargas Azcona. Es importante mencionar que para obtener los 100 puntos en el problema es necesario implementar las optimizaciones que se mencionan (y aunque no fuera así no está de más que las conozcan).&lt;/p>
&lt;p>Además del libro de Luis E. Vargas, que recomiendo ampliamente, sugiero la página de Pier Guillen &lt;a href="http://pier.guillen.com.mx/" target="_blank" rel="noopener">http://pier.guillen.com.mx/&lt;/a> , que en -&amp;gt;Algorithms -&amp;gt;10. Gráficas -&amp;gt;10.6 Árboles Mínimos Generadores desarrolla el tema en cuestión. Y claro, no está de más que consulten el tema en el libro Introduction to Algorithms de Thomas H. Cormen, que en la tercera edición trabaja el tema en el capítulo VI. Graph Algorithms -&amp;gt;23 Minimum Spanning Trees.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559170.js">&lt;/script></description></item><item><title>Solución a "Pulseras"</title><link>https://blog.omegaup.com/posts/162/</link><pubDate>Mon, 07 Jan 2013 16:58:46 +0000</pubDate><guid>https://blog.omegaup.com/posts/162/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Considero este problema como un buen ejemplo para quienes desean comenzar a trabajar con problemas de programación dinámica. Se nos pide calcular la cantidad de pulseras diferentes que se pueden construir bajo ciertas condiciones. Podemos comenzar preguntándonos, ¿qué sucede si la primera cuenta es negra? La siguiente podrá ser sólo blanca. Y si comenzamos con una blanca, la siguiente puede ser negra o blanca. Podemos entonces en una matriz de 2xn colocar en cada columna cuántas secuencias distintas hay que en la posición i-ésima terminen en negro y cuántas en blanco de tal modo que no haya dos cuentas negras consecutivas. Simplemente, para obtener los números de la siguiente posición, observamos que el número de las que terminan en blanco es la suma de ambos números de la posición anterior y de las que terminan en negro es el número de secuencias que terminan en blanco de la posición anterior.&lt;/p>
&lt;p>Resta solo un detalle más a considerar. Requerimos que la secuencia no inicie y termine en negro, pues los extremos quedarán adyacentes al cerrar la pulsera. Una forma de resolver esto es la siguiente: Contamos, con el método descrito, cuántas secuencias distintas hay que inicien con blanco y que no tengan dos cuentas negras consecutivas. El número que nos pide el problema será entonces la cantidad de pulseras que empiezan con blanco y cumplen con que no haya dos negras consecutivas (independientemente de con qué color terminen) más el número de pulseras que inicien con negro y terminen con blanco (y claro, cumplan con que no haya dos negras consecutivas). ¿Cuántas hay de estas últimas? La misma cantidad que de pulseras que inician con blanco y terminan con negro, pues su simétrica inicia con negro, termina con blanco y claramente sigue cumpliendo el que no posea dos cuentas negras consecutivas. Así que es posible resolver el problema con un código muy breve, como se muestra abajo.&lt;/p>
&lt;p>Solo resta mencionar que hay que tener cuidado de aplicar el módulo correctamente. Se pueden evitar errores definiendo el valor del mismo para no tener que escribir el número varias veces.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559167.js">&lt;/script></description></item><item><title>Solución a "Los Bloques de Link"</title><link>https://blog.omegaup.com/posts/solucion-a-los-bloques-de-link/</link><pubDate>Mon, 07 Jan 2013 16:54:06 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-los-bloques-de-link/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Es claro que no es posible probar todas las sucesiones posibles de movimientos de los bloques para encontrar la solución (a excepción de casos muy simples). El número de tales sucesiones puede ser infinito en caso de que se puedan formar ciclos de movimientos (lo cual sucede en muchos de lo casos de prueba), y aún en casos donde el número sea finito puede suceder que no se tenga tiempo para probarlos todos.&lt;/p>
&lt;p>Una primera observación crucial es que, en el estado del mapa, solo nos interesa saber donde están los bloques de hielo en cada paso, es decir, su ubicación es lo que determina lo que nos interesa del estado. No nos interesan los pasos previos que los llevaron a su posición, solo que sea el número mínimo posible. Tenemos un problema que puede ser resuelto realizando una búsqueda en amplitud.&lt;/p>
&lt;p>¿Cuántos estados es posible alcanzar? El mapa es a lo más de 40x40 espacios y las orillas siempre están bloqueadas, así que realmente tenemos 38x38=1444 espacios a los que quizá es posible llevar a los bloques. Tenemos dos bloques de hielo, así que hay (1444x1443)/2=1,041,846 formas de colocarlos en el mapa (hemos considerado aquí ya el hecho de que son indistinguibles). Para fines de la búsqueda el número que hemos calculado es en realidad una cota superior muy mala (mala en el sentido de que la cota superior mínima es muy inferior, es decir, calculamos “de más”), pues por la forma en que se mueven los bloques es claro que aún en el peor de los casos posibles la cantidad de estados a los que se puede acceder es mucho menor (¿cuál es el peor de los casos?). Es posible entonces emplear una búsqueda en amplitud común para resolver el problema, el espacio de búsqueda no es muy grande y es claro que podemos recorrerlo por completo.&lt;/p>
&lt;p>Para representar los estados requerimos tener la posición de ambos bloques, y nada más. Podemos emplear una arreglo de bool&amp;rsquo;s (boolean&amp;rsquo;s en pascal) de cuatro dimensiones para marcar los estados a los que se ha accedido. Para la cola, en el código que se anexa más abajo, empleamos un arreglo de dos dimensiones (una matriz) donde además de guardar la posición de los bloques de los estados guardamos la cantidad de movimientos realizados para llegar a cada estado. Para ver a que estados podemos llegar desde un estado dado basta con ver en que direcciones es posible mover los bloques y a qué posición llegarán.&lt;/p>
&lt;p>Para optimizar la búsqueda podemos hacer dos observaciones. La primera es que con nuestra representación de los estados podríamos llegar dos veces al mismo estado, ya que los dos bloques de hielo son para nuestros fines iguales. En el código de abajo es por ello que al llegar a un estado nuevo se marcan dos valores en el arreglo de bools como verdaderos, pues ambos representan en realidad el mismo estado.&lt;/p>
&lt;p>Otra observación es que para averiguar eficientemente a que estados se puede llegar desde un estado dado podemos precalcular, antes de realizar la búsqueda, para cada espacio vacío o con bloque de hielo, cuál es la posición del espacio bloqueado (con numeral # o con el botón A) más cercano en cada dirección. Así solo habrá que comparar esa posición con la del otro bloque de hielo para ver a dónde llegará el bloque tras su movimiento. Esto puede mejorar el tiempo de ejecución para un caso dado, aunque no siempre es así. En este problema para obtener los 100 puntos no hacen falta optimizaciones de este tipo, aunque es bueno tener este tipo de ideas en mente para problemas más complejos.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559163.js">&lt;/script></description></item><item><title>Solución a "Problema"</title><link>https://blog.omegaup.com/posts/solucion-a-problema/</link><pubDate>Mon, 07 Jan 2013 16:34:20 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-problema/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Primero, dado una secuencia $latex A$ denotaremos por $latex s(A)$ a la suma de los elementos de A. Entonces podemos replantear el problema como: Dada una secuencia $latex S$ debemos de econtrar una subsecuencia $latex A$ de $latex S$ tal que $latex s(A) - (s(S) - s(A))$ sea la minima posible.&lt;/p>
&lt;p>Ahora, como $latex s(A) - (s(S) - s(A)) = 2 \times s(A) - s(S)$, entonces tenemos que minimizar $latex 2 \times s(A) - s(S)$ que es lo mismo que minimizar $latex s(A) - s(S)/2$. O sea, debemos de encontrar una subsecuencia $latex A$ cuya suma esté lo más cercana a la mitad de la suma de $latex S$, en particular podemos restringir nuestra búsqueda a las subsecuencias cuya suma sea menor o igual a $latex s(S)/2$.&lt;/p>
&lt;p>Se plantea para este problema una solución de tipo &lt;em>Programación Dinámcia&lt;/em> que corre sobre los elementos de la secuencia $latex S$ y considera todas las posibles diferentes sumas de subsecuencias cuyos elementos tienen índices menores o iguales al actual y cuya suma no excede $latex s(S)/2$. Se tendrán entonces $latex n \times s(S)/2$ posibles estados y cada uno podrá ser procesado en tiempo constante ya que solo hay dos trancisiones posibles para cada estado: Se toma el elemento actual dentro de la subsecuencia o no. Por lo tanto la solución tendrá una complejidad temporal de $latex O (n \times s(S))$.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559155.js">&lt;/script></description></item><item><title>Solución a "Alfiles"</title><link>https://blog.omegaup.com/posts/solucion-a-alfiles/</link><pubDate>Mon, 07 Jan 2013 16:23:49 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-alfiles/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Lo primero que se debe de notar es que en cada una de las $latex 2n-1$ diagonales principales, las cuales mostradas en la imagen de abajo, habrá máximo 1 alfil. Lo mismo se cumple para las diagonales invertidas, mostradas también en una imagen abajo.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic1.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic2.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora, cada diagonal principal se cruza con ciertas diagonales invertidas. Entonces se plantea una solución de tipo &lt;em>Backtracking&lt;/em> que corre sobre las diagonales principales marcando diagonales invertidas a cada paso (representando que se ha colocado un alfil en el cruce de esas dos diagonales).&lt;/p>
&lt;p>Una implementación directa y sin optimizaciones ni podas para los casas donde $latex n = 8$ hará uso de $latex 1\times2\times3\times4\times5\times6\times7\times8\times7\times6\times5\times4\times3\times2\times1=203212800$ operaciones, lo cual no está muy lejos de ser una solución eficiente. Entonces bastan algunas podas para obtener una solución al 100%, podemos por ejemplo podar las ramas de la recursión que consideran combinaciones con una diagonal invertida repetida.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559152.js">&lt;/script></description></item><item><title>Solución a "Mario Reloaded"</title><link>https://blog.omegaup.com/posts/solucion-a-mario-reloaded/</link><pubDate>Mon, 07 Jan 2013 16:08:32 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-mario-reloaded/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:paspartu@gmail.com" >Pavel Herrera Dominguez&lt;/a>)&lt;/p>
&lt;h2>Observaciones&lt;span class="hx-absolute -hx-mt-20" id="observaciones">&lt;/span>
&lt;a href="#observaciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Lo primero es ver como se modelan los estados del problema sin pensar en que Mario puede tomar los atajos, únicamente pensar en las llaves, claramente existen $latex n\times2^m$ estados, pues no importa el orden en que se toman las llaves solo las llaves que se tienen al llegar a cada puerta. A partir de aquí nos referiremos como estado a la puerta y las llaves que trae Mario.&lt;/p>
&lt;p>La segunda observación es ver como afecta llegar a una puerta con cierto juego de llaves, osea a cada estado. Cada vez que visitamos un estado todos los estados ya visitados que tienen el mismo juego de llaves se actualiza instantáneamente. Esto se puede entender como si únicamente el juego de llaves definiera el estado, lo que nos lleva a pensar que el problema es saber que puertas pertenecen a qué juego de llaves.&lt;/p>
&lt;p>De la observación anterior podemos pensar que si mantenemos una lista de puertas ya visitadas para cada juego de llaves, cuando algún estado (puerta, juego de llaves) se visita con un menor tiempo, todas las puertas alcanzadas con ese juego de llaves deben ser actualizadas y sus respectivos vecinos.&lt;/p>
&lt;h2>Idea&lt;span class="hx-absolute -hx-mt-20" id="idea">&lt;/span>
&lt;a href="#idea" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>La idea es hacer una especie de búsqueda en amplitud la cual tome en cuenta las observaciones anteriores. Esto es una búsqueda que visite los estados (puerta, llave) y conserve una lista de las puertas alcanzables con cada juego de llaves.&lt;/p>
&lt;h2>Implementacion&lt;span class="hx-absolute -hx-mt-20" id="implementacion">&lt;/span>
&lt;a href="#implementacion" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559138.js">&lt;/script>
&lt;h2>Tarea&lt;span class="hx-absolute -hx-mt-20" id="tarea">&lt;/span>
&lt;a href="#tarea" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Pensar si es posible hacer la búsqueda sin usar los estados (puerta, juego de llaves).&lt;/p></description></item><item><title>Solución a "El collar de perlas"</title><link>https://blog.omegaup.com/posts/solucion-a-el-collar-de-perlas/</link><pubDate>Thu, 03 Jan 2013 16:01:37 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-el-collar-de-perlas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://goldendarknut.blogspot.mx/" target="_blank" rel="noopener">Félix Rafael Horta Cuadrilla&lt;/a>&lt;/p>
&lt;p>En una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.&lt;/p>
&lt;p>Para resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero &lt;em>i&lt;/em> en cualquier lista representa al enano &lt;em>i&lt;/em>.&lt;/p>
&lt;p>Durante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.&lt;/p>
&lt;p>En algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.&lt;/p>
&lt;p>&lt;strong>Problema&lt;/strong>&lt;/p>
&lt;p>Escribe un programa que ayude a los enanos verdes a obtener el diamante, sabiendo de antemano las listas de todos los enanos. Puedes asumir que los enanos rojos juegan de manera optima. Se garantiza que siempre habra una forma en la que los enanos verdes puedan ganar si juegan optimamente.&lt;/p>
&lt;p>&lt;strong>Entrada&lt;/strong>&lt;/p>
&lt;p>La primer linea contiene la longitud &lt;strong>L&lt;/strong> del collar, el numero &lt;strong>N&lt;/strong> de enanos y el numero &lt;strong>F&lt;/strong> que representa el enano que empieza con el collar.&lt;/p>
&lt;p>La segunda linea contiene &lt;strong>L&lt;/strong> caracteres (seguidos, es decir, &lt;strong>NO&lt;/strong> hay espacios entre ellos) que representan el collar, estos caracteres pueden ser una letra &lt;strong>B&lt;/strong> que significa que es una perla blanca, una letra &lt;strong>N&lt;/strong> que significa que es una perla negra o una &lt;strong>D&lt;/strong> que indica que es el diamante. Solo habra un diamante y este siempre estara al final del collar.&lt;/p>
&lt;p>Las siguientes &lt;strong>N&lt;/strong> lineas describen a los enanos y sus listas. Cada linea esta formada por un numero &lt;strong>C&lt;/strong> que representa el color del enano (0 si es verde y 1 si es rojo) seguido por la longitud &lt;strong>LN&lt;/strong> de la lista negra y de &lt;strong>LN&lt;/strong> numeros, representando cada uno de los numeros en la lista negra del enano. Finalmente, en la misma linea, el numero &lt;strong>LB&lt;/strong> que indica la longitud de la lista blanca del enano y de &lt;strong>LB&lt;/strong> numeros indicando los elementos de dicha lista.&lt;/p>
&lt;p>&lt;strong>Límites&lt;/strong>&lt;/p>
&lt;p>1 &amp;lt;= L &amp;lt;= 1000&lt;/p>
&lt;p>1 &amp;lt;= N &amp;lt;= 1000&lt;/p>
&lt;p>&lt;strong>Interacción&lt;/strong>&lt;/p>
&lt;p>Este problema es interactivo y deberas escribir una funcion llamada &lt;em>juega()&lt;/em> que lea de pantalla el problema los datos de entrada y se cominique con tres funciones en una libreria.&lt;/p>
&lt;p>Las tres funciones con las que hay que interactuar son las siguientes:&lt;/p>
&lt;p>    void pasaCollar(int enano);&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos verdes posea el collar, tu programa mande el collar al enano especificado como parametro. Llamar a &lt;em>pasaCollar&lt;/em> cuando no le corresponde o pasar el collar a un enano que no este en la lista correspondiente resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>    int recibeCollar();&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos rojos posea el collar, tu programa llame a esta funcion para saber a que enano paso el collar el evaluador. Llamar a esta funcion cuando no le corresponde el turno a un enano rojo resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>void termina();&lt;/p>
&lt;p>Debe ser llamada una vez cuando en el collar solo quede el diamante. Si se llama en otro momento o si se llama y el collar esta en posesion de un enano rojo obtendras cero puntos en ese caso. Solo recibiras puntos si llamas a la funcion &lt;em>termina()&lt;/em> cuando el collar este en posesion de un enano verde y el collar solo posea al diamante.&lt;/p>
&lt;p>&lt;strong>Ejemplo&lt;/strong>&lt;/p>
&lt;p>Entrada&lt;/p>
&lt;p>6 4 2&lt;br>
NBBNND&lt;br>
0 1 2 1 4&lt;br>
0 2 1 3 1 1&lt;br>
1 1 4 1 4&lt;br>
1 2 2 3 1 1&lt;/p>
&lt;p>Salida&lt;/p>
&lt;p>pasaCollar(1)&lt;br>
pasaCollar(4)&lt;br>
recibeCollar() -&amp;gt; 1&lt;br>
pasaCollar(2)&lt;br>
pasaCollar(1)&lt;br>
termina()&lt;/p>
&lt;p>&lt;strong>Compilación&lt;/strong>&lt;/p>
&lt;p>Se proporcionan plantillas para facilitar la codificación del problema, de esa forma sólo necesitas codificar el archivo perlas.c/perlas.cpp/perlas.pas. Las plantillas son solo para facilitar la codificación y las pruebas, &lt;strong>no se garantiza que se evaluará con las mismas&lt;/strong>.&lt;/p>
&lt;p>Utilizando la plantilla proporcionada, puedes compilar este programa correctamente en C++ de la siguiente forma:&lt;/p>
&lt;p>    g++ main.cpp perlas.cpp -o perlas&lt;/p>
&lt;p>En C, se hace de la siguiente forma:&lt;/p>
&lt;p>    g++ main.c perlas.c -o perlas&lt;/p>
&lt;p>Mientras que para Pascal:&lt;/p>
&lt;p>fpc main.pas&lt;/p>
&lt;p>De la misma forma, las opciones de compilación pueden ser diferentes en la evaluación, sin embargo, si tu programa compila con las plantillas, también debería de hacerlo en el evaluador.&lt;/p>
&lt;p>&lt;strong>Descarga las plantillas &lt;a href="https://www.dropbox.com/sh/nux63uknmdyzgej/sfqTP9Tng8/plantillas.rar" target="_blank" rel="noopener">aquí&lt;/a> .&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Solución&lt;/strong>&lt;/p>
&lt;p>Una manera sencilla de tratar de ganar en este juego, es hacer una búsqueda sobre las listas de los enanos verdes y siempre pasar el collar sobre los enanos verdes, lo cual resolvería un par de casos. Sin embargo, en la mayor parte de los casos, es necesario pasar el collar a un enano rojo que eventualmente lo regresará a un enano verde. Y este es precisamente el problema, saber cuándo pasar a un enano rojo y a qué enano rojo, y como se necesita de la interacción de los enanos rojos para llegar a la solución, un gran problema se presenta.&lt;/p>
&lt;p>Aunque este problema podría resolverse fácilmente con una búsqueda memorizada haciendo las llamadas a las funciones durante la búsqueda, no puede hacerse de esta forma porque cuando se hace una búsqueda se requiere poder ir hacia adelante y hacia atrás en el árbol de búsqueda, y como se necesita de la interacción de los enanos rojos, se tiene que lograr la solución en la primera pasada.&lt;/p>
&lt;p>Por lo tanto hay que calcular todas las posibles tiradas antes de jugar, considerando las mejores tiradas de los enanos rojos. De esta forma, una vez que se tiene  una jugada para ganar el juego para &lt;strong>cualquier estado posible&lt;/strong>, se puede jugar teniendo seguro el triunfo.&lt;/p>
&lt;p>Ahora, aunque sabemos que no se puede resolver con una búsqueda, sí podemos utilizar un árbol de búsqueda para resolver el problema, pero ¿cómo tomar en cuenta las elecciones de los enanos rojos?, la respuesta a esto es jugar para ambos equipos y usar el mismo cósigo para ello, eligendo siempre la mejor opción para &lt;strong>el color de enano&lt;/strong> en cada turno, es decir, cuando la búsqueda esté sobre un enano rojo, hay que elegir la opción que haga que los enanos rojos ganen, y cuando la búsqueda esté sobre un enano verde, hay que elegir la opción que haga ganar a los enanos verdes.&lt;/p>
&lt;p>Es evidente que cuando las hojas del árbol terminan en un enano verde, se gana el juego (esos estados son estados ganadores), y cuando termina en un enano rojo el juego se pierde (esos estados son estados perdedores), eso es fácil, lo difícil son los siguientes niveles.&lt;/p>
&lt;p>Tomando en cuenta esto necesitamos etiquetar todos los estados como estados ganadores o estados perdedores, debido a que ya sabemos qué son los estados hojas, podemos deducir qué son los estados anteriores a las hojas de la siguiente forma: Si el estado pertenece a un enano verde, nos basta con que UN y solo UN enano en su lista lleve a un estado ganador, ya que como enanos verdes podemos controlar a quien le pasamos el collar, por lo que basta con que el estado pueda llevar a un estado ganador para que también sea un estado ganador. Si el enano verde NO lleva a ningún estado ganador, entonces ese estado NO es un estado ganador, por que no importa a quien se lo pases, siempre perderás.&lt;/p>
&lt;p>Pensando de esta misma forma, si el estado pertenece a un enano rojo, necesitamos que TODOS los estados a los que conduzca sean estados ganadores, por que si hay solo un estado perdedor, los enanos rojos, que juegan con la mejor estrategia, siempre eligirán ese estado.&lt;/p>
&lt;p>De esta forma, es posible que haya enanos verdes a los que quieras evitar, y enanos rojos a los que quieras pasarle el collar.&lt;/p>
&lt;p>Entonces, para resolver el problema, hay que pasar por todos los estados y marcarlos como estados ganadores o estados perdedores con la técnica que más te guste, ya sea programación dinámica o búsqueda memorizada, pero hay que hacerlo antes de jugar. Una vez teniendo precalculado cuáles son los estados ganadores y perdedores, solo hay que hacer las llamadas de los enanos verdes siempre hacia estados ganadores.&lt;/p>
&lt;p>&lt;a href="http://elira.operamail.com/files/perlas.rar" target="_blank" rel="noopener">DESCARGAR ARCHIVOS Y SOLUCIÓN&lt;/a>&lt;/p></description></item></channel></rss>