<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Silvio</title><link>https://blog.omegaup.com/tags/silvio/</link><description>Recent content in Silvio on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 08 Aug 2013 02:02:51 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/silvio/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "La Venganza de Silvio"</title><link>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</link><pubDate>Thu, 08 Aug 2013 02:02:51 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-la-venganza-de-silvio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/VenganzaDeSilvio" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Freddy&lt;/p>
&lt;p>Este problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.&lt;/p>
&lt;h2>Subtarea 1&lt;span class="hx-absolute -hx-mt-20" id="subtarea-1">&lt;/span>
&lt;a href="#subtarea-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para obtener el primer grupo de puntos, sólo basta calcular $latex N^M$ multiplicando a $latex N$ por sí mismo $latex M$ veces, teniendo cuidado de que no haya overflow.&lt;/p>
&lt;h2>Subtarea 2&lt;span class="hx-absolute -hx-mt-20" id="subtarea-2">&lt;/span>
&lt;a href="#subtarea-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar &lt;a href="http://es.wikipedia.org/wiki/Exponenciaci%c3%b3n_binaria" target="_blank" rel="noopener">exponenciación binaria&lt;/a>.&lt;/p>
&lt;p>Sabemos que $latex x^0 = 1$, que $latex (x^n)^2 = x^{2n}$, y que $latex x * x^{n-1} = x^n$ para toda $latex x$ y $latex n$, por lo que podemos escribir la siguiente relación:&lt;/p>
&lt;p>$latex \text{potencia}(N,M) = \begin{cases} 1 &amp;amp; \text{si } M = 0 \\ (potencia(N,M/2))^2 &amp;amp; \text{si } M \text{ es par} \\ N * (potencia(N,(M-1)/2))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>Aplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $latex O(log M)$, ya que en cada paso $latex M$ se reduce a la mitad.&lt;/p>
&lt;h2>Subtarea 3&lt;span class="hx-absolute -hx-mt-20" id="subtarea-3">&lt;/span>
&lt;a href="#subtarea-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $latex M$. Para ello requerimos una observación adicional. Dividir entre $latex 2$ en base $latex 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.&lt;/p>
&lt;p>Podemos aprovechar esta observación guardando $latex M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $latex A$ es el arreglo donde guardamos los bits de $latex M$, está $latex 0$-indexado, tiene $latex k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $latex potencia2(N,k-1)$, donde $latex potencia2$ es:&lt;/p>
&lt;p>$latex \text{potencia2}(N,i) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \\ (potencia2(N,i-1))^2 &amp;amp; \text{si } A[i] = 0 \\ N * (potencia2(N,i-1))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;h2>Subtarea 4&lt;span class="hx-absolute -hx-mt-20" id="subtarea-4">&lt;/span>
&lt;a href="#subtarea-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.&lt;/p>
&lt;p>Por conveniencia, definamos $latex f(i)$ como el número que se obtiene tomando los elementos $latex [0..i]$ del arreglo $latex A$, y $latex f(-1) = 0$. Recordando que multiplicar por $latex 2$ en base $latex 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $latex f(i) = 2f(i-1) + A[i]$.&lt;/p>
&lt;p>Ahora, es simple notar que $latex potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $latex potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.&lt;/p>
&lt;p>Por lo tanto, podemos escribir un ciclo en vez de utilizar recursión.&lt;/p>
&lt;p>Este algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.&lt;/p>
&lt;p>Aquí está la implementación del algoritmo anterior:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559240.js">&lt;/script>
&lt;h2>Consideraciones&lt;span class="hx-absolute -hx-mt-20" id="consideraciones">&lt;/span>
&lt;a href="#consideraciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Hay que tener cuidado de que no haya overflow. Cuando un entero de $latex k$ bits se eleva al cuadrado, puede ahora tener a lo más $latex 2k$ bits. Como $latex m$ puede tener hasta $latex 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.&lt;/p>
&lt;p>También, varios competidores no consideraron el caso en el que se pide calcular $latex N^0 \pmod 1$.&lt;/p></description></item></channel></rss>