<!doctype html><html lang=es-mx><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>omegaUp blog</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Incrementando el talento de Ingeniería de Software en América Latina"><meta name=generator content="Hugo 0.136.5"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/ananke/css/main.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Libre+Franklin%3A300%2C300i%2C400%2C400i%2C600%2C600i%2C800%2C800i&amp;#038;subset=latin%2Clatin-ext"><link rel=stylesheet href=/css/styles.css><link href=/tags/soluciones-preselectivo-2013/index.xml rel=alternate type=application/rss+xml title="omegaUp blog"><link href=/tags/soluciones-preselectivo-2013/index.xml rel=feed type=application/rss+xml title="omegaUp blog"><meta property="og:url" content="https://blog.omegaup.com/tags/soluciones-preselectivo-2013/"><meta property="og:site_name" content="omegaUp blog"><meta property="og:title" content="Soluciones Preselectivo 2013"><meta property="og:description" content="Incrementando el talento de Ingeniería de Software en América Latina"><meta property="og:locale" content="es_mx"><meta property="og:type" content="website"><meta itemprop=name content="Soluciones Preselectivo 2013"><meta itemprop=description content="Incrementando el talento de Ingeniería de Software en América Latina"><meta itemprop=datePublished content="2014-01-23T03:51:39+00:00"><meta itemprop=dateModified content="2014-01-23T03:51:39+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Soluciones Preselectivo 2013"><meta name=twitter:description content="Incrementando el talento de Ingeniería de Software en América Latina"></head><body class="ma0 bg-near-white"><header class="cover bg-top" style=background-image:url(https://blog.omegaup.com/images/cover.jpeg)><div class="w-70-ns center"><div class="pv4 pt7-l ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 white-90 mb0 lh-title">Soluciones Preselectivo 2013</h1><h2 class="fw1 f5 f3-l white-80 measure-wide-l center mt3">Incrementando el talento de Ingeniería de Software en América Latina</h2></div></div></header><header class="bg-black-90 sticky w-100 ph3 pv3 pv4-ns ph4-m ph5-l z-1"><nav class="f6 fw6 ttu tracked w-70-ns center"><a class="link dim white dib mr3" href=/tags/news/ title=Noticias>Noticias</a>
<a class="link dim white dib mr3" href=/tags/documentation/ title=Documentación>Documentación</a>
<a class="link dim white dib mr3" href=/tags/features/ title=Características>Características</a>
<a class="link dim white dib mr3" href=/tags/solution/ title=Solución>Solución</a>
<a class="link dim white dib mr3" href=/tags/study-material/ title="Material de estudio">Material de estudio</a>
<a class="link dim white dib mr3" href=/search/ title=Búsqueda>Búsqueda</a>
<a class="link dim white dib" href=https://omegaup.org/ title="Acerca de">Acerca de</a></nav></header><main class=pb7 role=main><article class="cf pa3 pa4-m pa4-l"><div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links nested-img mid-gray"><p>Below you will find pages that utilize the taxonomy term “Soluciones Preselectivo 2013”</p></div></article><div class="mw8 center"><section class="flex-ns flex-wrap justify-around mt5"><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-quimicos/ class="link black dim">Solución a "Químicos"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P6#problems/quimicos>Preselectivo para la IOI 2014, Etapa 1, Problemset 6</a> <strong>Autor:</strong>  <a href=http://lhchavez.com/>Luis Héctor Chávez (lhchavez)</a> <strong>Fuente</strong>: Ethan Jiménez Vargas</p><p>Éste es un problema que tiene una solución elegante y determinística pero requiere algoritmos avanzados bastante complicados. Lo bueno es que es posible aproximar a la solución utilizando fuerza bruta mediante backtracking.</p><p>El problema nos pide encontrar una manera de asignar sustancias a los tubos y después mezclarlas con las dos operaciones disponibles (suma y diferencia absoluta) para terminar con un acomodo homogéneo de sustancias: la diferencia entre el tubo con más cantidad y con menos cantidad de sustancia debe ser lo más pequeña posible. Una manera de hacerlo es proponer un intervalo $latex [a,b]$ y ver si es posible asignar sustancias y aparear los tubos de manera que la cantidad de sustancia resultante de la mezcla en todos los tubos esté contenido dentro del intervalo. Para acelerar el proceso, puedes elegir los intervalos haciendo una búsqueda binaria de acuerdo a su ancho $latex b-a$, porque a fin de cuentas lo que nos pide el problema es precisamente el ancho mínimo. Para cada intervalo propuesto $latex [a,b]$, podemos hacer un grafo con $latex 2N$ nodos (uno para cada tubo), agregando un arco entre dos nodos $latex A$ y $latex B$ si $latex A+B\in[a,b]$ ó $latex |A-B|\in[a,b]$. Después, buscamos un <a href=http://es.wikipedia.org/wiki/Apareamiento_(teor%C3%ADa_de_grafos)>apareamiento máximo</a> en el grafo: buscamos el conjunto de arcos con cardinalidad máxima tal que cada nodo tenga a lo más un arco incidente. Esto se puede encontrar con el <a href=http://es.wikipedia.org/wiki/Algoritmo_de_Emparejamiento_de_Edmonds>algoritmo de Edmonds</a> (también conocido como el Blossom algorithm por la forma de los ciclos de longitud impar) en tiempo $latex O(|2N|^4)$, lo cual encontraría todas las soluciones en solo un par de segundos.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-crucero/ class="link black dim">Solución a "Crucero"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P4#problems/Crucero>Preselectivo para la IOI 2014, Etapa 1, Problemset 4</a> <strong>Autor:</strong> <a href=mailto:saul.g.gutierrez@gmail.com>Saúl Germán Gutiérrez Calderón</a> <strong>Fuente</strong>: USACO Enero 2009 Gold</p><p>Como se puede notar, al trazar la ruta óptima del crucero se está desperdiciando mucho espacio, y daría lo mismo si expandiésemos la isla para que no se desperdiciara espacio entre la ruta y la orilla de ésta.</p><p><a href=/images/image002.jpg><img src=/images/image002.jpg alt title=image002></a> <a href=/images/image004.jpg><img src=/images/image004.jpg alt title=image004></a></p><p>Si supiéramos cual es la ruta óptima del crucero para expandir la isla bastaría con hacer un Flood Fill para rellenar los espacios con agua que quedan dentro de la ruta.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-mocha-hojas/ class="link black dim">Solución a "Mocha Hojas"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P17#problems/Mocha-Hojas>Preselectivo para la IOI 2014, Etapa 1, Problemset 17</a> <strong>Autor:</strong> <a href=http://freddy.mx/>Freddy Román Cepeda</a> <strong>Fuente</strong>: Alberto José Ramírez Valadez</p><p>Para simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-alternativa-a-decepcion/ class="link black dim">Solución alternativa a "Decepción"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P8#problems/decepcion>Preselectivo para la IOI 2014, Etapa 1, Problemset 8</a> <strong>Autor:</strong> <a href=http://freddy.mx/>Freddy Román Cepeda</a> <strong>Fuente</strong>: Ethan Jiménez Vargas</p><p>Esta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $latex O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.</p><p>Podemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $latex f(n,m)$ cuenta de cuántas maneras se pueden poner $latex n$ torres de tal manera de que sólo $latex m$ se pueden ver de un lado, la respuesta que queremos es $latex \sum_{i=0}^{N-1} ({N-1 \choose i} * f(i,F-1) * f(N-i-1,B-1))$.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-panoramas/ class="link black dim">Solución a "Panoramas"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P17#problems/Tour>Preselectivo para la IOI 2014, Etapa 1, Problemset 17</a> <strong>Autor:</strong> Miguel Ángel Covarrubias <strong>Fuente</strong>: Miguel Ángel Covarrubias</p><p>El problema es un Steiner tree problem (un MST pero donde sólo hay que conectar un subconjunto de nodos) pero con costo por nodo en vez de por arista. El grafo de los panoramas es un árbol más un ciclo. Para un árbol una solución es poner como raíz a $latex s_1$ y para cada $latex s_i$ marcar los nodos en su camino hacia la raíz. Se puede usar DP o recursión para calcular el mínimo numero de vertices que conectan todos los nodos interesantes y pasan por la raíz para cada subárbol.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-mapas-de-bits/ class="link black dim">Solución a "Mapas de bits"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P12/#problems/Mapas-de-bits>Preselectivo para la IOI 2014, Etapa 1, Problemset 12</a> <strong>Autor:</strong> Jorge Alberto González Martínez <strong>Fuente</strong>: Jorge Alberto González Martínez</p><p>En el problema se describen dos formas de representar un mapa de bits.</p><p>La forma bidimensional es simplemente utilizar una matriz para representar los bits. La forma por descomposición consiste en agrupar los bits similares y solo escribir el valor de los bits similares. En caso de que no sean similares todos los bits en un mapa de bits dado, se procede a dividir en cuatro secciones, imprimir la letra D y procesar cada uno de los cuartos de la misma manera, tal como se lee en la descripción del problema.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/445/ class="link black dim">Solución a "Pista"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2014E1P14#problems/pista>Preselectivo para la IOI 2014, Etapa 1, Problemset 14</a> <strong>Autor:</strong> Miguel Covarrubias <strong>Fuente</strong>: Codeforces</p><p>Este problema es una ligera modificación del Let&rsquo;s Play Osu! que apareció en la ronda 146 en Codeforces. <a href=http://codeforces.ru/blog/entry/5592>La solución explicada la pueden encontrar en el editorial.</a></p><p>Para $latex N \le 10$ se pueden checar todas las $latex 2^N$ configuraciones de pistas. Para $latex N \le 1000$ funciona una dinámica $latex O(N^2)$, donde los estados son (posición, altura/profundidad que se lleva hasta el momento).</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-cueva/ class="link black dim">Solución a "Cueva"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P4>Preselectivo para la IOI 2013, Etapa 1, Examen 4</a> <strong>Autor:</strong> <a href=http://twitter.com/erosethan>Ethan Jiménez Vargas</a></p><p>Después de comprender el problema podemos deducir dos cosas:</p><ul><li>Los <strong>N</strong> puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán <strong>N-1</strong> aristas y siempre hay un camino entre cualquier par de nodos.</li><li>Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las <strong>Q</strong> preguntas, ¿el nodo A es un ancestro del nodo <strong>B</strong>?”, de modo que necesitamos encontrar una manera óptima de saberlo.</li></ul><p><em><strong>Subtarea 1</strong></em>. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si <strong>A</strong> es ancestro de <strong>B</strong>, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo <strong>A</strong> encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo <strong>B</strong>, si existe un camino del nodo <strong>A</strong> al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo <strong>A</strong> es el mismo nodo <strong>B</strong>, en ambos casos la respuesta es 0.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-chilly-rapero/ class="link black dim">Solución a "Chilly Rapero"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P12>Preselectivo para la IOI 2013, Etapa 1, Examen 12</a> <strong>Autor:</strong> <a href=http://twitter.com/erosethan>Ethan Jiménez Vargas</a></p><p>La clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-cambio/ class="link black dim">Solución a "Cambio"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P7>Preselectivo para la IOI 2013, Etapa 1, Examen 7</a> **Autor: **<a href=mailto:elira@elira.me>Enrique Lira Vargas</a></p><p>Lo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.</p><h2 id=solución-de-30-50-puntos>Solución de 30, 50 puntos</h2><p>Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-minecraft/ class="link black dim">Solución a "Minecraft"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P5>Preselectivo para la IOI 2013, Etapa 1, Examen 5</a> **Autor: **<a href=mailto:elira@elira.me>Enrique Lira Vargas</a></p><p>Este problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.</p><h2 id=para-los-primeros-50-puntos>Para los primeros 50 puntos</h2><p>Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.</p><h2 id=para-los-75-puntos>Para los 75 puntos</h2><p>Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-k-arbol/ class="link black dim">Solución a "K-Arbol"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P5>Preselectivo para la IOI 2013, Etapa 1, Examen 5</a> **Autor: **<a href=mailto:lkt345@gmail.com>Saul de Nova Caballero</a></p><p>En pocas palabras el problema es, dado un árbol que se puede colorear, encuentra la menor solución satisfaciendo las restricciones dadas sobre los colores. Este problema es un caso particular de Graph Coloring(en español coloración de grafos), en donde el grafo es un árbol.</p><h1 id=subcaso-110-puntos>Subcaso 1(10 puntos)</h1><p>Para el primer subcaso era posible hacer una búsqueda en profunidad sobre todos los nodos, encontrando la menor solución. Para guardar el árbol, era posible utilizar una matriz que guardara todos los colores posibles y entonces ver si era posible una solución con el menor color posible. La solución de este caso era trivial si se usaba una búsqueda exhaustiva.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-metro/ class="link black dim">Solución a "Metro"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P12>Preselectivo para la IOI 2013, Etapa 1, Examen 12</a> **Autor: **<a href=mailto:alainacme@gmail.com>Alain Acevedo Mejía</a></p><p>El problema en cuestión se reduce a encontrar un árbol de expansión mínima. La solución es una aplicación directa de alguno de los algoritmos existentes para ello (bien implementada), por lo que hablaré brevemente sobre una de las posibilidades y daré referencias donde puedan encontrar información más detallada.</p><p>Para encontrar el costo mínimo de unir todas las estaciones debemos encontrar el árbol de expansión mínima de la gráfica en cuestión (es decir, una subgráfica conexa que una todos los vértices de la gráfica original y cuyo peso (la suma de los costos de todas sus aristas) sea el mínimo posible (siempre es un árbol)). Para ello una opción es usar el algoritmo de Kruskal: Ordenamos las aristas por su peso y vamos agregando cada arista de peso mínimo que no cree un ciclo en la gráfica. Hacemos esto hasta haber conectado todos los vértices de nuestra gráfica. Por la cantidad de aristas que tenemos requerimos ordenar eficientemente y verificar si las aristas forman un ciclo o no eficientemente en cada paso, de lo contrario el programa no correrá en tiempo.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/162/ class="link black dim">Solución a "Pulseras"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P10>Preselectivo para la IOI 2013, Etapa 1, Examen 10</a> **Autor: **<a href=mailto:alainacme@gmail.com>Alain Acevedo Mejía</a></p><p>Considero este problema como un buen ejemplo para quienes desean comenzar a trabajar con problemas de programación dinámica. Se nos pide calcular la cantidad de pulseras diferentes que se pueden construir bajo ciertas condiciones. Podemos comenzar preguntándonos, ¿qué sucede si la primera cuenta es negra? La siguiente podrá ser sólo blanca. Y si comenzamos con una blanca, la siguiente puede ser negra o blanca. Podemos entonces en una matriz de 2xn colocar en cada columna cuántas secuencias distintas hay que en la posición i-ésima terminen en negro y cuántas en blanco de tal modo que no haya dos cuentas negras consecutivas. Simplemente, para obtener los números de la siguiente posición, observamos que el número de las que terminan en blanco es la suma de ambos números de la posición anterior y de las que terminan en negro es el número de secuencias que terminan en blanco de la posición anterior.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-los-bloques-de-link/ class="link black dim">Solución a "Los Bloques de Link"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P8>Preselectivo para la IOI 2013, Etapa 1, Examen 8</a> **Autor: **<a href=mailto:alainacme@gmail.com>Alain Acevedo Mejía</a></p><p>Es claro que no es posible probar todas las sucesiones posibles de movimientos de los bloques para encontrar la solución (a excepción de casos muy simples). El número de tales sucesiones puede ser infinito en caso de que se puedan formar ciclos de movimientos (lo cual sucede en muchos de lo casos de prueba), y aún en casos donde el número sea finito puede suceder que no se tenga tiempo para probarlos todos.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-problema/ class="link black dim">Solución a "Problema"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P10>Preselectivo para la IOI 2013, Etapa 1, Examen 10</a> **Autor: **<a href=mailto:hugochiquito.cpp@gmail.com>Hugo Dueñas</a></p><p>Primero, dado una secuencia $latex A$ denotaremos por $latex s(A)$ a la suma de los elementos de A. Entonces podemos replantear el problema como: Dada una secuencia $latex S$ debemos de econtrar una subsecuencia $latex A$ de $latex S$ tal que $latex s(A) - (s(S) - s(A))$ sea la minima posible.</p><p>Ahora, como $latex s(A) - (s(S) - s(A)) = 2 \times s(A) - s(S)$, entonces tenemos que minimizar $latex 2 \times s(A) - s(S)$ que es lo mismo que minimizar $latex s(A) - s(S)/2$. O sea, debemos de encontrar una subsecuencia $latex A$ cuya suma esté lo más cercana a la mitad de la suma de $latex S$, en particular podemos restringir nuestra búsqueda a las subsecuencias cuya suma sea menor o igual a $latex s(S)/2$.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-alfiles/ class="link black dim">Solución a "Alfiles"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P7>Preselectivo para la IOI 2013, Etapa 1, Examen 7</a> **Autor: **<a href=mailto:hugochiquito.cpp@gmail.com>Hugo Dueñas</a></p><p>Lo primero que se debe de notar es que en cada una de las $latex 2n-1$ diagonales principales, las cuales mostradas en la imagen de abajo, habrá máximo 1 alfil. Lo mismo se cumple para las diagonales invertidas, mostradas también en una imagen abajo.</p><p><img src=/images/pic1.png alt></p><p><img src=/images/pic2.png alt></p><p>Ahora, cada diagonal principal se cruza con ciertas diagonales invertidas. Entonces se plantea una solución de tipo <em>Backtracking</em> que corre sobre las diagonales principales marcando diagonales invertidas a cada paso (representando que se ha colocado un alfil en el cruce de esas dos diagonales).</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-mario-reloaded/ class="link black dim">Solución a "Mario Reloaded"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P8>Preselectivo para la IOI 2013, Etapa 1, Examen 8</a> **Autor: **<a href=mailto:paspartu@gmail.com>Pavel Herrera Dominguez</a>)</p><h2 id=observaciones>Observaciones</h2><p>Lo primero es ver como se modelan los estados del problema sin pensar en que Mario puede tomar los atajos, únicamente pensar en las llaves, claramente existen $latex n\times2^m$ estados, pues no importa el orden en que se toman las llaves solo las llaves que se tienen al llegar a cada puerta. A partir de aquí nos referiremos como estado a la puerta y las llaves que trae Mario.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-el-collar-de-perlas/ class="link black dim">Solución a "El collar de perlas"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P10>Preselectivo para la IOI 2013, Etapa 1, Examen 10</a>**<a href=https://omegaup.com/arena/IOI2013E1P10> </a> Autor: **<a href=http://goldendarknut.blogspot.mx/>Félix Rafael Horta Cuadrilla</a></p><p>En una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.</p><p>Para resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero <em>i</em> en cualquier lista representa al enano <em>i</em>.</p><p>Durante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.</p><p>En algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-teclado-roto/ class="link black dim">Solución a "Teclado Roto"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P2>Preselectivo para la IOI 2013, Etapa 1, Examen 2</a>**<a href=https://omegaup.com/arena/IOI2013E1P2> </a> Autor: **<a href=#>Jorge Alberto González Martínez</a></p><p>Los temas para el examen donde apareció este problema eran pilas, colas y búsqueda binaria. Después de haber estudiado los temas, es buena idea combinar la teoría aprendida.</p><p>El problema del teclado roto describe una serie de operaciones en las que es necesaria una estructura en la que sea posible agregar elementos por ambos lados (izquierda y derecha). La descripción del problema muestra las restricciones, que no superan los 100, 000 elementos, por lo que es posible hacer un arreglo estático de caracteres de ese tamaño.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/solucion-a-el-artista-lento/ class="link black dim">Solución a "El Artista Lento"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P2>Preselectivo para la IOI 2013, Etapa 1, Examen 2</a>**<a href=https://omegaup.com/arena/IOI2013E1P2> </a> Autor: **<a href=#>Christian Hernández</a></p><p>Lo primero de lo que debemos darnos cuenta es de que como los pedazos son de dimensiones enteras y se colocan en dimensiones enteras, podemos &ldquo;pensar&rdquo; el problema de manera que en lugar de pegar rectángulos de <strong>Mi</strong> x <strong>Ni</strong>, estamos pegando <strong>Mi</strong> x <strong>Ni</strong> de 1 x 1 (Ejemplo: Si tuvieramos que pegar un rectángulo de 4 x 3, podemos pensarlo como pegar 12 rectangulos de 1 x 1). Podemos pensar lo mismo de los rectángulos adhesivos.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/engranes-khayyam-solucion-enrique-lira/ class="link black dim">Solución a "Engranes"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:</strong> <a href=https://omegaup.com/arena/IOI2013E1P1>Preselectivo para la IOI 2013, Etapa 1, Examen 1</a>**<a href=https://omegaup.com/arena/IOI2013E1P1> </a> Autor: **<a href=http://www.linkedin.com/pub/jesus-omar-ocegueda-gonzalez/18/b45/5b9>Omar Ocegueda (Khayyam)</a> **Solución por: **<a href=http://elira.me/>Enrique Lira</a></p><p>Para poder resolver este problema hay que ver ciertas propiedades a las cuales podemos llegar fácilmente a partir de ejemplos. Una primera duda que nos surge es: ¿Vuelve al estado inicial?, si hacemos un par de ejemplos podemos ver que si, otra duda que nos surge es: ¿Cuándo vuelve al estado inicial?, y aquí comienza lo complicado. Para saber cuando vuelve a su estado inicial hay que notar ciertas cosas, una de ellas es que en cuanto el diente 1 vuelve a tocar al valle 1 hemos vuelto al estado inicial, no hay forma de que el diente 0 toque al valle 0 sin haber vuelto al estado inicial, entonces hay que buscar ese instante.</p></div></div></div></div><div class="relative w-100 mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/juego-lento-ethan-jimenez/ class="link black dim">Solución a "Juego Lento"</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p><strong>Concurso:<a href=https://omegaup.com/arena/IOI2013E1P1> </a></strong><a href=https://omegaup.com/arena/IOI2013E1P1>Preselectivo para la IOI 2013, Etapa 1, Examen 1</a><br><strong>Autor:</strong> <a href=http://www.codechef.com/users/ethanjimenez>Ethan Jimenez</a></p><p>Empecemos analizando el caso en que solo jugamos con un montón de fichas, dada la restricción de tomar únicamente una sola ficha el juego se vuelve predecible ya que no hay más opción que tomar una ficha de ese montón. Si el montón tiene una sola ficha el jugador con el primer turno pierde, si hay dos fichas el jugador con el primer turno gana, si hay tres fichas el jugador con el primer turno pierde, y así alternadamente, podemos entonces deducir que si hay un número impar de fichas en el montón, el jugador con el primer turno perderá, por el otro lado, si el montón tiene un número par de fichas ganará la partida.</p></div></div></div></div></section></div></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://blog.omegaup.com/>&copy; omegaUp blog 2024</a><div><div class=ananke-socials></div></div></div></footer><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['$latex', '$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\[','\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      ignoreClass: 'gist',
      TeX: {
        equationNumbers: { autoNumber: "AMS" },
        extensions: ["AMSmath.js", "AMSsymbols.js"],
      },
   },
 });
</script></body></html>