<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Soluciones Preselectivo 2013</title><link>https://blog.omegaup.com/tags/soluciones-preselectivo-2013/</link><description>Recent content in Soluciones Preselectivo 2013 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 23 Jan 2014 03:51:39 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/soluciones-preselectivo-2013/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Químicos"</title><link>https://blog.omegaup.com/solution/solucion-a-quimicos/</link><pubDate>Thu, 23 Jan 2014 03:51:39 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-quimicos/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P6#problems/quimicos" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 6&lt;/a> &lt;strong>Autor:&lt;/strong>  &lt;a href="http://lhchavez.com/" target="_blank" rel="noopener">Luis Héctor Chávez (lhchavez)&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Éste es un problema que tiene una solución elegante y determinística pero requiere algoritmos avanzados bastante complicados. Lo bueno es que es posible aproximar a la solución utilizando fuerza bruta mediante backtracking.&lt;/p>
&lt;p>El problema nos pide encontrar una manera de asignar sustancias a los tubos y después mezclarlas con las dos operaciones disponibles (suma y diferencia absoluta) para terminar con un acomodo homogéneo de sustancias: la diferencia entre el tubo con más cantidad y con menos cantidad de sustancia debe ser lo más pequeña posible. Una manera de hacerlo es proponer un intervalo $latex [a,b]$ y ver si es posible asignar sustancias y aparear los tubos de manera que la cantidad de sustancia resultante de la mezcla en todos los tubos esté contenido dentro del intervalo. Para acelerar el proceso, puedes elegir los intervalos haciendo una búsqueda binaria de acuerdo a su ancho $latex b-a$, porque a fin de cuentas lo que nos pide el problema es precisamente el ancho mínimo. Para cada intervalo propuesto $latex [a,b]$, podemos hacer un grafo con $latex 2N$ nodos (uno para cada tubo), agregando un arco entre dos nodos $latex A$ y $latex B$ si $latex A+B\in[a,b]$ ó $latex |A-B|\in[a,b]$. Después, buscamos un &lt;a href="http://es.wikipedia.org/wiki/Apareamiento_%28teor%C3%ADa_de_grafos%29" target="_blank" rel="noopener">apareamiento máximo&lt;/a> en el grafo: buscamos el conjunto de arcos con cardinalidad máxima tal que cada nodo tenga a lo más un arco incidente. Esto se puede encontrar con el &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Emparejamiento_de_Edmonds" target="_blank" rel="noopener">algoritmo de Edmonds&lt;/a> (también conocido como el Blossom algorithm por la forma de los ciclos de longitud impar) en tiempo $latex O(|2N|^4)$, lo cual encontraría todas las soluciones en solo un par de segundos.&lt;/p>
&lt;p>Lamentablemente la implementación del algoritmo de Edmonds es bastante complicada. Como este es un problema de solo-salida y todo se vale, en vez de hacer el intento por implementarlo, utilicé la librería &lt;a href="http://www.boost.org/" target="_blank" rel="noopener">Boost&lt;/a> de C++ que ya tiene muchísimos algoritmos de &lt;a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/index.html" target="_blank" rel="noopener">grafos&lt;/a> ya implementados.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572476.js">&lt;/script>
&lt;p>Ahora, si no se te ocurre usar el algoritmo de Edmonds o no tienes acceso a Boost, aún así puedes obtener una cantidad decente de puntos usando una heurística: podemos &lt;em>intentar&lt;/em> hacer un apareamiento máximo usando fuerza bruta, rindiéndonos si el problema suena muy complicado y asumimos que no existe un apareamiento. Una fuerza bruta naïve con un contador que se decrementa cada vez que se llama la función de búsqueda es más que suficiente. Haciendo un par de modificaciones al algoritmo anterior nos da una solución que nos da el 80% de los casos bien:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572478.js">&lt;/script>
&lt;p>Claro que si te quieres ver greedy, puedes subirle al número de intentos, pero posiblemente no haya suficiente tiempo en el concurso para que termine. Si llegas a utilizar estas técnicas &amp;ldquo;impuras&amp;rdquo;, asegúrate primero de obtener cualquier solución que te de puntos antes de subirle para encontrar mejores respuestas.&lt;/p></description></item><item><title>Solución a "Crucero"</title><link>https://blog.omegaup.com/solution/solucion-a-crucero/</link><pubDate>Thu, 23 Jan 2014 03:41:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-crucero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P4#problems/Crucero" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:saul.g.gutierrez@gmail.com" >Saúl Germán Gutiérrez Calderón&lt;/a> &lt;strong>Fuente&lt;/strong>: USACO Enero 2009 Gold&lt;/p>
&lt;p>Como se puede notar, al trazar la ruta óptima del crucero se está desperdiciando mucho espacio, y daría lo mismo si expandiésemos la isla para que no se desperdiciara espacio entre la ruta y la orilla de ésta.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image002.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image002.jpg" title="image002" alt="" loading="lazy" />
&lt;figcaption>image002&lt;/figcaption>
&lt;/figure>&lt;/a> &lt;a href="https://blog.omegaup.com/images/image004.jpg" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image004.jpg" title="image004" alt="" loading="lazy" />
&lt;figcaption>image004&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si supiéramos cual es la ruta óptima del crucero para expandir la isla bastaría con hacer un Flood Fill para rellenar los espacios con agua que quedan dentro de la ruta.&lt;/p>
&lt;p>Resulta que el flood fill e puede hacer aun sin conocer cuál sería la ruta óptima. Si nos ponemos a hacer todos los tipos de celdas adyacentes a la celda actual en un flood fill, nos toparemos con que solo hay 2 que permiten que la isla crezca y 1 que evita que se expanda. El resto de las celdas adyacentes no nos dice nada acerca de si tenemos que poner algo ahí o no (de momento).&lt;/p>
&lt;p>Si se pone un pedazo de isla nuevo en el centro de las figura de abajo, entonces la cosa peligrosa tendría que ser rodeada de alguna manera para poder pasar, lo cual nos llevaría a tomar una ruta mas larga. Por ello, no es una buena idea poner un pedazo de isla ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image005.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image005.png" title="image005" alt="" loading="lazy" />
&lt;figcaption>image005&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Si es como la de la figura de abajo,&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image006.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image006.png" title="image006" alt="" loading="lazy" />
&lt;figcaption>image006&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>ambos caminos tienen la misma longitud. Por ello, se puede poner un pedazo de isla ahí y esto nos simplifica el problema.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image007.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image007.png" title="image007" alt="" loading="lazy" />
&lt;figcaption>image007&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;a href="https://blog.omegaup.com/images/image008.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image008.png" title="image008" alt="" loading="lazy" />
&lt;figcaption>image008&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>La ruta óptima no puede pasar por el cuadro del centro ya que esto sería un desperdicio de tiempo, por lo cual podemos expandir la tierra ahí.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/image009.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/image009.png" title="image009" alt="" loading="lazy" />
&lt;figcaption>image009&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Entonces, sólo hay que hacer todas las expansiones de tierra hasta que ya no se pueda más y después de esto se puede hacer una mano derecha para buscar la orilla de la isla que al mismo tiempo será la ruta óptima.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8572582.js">&lt;/script></description></item><item><title>Solución a "Mocha Hojas"</title><link>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</link><pubDate>Sat, 18 Jan 2014 23:25:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mocha-hojas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Mocha-Hojas" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Alberto José Ramírez Valadez&lt;/p>
&lt;p>Para simplificar el análisis, podemos notar que la respuesta que nos piden es igual al total de los pesos de las hojas del árbol menos el total de los pesos de las hojas del árbol ya balanceado. De ahora en adelante, trataremos el problema como si tuviéramos que conseguir este segundo valor, en vez del número de operaciones. Entonces queremos maximizar el peso total del árbol balanceado, para minimizar la cantidad de operaciones.&lt;/p>
&lt;p>Consideremos el caso de un árbol con un solo nivel. Ya que sólo podemos restarle a los pesos de las hojas, evidentemente el peso máximo del árbol se alcanza cuando se emparejan todas las hojas al peso de la hoja con peso mínimo.&lt;/p>
&lt;p>Ahora, consideremos un árbol con dos niveles. Si la raíz tiene $latex k$ hijos, para cada hijo $latex i$ sea $latex h_i$ el subárbol de $latex i$, $latex b_i$ el número de hojas de $latex h_i$, y $latex c_i$ el peso del árbol obtenido de realizar el procedimiento del párrafo anterior a $latex h_i$. Si todas las $latex c_i$ son iguales, entonces nuestro árbol está balanceado. De lo contrario, debemos restar aún más para poder balancearlo. Sin embargo, también necesitamos que cada $latex h_i$ continúe estando balanceado. La única manera que le podemos restar peso a $latex h_i$ sería restarle la misma cantidad de peso a cada una de sus hojas. Entonces, a cada $latex h_i$ sólo podemos restarle peso en múltiplos de $latex b_i$. Como queremos maximizar el peso del árbol resultante, necesitamos encontrar el número más grande $latex x$ tal que a todos los $latex c_i$ les podamos restar un múltiplo de su respectivo $latex b_i$ para obtener $latex x$. Notemos también que $latex c_i$ es un múltiplo de $latex b_i$ porque los nodos internos del árbol no tienen peso. Si $latex m$ es el mínimo común múltiplo de todos los $latex b_i$, entonces $latex x$ también es un múltiplo de $latex m$. Entonces, el máximo $latex x$ posible es igual al múltiplo de $latex m$ más grande que sea menor o igual a todos los $latex c_i$. Por lo tanto, el valor máximo obtenible del árbol completo es igual a $latex kx$. Por último, si tuviéramos que restarle más peso a este árbol pero mantenerlo balanceado, es evidente que lo menos que podemos restar para mantenerlo balanceado es $latex km$, y si seguimos restando $latex km$ continuará balanceado.&lt;/p>
&lt;p>De esta observación podemos obtener la solución para cualquier árbol. Reusando la notación del párrafo anterior, $latex k$ es la cantidad de hijos de la raíz, $latex h_i$ el subárbol del $latex i$ésimo hijo, y $latex c_i$ el peso del árbol obtenido de realizar recursivamente el procedimiento de éste párrafo a $latex h_i$ (o el del anterior si $latex h_i$ tiene 2 niveles). Ahora $latex b_i$ es igual a lo mínimo que le podemos restar a $latex h_i$ y que continúe balanceado. El análisis del párrafo anterior también es correcto para la nueva definición de $latex b_i$ y $latex c_i$.&lt;/p>
&lt;p>El código siguiente implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8498208.js">&lt;/script></description></item><item><title>Solución alternativa a "Decepción"</title><link>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</link><pubDate>Fri, 17 Jan 2014 02:14:47 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-alternativa-a-decepcion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P8#problems/decepcion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Ethan Jiménez Vargas&lt;/p>
&lt;p>Esta es una solución alternativa al problema. La solución pensada originalmente consiste en una búsqueda podada. Sin embargo, esta solución corre en tiempo y memoria $latex O(N^2)$, mucho mejor de lo necesario para obtener todos los puntos.&lt;/p>
&lt;p>Podemos dividir el problema a la mitad con una observación simple: la torre más alta debe verse desde ambos lados. Además, no dejará que el resto de las torres que ocurren después de ella se vean. Podemos aprovechar este hecho para separar el problema en dos partes: izquierda y derecha. Si $latex f(n,m)$ cuenta de cuántas maneras se pueden poner $latex n$ torres de tal manera de que sólo $latex m$ se pueden ver de un lado, la respuesta que queremos es $latex \sum_{i=0}^{N-1} ({N-1 \choose i} * f(i,F-1) * f(N-i-1,B-1))$.&lt;/p>
&lt;p>En otras palabras, esta expresión es la suma de las maneras de cumplir las condiciones originales del problema colocando la torre más alta en la posición $latex i$. Es decir, hay $latex {N-1 \choose i}$ maneras de distribuir el resto de las torres a la izquierda o derecha de la torre más alta (porque la única cosa que importa es el orden relativo de las torres y todas las alturas son distintas), las cuales multiplicamos por las maneras de hacer que se cumpla la condición sobre el lado izquierdo y lo mismo con el lado derecho.&lt;/p>
&lt;p>Ahora, para computar $latex f$, podemos reusar la misma observación. Cuando colocamos la torre más alta en el índice $latex i$, cualquier torre que pongamos después de $latex i$ ya no se podrá ver. Del lado visible, necesitamos reordenar las torres restantes de tal manera que sólo se puedan ver $latex m-1$. Además, podemos reordenar el lado oculto de la manera que queramos. Con esto tenemos que&lt;/p>
&lt;p>$latex f(0,0) = 1$ $latex f(n,m) = \begin{cases} 0 &amp;amp; \text{si } m &amp;gt; n\\ \sum_{i=0}^{n-1}({n-1 \choose i} * f(i,m-1) * (n-i-1)!) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>con lo que resolvemos el problema en tiempo $latex O(N^3)$ y memoria $latex O(N^2)$.&lt;/p>
&lt;p>Esto se puede mejorar aún más observando que $latex f(n,m)$ está computando los números de Stirling de primera clase, para los cuales hay una recurrencia que se puede utilizar para calcularlos en tiempo $latex O(N^2)$.&lt;/p>
&lt;p>Los números de Stirling de primera clase cuentan las permutaciones de $latex n$ elementos con $latex m$ ciclos. Considere una permutación con $latex m$ ciclos de los $latex n$ edificios. Cada ciclo debe tener un elemento máximo. Además podemos ordenar los ciclos entre sí por su elemento mayor. De esta manera, tenemos $latex m$ edificios visibles. Ya que estamos contando todas las permutaciones con $latex m$ ciclos, cada posible ordenamiento con $latex m$ edificios visibles será considerada. Esto se debe a que cada ciclo tiene únicamente un ordenamiento en el cual sólo uno de sus elementos es visible: el que comienza con el edificio más grande.&lt;/p>
&lt;p>Aquí está el código que implementa esta solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8467347.js">&lt;/script></description></item><item><title>Solución a "Panoramas"</title><link>https://blog.omegaup.com/solution/solucion-a-panoramas/</link><pubDate>Thu, 16 Jan 2014 17:36:38 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-panoramas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P17#problems/Tour" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 17&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Ángel Covarrubias &lt;strong>Fuente&lt;/strong>: Miguel Ángel Covarrubias&lt;/p>
&lt;p>El problema es un Steiner tree problem (un MST pero donde sólo hay que conectar un subconjunto de nodos) pero con costo por nodo en vez de por arista. El grafo de los panoramas es un árbol más un ciclo. Para un árbol una solución es poner como raíz a $latex s_1$ y para cada $latex s_i$ marcar los nodos en su camino hacia la raíz. Se puede usar DP o recursión para calcular el mínimo numero de vertices que conectan todos los nodos interesantes y pasan por la raíz para cada subárbol.&lt;/p>
&lt;p>$latex \mathrm{dp}_r=\mathrm{interesante}(r)\ \mathrm{si}\ \Sigma_h\mathrm{dp}_h=0$ $latex \mathrm{dp}_r = \Sigma_h\mathrm{dp}_h+1\ \mathrm{si}\ \Sigma_c\mathrm{dp}_h&amp;gt;0$&lt;/p>
&lt;p>$latex h$ es un hijo de $latex r$. La arista extra $latex (u,v)$ en el ciclo $latex c$ permite usar otros caminos a lo largo de $latex c$. Tales caminos deben conectar todos los nodos en $latex c$ que tengan nodos interesantes en su árbol después de quitar las aristas del ciclo $latex E-c$. Etiquetemos tales nodos con un uno y los demás nodos del $latex c$ con un cero. Para $latex E-(u,v)$ el ciclo sólo no cubre los últimos ceros. Para encontrar la solución sólo basta encontrar la secuencia de ceros más grande. En el siguiente diagrama, la arista que falta es $latex (u,v)$. La DP sólo no usa el último cero, pero es mejor no usar los dos ceros que están adyacentes.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">0&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">/&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">1&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">\\&lt;/span> &lt;span class="o">/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">0&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Este código implementa la solución.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/8468920.js">&lt;/script></description></item><item><title>Solución a "Mapas de bits"</title><link>https://blog.omegaup.com/solution/solucion-a-mapas-de-bits/</link><pubDate>Sun, 06 Oct 2013 22:56:54 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mapas-de-bits/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P12/#problems/Mapas-de-bits" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 12&lt;/a> &lt;strong>Autor:&lt;/strong> Jorge Alberto González Martínez &lt;strong>Fuente&lt;/strong>: Jorge Alberto González Martínez&lt;/p>
&lt;p>En el problema se describen dos formas de representar un mapa de bits.&lt;/p>
&lt;p>La forma bidimensional es simplemente utilizar una matriz para representar los bits. La forma por descomposición consiste en agrupar los bits similares y solo escribir el valor de los bits similares. En caso de que no sean similares todos los bits en un mapa de bits dado, se procede a dividir en cuatro secciones, imprimir la letra D y procesar cada uno de los cuartos de la misma manera, tal como se lee en la descripción del problema.&lt;/p>
&lt;p>La solución a este problema consistía en programar el método descrito. Este método inherentemente está basado en la técnica de divide y vencerás.&lt;/p>
&lt;p>A continuación, un pseudo-código que muestra la forma de llevar a cabo la transformación de un mapa de bits bidimensional a la forma reducida:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">todos&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">elementos&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">mapaDeBits&lt;/span> &lt;span class="n">son&lt;/span> &lt;span class="n">iguales&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Imprime&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">valor&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">termina&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Imprime&lt;/span> &lt;span class="n">D&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorIzquierdo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorDerecho&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorIzquierdo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ReduceMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorDerecho&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>El método para hacer la transformación inversa es muy parecido, sólo que para imprimir la equivalencia hay que comenzar con un mapa de bits bidimensional que nos sirva de variable auxiliar para hacer la conversión. Esta variable auxiliar se puede declarar de manera global y, cuando el método recursivo termine, simplemente imprimir su contenido:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">mapaDeBits&lt;/span> &lt;span class="n">comienza&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">un&lt;/span> &lt;span class="n">valor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Rellenar&lt;/span> &lt;span class="n">sección&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">mapa&lt;/span> &lt;span class="n">bidimensional&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">valor&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Si&lt;/span> &lt;span class="n">no&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorIzquierda&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">superiorDerecha&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorIzquierda&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">AmplificaMapa&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mapaDeBits&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">removerPrimerElemento&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sección&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">inferiorDerecha&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>La primera vez que se llama a la función AmplificaMapa se debe entregar la representación de la forma por descomposición del mapa de bits en la variable mapaDeBits y la sección que se entrega inicialmente es todo el mapa de bits. Esto puede ser manejado por filas y columnas.&lt;/p>
&lt;p>A continuación se muestra una implementación en C++ que resuelve el problema. Nótese cómo se maneja la sección sobre la que se está trabajando con cuatro variables: &lt;code>tl_row&lt;/code>, &lt;code>tl_col&lt;/code>, &lt;code>br_row&lt;/code>, &lt;code>br_col&lt;/code>. El nombre de las variables proviene de top-left row, top-left colum, bottom-right row y bottom-right colum respectivamente. Representan los índices (fila,columa) de las esquinas superior izquierda e inferior derecha.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860210.js">&lt;/script></description></item><item><title>Solución a "Pista"</title><link>https://blog.omegaup.com/solution/445/</link><pubDate>Sun, 06 Oct 2013 22:48:35 +0000</pubDate><guid>https://blog.omegaup.com/solution/445/</guid><description>
&lt;ul>
&lt;li>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P14#problems/pista" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 14&lt;/a>&lt;/li>
&lt;li>&lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente&lt;/strong>: Codeforces&lt;/li>
&lt;/ul>
&lt;p>Este problema es una ligera modificación del Let&amp;rsquo;s Play Osu! que apareció en la ronda 146 en Codeforces. &lt;a href="http://codeforces.ru/blog/entry/5592" target="_blank" rel="noopener">La solución explicada la pueden encontrar en el editorial.&lt;/a>&lt;/p>
&lt;p>Para $latex N \le 10$ se pueden checar todas las $latex 2^N$ configuraciones de pistas. Para $latex N \le 1000$ funciona una dinámica $latex O(N^2)$, donde los estados son (posición, altura/profundidad que se lleva hasta el momento).&lt;/p>
&lt;p>Les dejo la implementación de DiegoRoque como un muy buen ejemplo de una solución a este problema.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6860151.js">&lt;/script></description></item><item><title>Solución a "Cueva"</title><link>https://blog.omegaup.com/solution/solucion-a-cueva/</link><pubDate>Mon, 14 Jan 2013 16:27:54 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-cueva/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P4" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 4&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>Después de comprender el problema podemos deducir dos cosas:&lt;/p>
&lt;ul>
&lt;li>Los &lt;strong>N&lt;/strong> puntos de la cueva modelan un árbol, esto debido a la propiedad de que existirán &lt;strong>N-1&lt;/strong> aristas y siempre hay un camino entre cualquier par de nodos.&lt;/li>
&lt;li>Podemos traducir la tarea principal del problema a lo siguiente “Para cada una de las &lt;strong>Q&lt;/strong> preguntas, ¿el nodo A es un ancestro del nodo &lt;strong>B&lt;/strong>?”, de modo que necesitamos encontrar una manera óptima de saberlo.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>&lt;strong>Subtarea 1&lt;/strong>&lt;/em>. Para obtener los primeros 25 puntos del problema solo necesitamos implementar el método de fuerza bruta que nos permita conocer si &lt;strong>A&lt;/strong> es ancestro de &lt;strong>B&lt;/strong>, esto puede conseguirse con una búsqueda en profundidad (DFS) que desde el nodo &lt;strong>A&lt;/strong> encuentre la manera de llegar al nodo 1, restringiendo que no sea posible pasar por el nodo &lt;strong>B&lt;/strong>, si existe un camino del nodo &lt;strong>A&lt;/strong> al nodo raíz la respuesta es 1, en caso contrario la respuesta es 0. Hay que cuidar los casos especiales cuando el nodo B es el nodo raíz o cuando el nodo &lt;strong>A&lt;/strong> es el mismo nodo &lt;strong>B&lt;/strong>, en ambos casos la respuesta es 0.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NQ)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;strong>&lt;em>Subtarea 2.&lt;/em>&lt;/strong> Es notable que esta vez el número de preguntas es mucho mayor, por ello la solución anterior tardaría demasiado. Cambiemos nuestra estrategia, esta vez realicemos una búsqueda en profundidad desde el nodo 1 hasta los demás &lt;strong>N&lt;/strong> nodos, llevando una lista &lt;strong>L&lt;/strong> de los nodos que forman parte del camino desde el nodo 1 hasta el nodo &lt;strong>K&lt;/strong>, incluyendo los nodos 1 y &lt;strong>K&lt;/strong>, esto puede lograrse mediante recursividad.&lt;/p>
&lt;p>La tabla &lt;strong>ancestro[K][M]&lt;/strong> nos permitirá saber si el nodo &lt;strong>M&lt;/strong> es un ancestro del nodo &lt;strong>K&lt;/strong>, dándonos cuenta que todos los ancestros de &lt;strong>K&lt;/strong> se encuentran en la lista &lt;strong>L&lt;/strong> cuando la búsqueda en profundidad llega al nodo &lt;strong>K&lt;/strong>, podemos llenar la tabla &lt;strong>ancestro[K][M]&lt;/strong> durante la búsqueda en profundidad. Con la tabla anterior es fácil responder las preguntas, pues la respuesta depende de &lt;strong>ancestro[B][A]&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N2+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 3&lt;/strong>&lt;/em>. Para obtener los puntos de esta subtarea podemos utilizar cualquier algoritmo para resolver el clásico problema del ancestro común de dos nodos en un árbol, puesto que la respuesta es 1 si el ancestro común entre los nodos &lt;strong>A&lt;/strong> y &lt;strong>B&lt;/strong> es el nodo &lt;strong>A&lt;/strong>. Este problema ya ha sido estudiado ampliamente y tiene diversas formas de ser resuelto con complejidad &lt;strong>O(NlogN)&lt;/strong>, en el foro de tutoriales de TopCoder podemos encontrar un buen artículo con algunos de los algoritmos que pueden ser utilizados:&lt;/p>
&lt;p>&lt;a href="http://community.topcoder.com/tc?module=Static&amp;amp;d1=tutorials&amp;amp;d2=lowestCommonAncestor" target="_blank" rel="noopener">TopCoder Lowest Common Ancestor&lt;/a>&lt;/p>
&lt;p>El algoritmo que utiliza programación dinámica es el más recomendado, puesto que se puede responder a las &lt;strong>Q&lt;/strong> preguntas en un tiempo constante.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(NlogN+Q)&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;em>&lt;strong>Subtarea 4&lt;/strong>&lt;/em>. Para empezar, notemos que la solución anterior no funciona para este conjunto de puntos porque utiliza demasiada memoria, el simple hecho de almacenar los nodos y las aristas ocupa bastante espacio en memoria (aproximadamente 100Mb) y una solución para la subtarea 3 requeriría al menos 50Mb más, por lo tanto no es posible completar la subtarea 4 con una solución como la anterior, para obtener los 100 puntos en este problema necesitamos una idea mucho más creativa.&lt;/p>
&lt;p>Renombremos todos los nodos del árbol enumerandolos del 1 al &lt;strong>N&lt;/strong> siguiendo el orden establecido por el recorrido en postorden del árbol comenzando por el nodo 1, después, para cada nodo, con su respectivo número &lt;strong>Y&lt;/strong>, hay que obtener el menor número presente en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>, denotemos este número menor como &lt;strong>X&lt;/strong>, con los números &lt;strong>X&lt;/strong> y &lt;strong>Y&lt;/strong> definimos entonces un intervalo cerrado &lt;strong>[X,Y]&lt;/strong> que nos representa que en el subárbol con raíz en el nodo &lt;strong>Y&lt;/strong> se contienen todos los nodos cuyo número se encuentra en el intervalo &lt;strong>[X,Y]&lt;/strong>. Podemos interpretar esta información de una manera más conveniente, un nodo con número &lt;strong>Y&lt;/strong> es ancestro de un nodo con número &lt;strong>K&lt;/strong> si &lt;strong>X ≤ K ≤ Y&lt;/strong>, lo cual nos permitirá responder las preguntas planteadas.&lt;/p>
&lt;p>Es recomendable que el olímpico experimente y se convenza que la propiedad del intervalo &lt;strong>[X,Y]&lt;/strong> es siempre correcta debido a que el recorrido en postorden establecerá que el nodo con el número &lt;strong>X&lt;/strong>, que establece la cota inferior del intervalo, siempre será una hoja del subárbol y el nodo con valor &lt;strong>Y&lt;/strong>, que establece la cota superior del intervalo, siempre será la raíz del subárbol, cualquier otro valor fuera del intervalo estará excluido del subárbol con raíz en el nodo &lt;strong>Y&lt;/strong>.&lt;/p>
&lt;p>&lt;em>Complejidad de la solución: &lt;strong>O(N+Q)&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>Solución a "Chilly Rapero"</title><link>https://blog.omegaup.com/solution/solucion-a-chilly-rapero/</link><pubDate>Sat, 12 Jan 2013 19:41:11 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-chilly-rapero/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://twitter.com/erosethan" target="_blank" rel="noopener">Ethan Jiménez Vargas&lt;/a>&lt;/p>
&lt;p>La clave para resolver este problema es interpretar las palabras como nodos y los cambios entre palabras como aristas, de manera que podamos verlo todo como un grafo no dirigido. Asignamos a cada palabra un nodo y creamos las aristas entre nodos verificando alguna de las condiciones que se proponen en el enunciado del problema: si una palabra A es un prefijo o sufijo de la palabra B o la palabra A difiere con la palabra B por un solo caracter, establecemos una arista entre los nodos A y B.&lt;/p>
&lt;p>Crear las aristas entre los nodos tiene una complejidad de O(LN2) y la manera más simple de almacenar dichas aristas es mediante una matriz de adyacencia. Ya que tenemos el grafo planteado, buscaremos la manera más rápida de cambiar de palabra entre cualquier par de palabras, esto puede conseguirse usando el algoritmo de &lt;a href="http://es.wikipedia.org/wiki/Algoritmo_de_Floyd-Warshall" target="_blank" rel="noopener">Floyd-Warshall&lt;/a> con una complejidad de O(N3) que es suficiente para el problema.&lt;/p>
&lt;p>Finalmente, para obtener la respuesta sumamos el mínimo número de cambios requeridos entre todos los pares de palabras consecutivas en el rap, este número de cambios fue obtenido mediante el algoritmo de Floyd-Warshall. El número total de cambios lo multiplicamos por 0.2 y será la respuesta para el problema.&lt;/p>
&lt;p>Complejidad de la solución: O(LN2+N3)&lt;/p></description></item><item><title>Solución a "Cambio"</title><link>https://blog.omegaup.com/solution/solucion-a-cambio/</link><pubDate>Tue, 08 Jan 2013 17:18:25 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-cambio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Lo importante de este problema es notar como se puede usar un backtracking para contar cosas. En este caso lo que se debía contar era la cantidad de formas de llegar a una cantidad sumando una o más veces una serie de cantidades dadas.&lt;/p>
&lt;h2>Solución de 30, 50 puntos&lt;span class="hx-absolute -hx-mt-20" id="solución-de-30-50-puntos">&lt;/span>
&lt;a href="#soluci%c3%b3n-de-30-50-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Generar todas las combinaciones que sumen la cantidad C pedida. Para hacer esto se puede hacer con una búsqueda en profundidad de manera ordenada de la misma forma que se calculan permutaciones pero cuidando que la suma no sobrepase el valor C deseado. Esto se puede considerar una búsqueda podada.&lt;/p>
&lt;h2>Solución de 100 puntos&lt;span class="hx-absolute -hx-mt-20" id="solución-de-100-puntos">&lt;/span>
&lt;a href="#soluci%c3%b3n-de-100-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Consideremos la solución anterior y tratemos de calcularlo de abajo hacia arriba, habría que crear una función que nos dijera para una cantidad dada y un set de monedas que se pueden usar (para no repetir) nos diga cuantas formas distintas hay de completar dicha cantidad. Si se logra construir dicha función la solución al problema es simple puesto que se reduce a llamar dicha función con la cantidad que nos piden y el set completo de monedas. Lo interesante radica en cómo se compone dicha función, suponiendo que la función funciona hay que tratar de construirla, primero hay que considerar los casos especiales, si la cantidad es cero significa que no hay que hacer nada y entonces hay una forma de lograrlo (es una combinación válida), si la cantidad es mayor a cero hay que sumar las combinaciones de tomar una moneda de la primera denominación disponible con las de dejar de tomar monedas de dicha denominación.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Para calcular las combinaciones de tomar una moneda de dicha denominación se puede usar la función a partir de la cantidad restante (la cantidad buscada menos la denominación de la moneda) y el mismo set de monedas.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Para calcular las combinaciones de dejar de tomar monedas de cierta denominación de igual forma se puede usar la función con la misma cantidad pero con un set de monedas que no incluya la denominación que decidimos dejar de tomar.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Si se toma la moneda sin considerar si la denominación es más grande que la cantidad entonces existe el caso donde la cantidad es negativa y en ese caso la respuesta debiera ser cero puesto que es una combinación no válida.&lt;/p>
&lt;p>De igual forma si el set de denominaciones disponibles está vacío significa que ya no hay más denominaciones para probar y por lo tanto no hay ninguna forma de lograrlo.&lt;/p>
&lt;p>Como podemos notar dicha función es recursiva y se llama a si misma hasta que la cantidad se vuelve cero, negativa y/o el set de denominaciones queda vació, y si lo analizamos un poco podemos darnos cuenta de que funciona. La forma simple de saber que set de monedas es usable es guardar el índice de la primera moneda usable y eliminarlas en orden. Hay que notar que hasta el momento no hemos mejorado en nada la solución anterior, y la complejidad de esto es similar a la de nuestra idea anterior.&lt;/p>
&lt;p>Lo que hay que notar es que la cantidad no tendrá más de 10,000 valores distintos y que nunca habrá más de 100 sets distintos, por lo tanto dicha función solo se puede mandar a llamar 1,000,000 de veces con parámetros distintos. Sin embargo sabemos que la cantidad de combinaciones puede llegar a ser mucho mayor. Entonces ¿Qué sucede?, pues es sencillo darse cuenta que dicha función se mandará a llamar más de una vez con los mismos parámetros y en todos esos casos siempre deberá entregar la misma solución, es por esto que podemos guardar las respuestas para cada uno de los casos en un array y así nunca tener que calcularlos más de una vez, esto hace que nuestro programa pueda correr en tiempo.&lt;/p>
&lt;p>&lt;em>El asunto de los módulos creo que es algo que debiesen saber sin embargo les digo que el modulo se puede aplicar al sumar el tomar y el no tomar, puesto que (A + B) modulo X es igual a (A modulo X + B modulo X ) modulo X.&lt;/em>&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559217.js">&lt;/script></description></item><item><title>Solución a "Minecraft"</title><link>https://blog.omegaup.com/solution/solucion-a-minecraft/</link><pubDate>Tue, 08 Jan 2013 17:14:15 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-minecraft/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:elira@elira.me" >Enrique Lira Vargas&lt;/a>&lt;/p>
&lt;p>Este problema no requiere ninguna observación específica y realmente lo único que hay que hacer es una búsqueda.&lt;/p>
&lt;h2>Para los primeros 50 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-primeros-50-puntos">&lt;/span>
&lt;a href="#para-los-primeros-50-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Este primer sub set de casos se puede resolver implementando una búsqueda en amplitud que nos dé el camino más corto entre dos puntos en un mapa con paredes.&lt;/p>
&lt;h2>Para los 75 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-75-puntos">&lt;/span>
&lt;a href="#para-los-75-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para este punto se me ocurrió una solución factible para aquellos que no saben construir una cola de prioridad, correr una búsqueda en amplitud con dos colas cuidando elegir siempre la siguiente posición con una menor cantidad de movimientos de las dos colas.&lt;/p>
&lt;h2>Para los 100 puntos&lt;span class="hx-absolute -hx-mt-20" id="para-los-100-puntos">&lt;/span>
&lt;a href="#para-los-100-puntos" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución era para aquellos que supieran hacer una búsqueda utilizando una cola de prioridad. La idea es que al sacar un elemento de la cola siempre nos dé aquel al que se puede llegar con la menor cantidad de movimientos. Este procedimiento es idéntico a una búsqueda en amplitud solo que se utiliza una cola de prioridad. En la solución hago uso de un montículo como cola de prioridad.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559202.js">&lt;/script></description></item><item><title>Solución a "K-Arbol"</title><link>https://blog.omegaup.com/solution/solucion-a-k-arbol/</link><pubDate>Mon, 07 Jan 2013 17:37:40 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-k-arbol/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P5" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 5&lt;/a> **Autor: **&lt;a href="mailto:lkt345@gmail.com" >Saul de Nova Caballero&lt;/a>&lt;/p>
&lt;p>En pocas palabras el problema es, dado un árbol que se puede colorear, encuentra la menor solución satisfaciendo las restricciones dadas sobre los colores. Este problema es un caso particular de Graph Coloring(en español coloración de grafos), en donde el grafo es un árbol.&lt;/p>
&lt;h1>Subcaso 1(10 puntos)&lt;/h1>&lt;p>Para el primer subcaso era posible hacer una búsqueda en profunidad sobre todos los nodos, encontrando la menor solución. Para guardar el árbol, era posible utilizar una matriz que guardara todos los colores posibles y entonces ver si era posible una solución con el menor color posible. La solución de este caso era trivial si se usaba una búsqueda exhaustiva.&lt;/p>
&lt;h1>Subcaso 2(20 puntos)&lt;/h1>&lt;p>Para el segundo subcaso era necesario una mejor estrategia. Para este caso, era necesaria la observación de que todos los colores de los nodos solo dependen de su padre y de sus hijos. Otra observación importante era que para los nodos del árbol, excepto las hojas, había que procesar a sus hijos menores.Procesar implica checar que colores puede tener un nodo. Por lo que para lograr los puntos en este subcaso era necesario procesar los nodos hijos, luego sus padres y asi sucesivamente. Es decir para procesar, un nodo primero hay que procesar a todos sus hijos.&lt;/p>
&lt;p>La forma de procesar a un nodo es la siguiente. Por cada nodo se compara con su padre y al momento de comparar, lo que se busca es que por cada color del nodo, el padre no tenga un color que lo elimine como opción. Es decir tengo el siguiente caso&lt;/p>
&lt;p>Nodo -&amp;gt; Rojo, Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo, Verde&lt;/p>
&lt;p>Por cada color del nodo, el padre puede elegir un color distinto. Por ejemplo, si el Nodo es Rojo, el padre puede ser Verde. Si el nodo es Verde, el padre puede ser Rojo y si el nodo es Azul, puedes elegir el Rojo o el Verde. Sin embargo, para el siguiente caso&lt;/p>
&lt;p>Nodo -&amp;gt; Rojo, Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo&lt;/p>
&lt;p>El padre del nodo solo puede ser Rojo, por lo que para que las condiciones del problema se cumplan, el Nodo no puede ser Rojo. En este caso actualizamos la tabla de valores posibles del Nodo. Y queda como&lt;/p>
&lt;p>Nodo -&amp;gt; Verde, Azul&lt;/p>
&lt;p>Padre -&amp;gt; Rojo&lt;/p>
&lt;p>Lo anterior se hace para cada par de nodos desde los nodos hoja hasta la raíz. Procesandolos de menor a mayor da la mejor solución&lt;/p>
&lt;h1>Subcaso 3(20 puntos)&lt;/h1>&lt;p>Para obtener los puntos del subcaso 3 era posible simplemente ver por cada nodo procesarlo comenzando en la raíz, ya que en este caso el grafo en basicamente una gran línea. Utilizando la técnica descrita en el subcaso 2 por cada nodo se obtenía una solución a este subcaso&lt;/p>
&lt;h1>Subcaso 4(50 puntos)&lt;/h1>&lt;p>Para los puntos del cuarto caso era necesario &amp;ldquo;linearizar&amp;rdquo; el grafo, esto simplemente significa que los nodos mas arriba van a tener menor prioridad que los nodos de abajo, es decir el nodo raíz tendría valor 0 mientras que sus hijos tendrían valores más altos. Por ejemplo para un caso asi:&lt;/p>
&lt;p>0 -&amp;gt; 1 -&amp;gt; 4&lt;/p>
&lt;p>-&amp;gt; 2&lt;/p>
&lt;p>-&amp;gt; 3&lt;/p>
&lt;p>El nodo 0 es la raíz del árbol, el nodo 1 y 3 son hijos de 0 y los nodos 2 y 4 son hijos de 1, el arbol se linearizaría de la siguiente manera:&lt;/p>
&lt;p>0 -&amp;gt; 1, 1 -&amp;gt; 2, 3 -&amp;gt; 3, 4 -&amp;gt; 4, 2 -&amp;gt; 5&lt;/p>
&lt;p>Ahora lo que es necesario hacer es por cada nodo de mayor prioridad a los de menor prioridad es necesario hacer la técnica explicada en el subcaso 2.Tomando en cuenta otra observación. Que solo es necesario procesar los nodos que solo tengan un color. Es decir si el nodo 0 tiene posibilidad de ser Rojo, Azul o Verde, no es necesario procesarlo. Sin embargo si un nodo solo puede ser azul, hay que eliminar esa posiblidad tanto de su padre como de sus hijos.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/linearizar.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Imagen obtenida de &lt;a href="http://aima.cs.berkeley.edu/newchap05.pdf" target="_blank" rel="noopener">http://aima.cs.berkeley.edu/newchap05.pdf&lt;/a>&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">1&lt;/span> &lt;span class="c1">// karbol100.cpp
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="c1">// By Saul de Nova Caballero
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">4&lt;/span> &lt;span class="c1">//Librerias de la standard template library de c++(stl)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">5&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">algorithm&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">6&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cassert&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">7&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cstdio&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">8&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cstdlib&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">9&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">cstring&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">10&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">iostream&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">11&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">12&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">include&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">utility&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">13&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">14&lt;/span> &lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">15&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">16&lt;/span> &lt;span class="c1">//Iterador sobre estructuras de datos. En este caso listas de la stl
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">17&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">define&lt;/span> &lt;span class="n">TR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">18&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">typeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">container&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">19&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">20&lt;/span> &lt;span class="c1">//Definicion de un par de la stl
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">21&lt;/span> &lt;span class="k">typedef&lt;/span> &lt;span class="n">pair&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">pii&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">22&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">23&lt;/span> &lt;span class="c1">//Constantes del programa
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">24&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAXN&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10002&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">25&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAXM&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">502&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">26&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAXMEM&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">27&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">28&lt;/span> &lt;span class="c1">//Clase para definir los hijos del arbol
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">29&lt;/span> &lt;span class="c1">//Es una lista con todos los hijos de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">30&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Graph&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">31&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">32&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">addNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">33&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">34&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">35&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodes&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">36&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">37&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">38&lt;/span> &lt;span class="c1">//Clase para cola de las busquedas en amplitud
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">39&lt;/span> &lt;span class="c1">//Es de tipo generica
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">40&lt;/span> &lt;span class="k">template&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">41&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Queue&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">42&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">43&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">init&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">44&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">init&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">p1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">p2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">45&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">p1&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">46&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="nf">front&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">p2&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">47&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">48&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">p1&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">49&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">50&lt;/span> &lt;span class="k">private&lt;/span> &lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">51&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">p1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">p2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">52&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">memory&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXMEM&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">53&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">54&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">55&lt;/span> &lt;span class="c1">//Definicion de todas las variables del programa
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">56&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">C&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">//Variables dadas
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">57&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="c1">//La cantidad de colores posibles por nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">58&lt;/span> &lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="c1">//El padre de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">59&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//El color que le asigne al final al nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">60&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXN&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">MAXM&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">//Una matriz con todos los colores posibles por cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">61&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//Una lista ordenada de mayor a menor por la profundidad de cada nodo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">62&lt;/span> &lt;span class="n">Graph&lt;/span> &lt;span class="n">tree&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//Mi arbol
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">63&lt;/span> &lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">pii&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//Una cola para la busqueda
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">65&lt;/span> &lt;span class="c1">//Regresa el color valido por cada nodo permitiendo que un nodo no sea de un color
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">66&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">constraint&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">67&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">68&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">constraint&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">69&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">70&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">71&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">72&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">73&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">74&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">75&lt;/span> &lt;span class="c1">//Funcion para la lectura de todas las variables y la inicializacion de las estructuras
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">76&lt;/span> &lt;span class="c1">//Los asserts son para probar que el codigo es correcto
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">77&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Guarda&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">allowedColors&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">posibles&lt;/span> &lt;span class="n">colores&lt;/span> &lt;span class="n">por&lt;/span> &lt;span class="n">nodo&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">una&lt;/span> &lt;span class="n">matriz&lt;/span>&lt;span class="err">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">78&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">79&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">prohibited&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">80&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">81&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">MAXN&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">82&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">83&lt;/span> &lt;span class="nf">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">84&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">85&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">86&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">87&lt;/span> &lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">node&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">88&lt;/span> &lt;span class="n">tree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">addNode&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">89&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">90&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">91&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">92&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">C&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">93&lt;/span> &lt;span class="nf">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">prohibited&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">94&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">node&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">prohibited&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">prohibited&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">95&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">prohibited&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">//Checa que los nodos no se repitan ya que se pueden repetir
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="mi">96&lt;/span> &lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">prohibited&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">97&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">node&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">98&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">99&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">100&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">101&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">102&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Una&lt;/span> &lt;span class="n">busqueda&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">amplitud&lt;/span> &lt;span class="n">para&lt;/span> &lt;span class="s">&amp;#34;linearizar el árbol&amp;#34;&lt;/span>&lt;span class="err">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">103&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">orderNodes&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">104&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">make&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">105&lt;/span> &lt;span class="nf">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">106&lt;/span> &lt;span class="n">pii&lt;/span> &lt;span class="n">value&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">107&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_front&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">108&lt;/span> &lt;span class="n">TR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tree&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">nodes&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">109&lt;/span> &lt;span class="n">searchDepth&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">make&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">110&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">111&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">112&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">113&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">114&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">Checa&lt;/span> &lt;span class="n">por&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">nodo&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">mayor&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">menor&lt;/span> &lt;span class="n">en&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">linearizacion&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">colores&lt;/span> &lt;span class="n">posibles&lt;/span> &lt;span class="n">por&lt;/span> &lt;span class="n">nodo&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">solo&lt;/span> &lt;span class="n">tiene&lt;/span> &lt;span class="n">un&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="n">posible&lt;/span>&lt;span class="err">\*/&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">115&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">enforceArc&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">116&lt;/span> &lt;span class="nf">TR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">117&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">currNode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">118&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">119&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currNode&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">120&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">121&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">122&lt;/span> &lt;span class="n">swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">123&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">124&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">125&lt;/span> &lt;span class="c1">//printf(&amp;#34;%d %d %d\\n&amp;#34;, currNode, parent, color);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">126&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">127&lt;/span> &lt;span class="n">allowedColors&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">128&lt;/span> &lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">129&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">130&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">131&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">132&lt;/span> &lt;span class="c1">//Si no hay colores posibles, no se puede resolver el mapa
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">133&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">currNode&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">134&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;-1&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">n&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">135&lt;/span> &lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">136&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">137&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">138&lt;/span> &lt;span class="c1">//Checa de nuevo si alguno de los colores no puede ser
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">139&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">140&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">allowedColorsSize&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">141&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;-1&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">n&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">142&lt;/span> &lt;span class="n">exit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">143&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">144&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">145&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">146&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">147&lt;/span> &lt;span class="c1">//Hace un ciclo checando el menor color posible por nodo e imprime los colores menores
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">148&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">findSolution&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">149&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">150&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">&amp;gt;::&lt;/span>&lt;span class="n">iterator&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">151&lt;/span> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">152&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">153&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">154&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">155&lt;/span> &lt;span class="nf">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">parents&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">156&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">validColor&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">157&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">158&lt;/span> &lt;span class="nf">assert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">color&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">M&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">159&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">160&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">nodesOrder&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">161&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">162&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">163&lt;/span> &lt;span class="nf">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d&lt;/span>&lt;span class="se">\\&lt;/span>&lt;span class="s">n&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">colorAssigned&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">164&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">165&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">166&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">167&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">168&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">169&lt;/span> &lt;span class="n">orderNodes&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">170&lt;/span> &lt;span class="n">enforceArc&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">171&lt;/span> &lt;span class="n">findSolution&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">172&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">173&lt;/span> &lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "Metro"</title><link>https://blog.omegaup.com/solution/solucion-a-metro/</link><pubDate>Mon, 07 Jan 2013 17:22:45 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-metro/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P12" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 12&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>El problema en cuestión se reduce a encontrar un árbol de expansión mínima. La solución es una aplicación directa de alguno de los algoritmos existentes para ello (bien implementada), por lo que hablaré brevemente sobre una de las posibilidades y daré referencias donde puedan encontrar información más detallada.&lt;/p>
&lt;p>Para encontrar el costo mínimo de unir todas las estaciones debemos encontrar el árbol de expansión mínima de la gráfica en cuestión (es decir, una subgráfica conexa que una todos los vértices de la gráfica original y cuyo peso (la suma de los costos de todas sus aristas) sea el mínimo posible (siempre es un árbol)). Para ello una opción es usar el algoritmo de Kruskal: Ordenamos las aristas por su peso y vamos agregando cada arista de peso mínimo que no cree un ciclo en la gráfica. Hacemos esto hasta haber conectado todos los vértices de nuestra gráfica. Por la cantidad de aristas que tenemos requerimos ordenar eficientemente y verificar si las aristas forman un ciclo o no eficientemente en cada paso, de lo contrario el programa no correrá en tiempo.&lt;/p>
&lt;p>Para verificar si se forma o no un ciclo agregando una determinada arista empleamos el algoritmo conocido como Union Find, que se explica ampliamente en las secciones 16.7, 16.8 y 16.9 del libro Problemas y Algoritmos de Luis E. Vargas Azcona. Es importante mencionar que para obtener los 100 puntos en el problema es necesario implementar las optimizaciones que se mencionan (y aunque no fuera así no está de más que las conozcan).&lt;/p>
&lt;p>Además del libro de Luis E. Vargas, que recomiendo ampliamente, sugiero la página de Pier Guillen &lt;a href="http://pier.guillen.com.mx/" target="_blank" rel="noopener">http://pier.guillen.com.mx/&lt;/a> , que en -&amp;gt;Algorithms -&amp;gt;10. Gráficas -&amp;gt;10.6 Árboles Mínimos Generadores desarrolla el tema en cuestión. Y claro, no está de más que consulten el tema en el libro Introduction to Algorithms de Thomas H. Cormen, que en la tercera edición trabaja el tema en el capítulo VI. Graph Algorithms -&amp;gt;23 Minimum Spanning Trees.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559170.js">&lt;/script></description></item><item><title>Solución a "Pulseras"</title><link>https://blog.omegaup.com/solution/162/</link><pubDate>Mon, 07 Jan 2013 16:58:46 +0000</pubDate><guid>https://blog.omegaup.com/solution/162/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Considero este problema como un buen ejemplo para quienes desean comenzar a trabajar con problemas de programación dinámica. Se nos pide calcular la cantidad de pulseras diferentes que se pueden construir bajo ciertas condiciones. Podemos comenzar preguntándonos, ¿qué sucede si la primera cuenta es negra? La siguiente podrá ser sólo blanca. Y si comenzamos con una blanca, la siguiente puede ser negra o blanca. Podemos entonces en una matriz de 2xn colocar en cada columna cuántas secuencias distintas hay que en la posición i-ésima terminen en negro y cuántas en blanco de tal modo que no haya dos cuentas negras consecutivas. Simplemente, para obtener los números de la siguiente posición, observamos que el número de las que terminan en blanco es la suma de ambos números de la posición anterior y de las que terminan en negro es el número de secuencias que terminan en blanco de la posición anterior.&lt;/p>
&lt;p>Resta solo un detalle más a considerar. Requerimos que la secuencia no inicie y termine en negro, pues los extremos quedarán adyacentes al cerrar la pulsera. Una forma de resolver esto es la siguiente: Contamos, con el método descrito, cuántas secuencias distintas hay que inicien con blanco y que no tengan dos cuentas negras consecutivas. El número que nos pide el problema será entonces la cantidad de pulseras que empiezan con blanco y cumplen con que no haya dos negras consecutivas (independientemente de con qué color terminen) más el número de pulseras que inicien con negro y terminen con blanco (y claro, cumplan con que no haya dos negras consecutivas). ¿Cuántas hay de estas últimas? La misma cantidad que de pulseras que inician con blanco y terminan con negro, pues su simétrica inicia con negro, termina con blanco y claramente sigue cumpliendo el que no posea dos cuentas negras consecutivas. Así que es posible resolver el problema con un código muy breve, como se muestra abajo.&lt;/p>
&lt;p>Solo resta mencionar que hay que tener cuidado de aplicar el módulo correctamente. Se pueden evitar errores definiendo el valor del mismo para no tener que escribir el número varias veces.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559167.js">&lt;/script></description></item><item><title>Solución a "Los Bloques de Link"</title><link>https://blog.omegaup.com/solution/solucion-a-los-bloques-de-link/</link><pubDate>Mon, 07 Jan 2013 16:54:06 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-los-bloques-de-link/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:alainacme@gmail.com" >Alain Acevedo Mejía&lt;/a>&lt;/p>
&lt;p>Es claro que no es posible probar todas las sucesiones posibles de movimientos de los bloques para encontrar la solución (a excepción de casos muy simples). El número de tales sucesiones puede ser infinito en caso de que se puedan formar ciclos de movimientos (lo cual sucede en muchos de lo casos de prueba), y aún en casos donde el número sea finito puede suceder que no se tenga tiempo para probarlos todos.&lt;/p>
&lt;p>Una primera observación crucial es que, en el estado del mapa, solo nos interesa saber donde están los bloques de hielo en cada paso, es decir, su ubicación es lo que determina lo que nos interesa del estado. No nos interesan los pasos previos que los llevaron a su posición, solo que sea el número mínimo posible. Tenemos un problema que puede ser resuelto realizando una búsqueda en amplitud.&lt;/p>
&lt;p>¿Cuántos estados es posible alcanzar? El mapa es a lo más de 40x40 espacios y las orillas siempre están bloqueadas, así que realmente tenemos 38x38=1444 espacios a los que quizá es posible llevar a los bloques. Tenemos dos bloques de hielo, así que hay (1444x1443)/2=1,041,846 formas de colocarlos en el mapa (hemos considerado aquí ya el hecho de que son indistinguibles). Para fines de la búsqueda el número que hemos calculado es en realidad una cota superior muy mala (mala en el sentido de que la cota superior mínima es muy inferior, es decir, calculamos “de más”), pues por la forma en que se mueven los bloques es claro que aún en el peor de los casos posibles la cantidad de estados a los que se puede acceder es mucho menor (¿cuál es el peor de los casos?). Es posible entonces emplear una búsqueda en amplitud común para resolver el problema, el espacio de búsqueda no es muy grande y es claro que podemos recorrerlo por completo.&lt;/p>
&lt;p>Para representar los estados requerimos tener la posición de ambos bloques, y nada más. Podemos emplear una arreglo de bool&amp;rsquo;s (boolean&amp;rsquo;s en pascal) de cuatro dimensiones para marcar los estados a los que se ha accedido. Para la cola, en el código que se anexa más abajo, empleamos un arreglo de dos dimensiones (una matriz) donde además de guardar la posición de los bloques de los estados guardamos la cantidad de movimientos realizados para llegar a cada estado. Para ver a que estados podemos llegar desde un estado dado basta con ver en que direcciones es posible mover los bloques y a qué posición llegarán.&lt;/p>
&lt;p>Para optimizar la búsqueda podemos hacer dos observaciones. La primera es que con nuestra representación de los estados podríamos llegar dos veces al mismo estado, ya que los dos bloques de hielo son para nuestros fines iguales. En el código de abajo es por ello que al llegar a un estado nuevo se marcan dos valores en el arreglo de bools como verdaderos, pues ambos representan en realidad el mismo estado.&lt;/p>
&lt;p>Otra observación es que para averiguar eficientemente a que estados se puede llegar desde un estado dado podemos precalcular, antes de realizar la búsqueda, para cada espacio vacío o con bloque de hielo, cuál es la posición del espacio bloqueado (con numeral # o con el botón A) más cercano en cada dirección. Así solo habrá que comparar esa posición con la del otro bloque de hielo para ver a dónde llegará el bloque tras su movimiento. Esto puede mejorar el tiempo de ejecución para un caso dado, aunque no siempre es así. En este problema para obtener los 100 puntos no hacen falta optimizaciones de este tipo, aunque es bueno tener este tipo de ideas en mente para problemas más complejos.&lt;/p>
&lt;p>El siguiente código resuelve el problema:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559163.js">&lt;/script></description></item><item><title>Solución a "Problema"</title><link>https://blog.omegaup.com/solution/solucion-a-problema/</link><pubDate>Mon, 07 Jan 2013 16:34:20 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-problema/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Primero, dado una secuencia $latex A$ denotaremos por $latex s(A)$ a la suma de los elementos de A. Entonces podemos replantear el problema como: Dada una secuencia $latex S$ debemos de econtrar una subsecuencia $latex A$ de $latex S$ tal que $latex s(A) - (s(S) - s(A))$ sea la minima posible.&lt;/p>
&lt;p>Ahora, como $latex s(A) - (s(S) - s(A)) = 2 \times s(A) - s(S)$, entonces tenemos que minimizar $latex 2 \times s(A) - s(S)$ que es lo mismo que minimizar $latex s(A) - s(S)/2$. O sea, debemos de encontrar una subsecuencia $latex A$ cuya suma esté lo más cercana a la mitad de la suma de $latex S$, en particular podemos restringir nuestra búsqueda a las subsecuencias cuya suma sea menor o igual a $latex s(S)/2$.&lt;/p>
&lt;p>Se plantea para este problema una solución de tipo &lt;em>Programación Dinámcia&lt;/em> que corre sobre los elementos de la secuencia $latex S$ y considera todas las posibles diferentes sumas de subsecuencias cuyos elementos tienen índices menores o iguales al actual y cuya suma no excede $latex s(S)/2$. Se tendrán entonces $latex n \times s(S)/2$ posibles estados y cada uno podrá ser procesado en tiempo constante ya que solo hay dos trancisiones posibles para cada estado: Se toma el elemento actual dentro de la subsecuencia o no. Por lo tanto la solución tendrá una complejidad temporal de $latex O (n \times s(S))$.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559155.js">&lt;/script></description></item><item><title>Solución a "Alfiles"</title><link>https://blog.omegaup.com/solution/solucion-a-alfiles/</link><pubDate>Mon, 07 Jan 2013 16:23:49 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-alfiles/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P7" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 7&lt;/a> **Autor: **&lt;a href="mailto:hugochiquito.cpp@gmail.com" >Hugo Dueñas&lt;/a>&lt;/p>
&lt;p>Lo primero que se debe de notar es que en cada una de las $latex 2n-1$ diagonales principales, las cuales mostradas en la imagen de abajo, habrá máximo 1 alfil. Lo mismo se cumple para las diagonales invertidas, mostradas también en una imagen abajo.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic1.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/pic2.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora, cada diagonal principal se cruza con ciertas diagonales invertidas. Entonces se plantea una solución de tipo &lt;em>Backtracking&lt;/em> que corre sobre las diagonales principales marcando diagonales invertidas a cada paso (representando que se ha colocado un alfil en el cruce de esas dos diagonales).&lt;/p>
&lt;p>Una implementación directa y sin optimizaciones ni podas para los casas donde $latex n = 8$ hará uso de $latex 1\times2\times3\times4\times5\times6\times7\times8\times7\times6\times5\times4\times3\times2\times1=203212800$ operaciones, lo cual no está muy lejos de ser una solución eficiente. Entonces bastan algunas podas para obtener una solución al 100%, podemos por ejemplo podar las ramas de la recursión que consideran combinaciones con una diagonal invertida repetida.&lt;/p>
&lt;p>A continación se lista una implementación en C++ de la solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559152.js">&lt;/script></description></item><item><title>Solución a "Mario Reloaded"</title><link>https://blog.omegaup.com/solution/solucion-a-mario-reloaded/</link><pubDate>Mon, 07 Jan 2013 16:08:32 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-mario-reloaded/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P8" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 8&lt;/a> **Autor: **&lt;a href="mailto:paspartu@gmail.com" >Pavel Herrera Dominguez&lt;/a>)&lt;/p>
&lt;h2>Observaciones&lt;span class="hx-absolute -hx-mt-20" id="observaciones">&lt;/span>
&lt;a href="#observaciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Lo primero es ver como se modelan los estados del problema sin pensar en que Mario puede tomar los atajos, únicamente pensar en las llaves, claramente existen $latex n\times2^m$ estados, pues no importa el orden en que se toman las llaves solo las llaves que se tienen al llegar a cada puerta. A partir de aquí nos referiremos como estado a la puerta y las llaves que trae Mario.&lt;/p>
&lt;p>La segunda observación es ver como afecta llegar a una puerta con cierto juego de llaves, osea a cada estado. Cada vez que visitamos un estado todos los estados ya visitados que tienen el mismo juego de llaves se actualiza instantáneamente. Esto se puede entender como si únicamente el juego de llaves definiera el estado, lo que nos lleva a pensar que el problema es saber que puertas pertenecen a qué juego de llaves.&lt;/p>
&lt;p>De la observación anterior podemos pensar que si mantenemos una lista de puertas ya visitadas para cada juego de llaves, cuando algún estado (puerta, juego de llaves) se visita con un menor tiempo, todas las puertas alcanzadas con ese juego de llaves deben ser actualizadas y sus respectivos vecinos.&lt;/p>
&lt;h2>Idea&lt;span class="hx-absolute -hx-mt-20" id="idea">&lt;/span>
&lt;a href="#idea" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>La idea es hacer una especie de búsqueda en amplitud la cual tome en cuenta las observaciones anteriores. Esto es una búsqueda que visite los estados (puerta, llave) y conserve una lista de las puertas alcanzables con cada juego de llaves.&lt;/p>
&lt;h2>Implementacion&lt;span class="hx-absolute -hx-mt-20" id="implementacion">&lt;/span>
&lt;a href="#implementacion" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559138.js">&lt;/script>
&lt;h2>Tarea&lt;span class="hx-absolute -hx-mt-20" id="tarea">&lt;/span>
&lt;a href="#tarea" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Pensar si es posible hacer la búsqueda sin usar los estados (puerta, juego de llaves).&lt;/p></description></item><item><title>Solución a "El collar de perlas"</title><link>https://blog.omegaup.com/solution/solucion-a-el-collar-de-perlas/</link><pubDate>Thu, 03 Jan 2013 16:01:37 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-el-collar-de-perlas/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 10&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P10" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://goldendarknut.blogspot.mx/" target="_blank" rel="noopener">Félix Rafael Horta Cuadrilla&lt;/a>&lt;/p>
&lt;p>En una bosque habitan dos clanes de enanos: los enanos rojos y los enanos verdes. Durante sus expediciones en las cuevas cercanas, un grupo de enanos rojos y verdes encontraron un collar formado por perlas blancas y negras que no tienen ningun valor, pero al final del collar hay un valioso diamante. Los dos clanes de enanos quieren apoderarse del diamante.&lt;/p>
&lt;p>Para resolver el problema de manera pacifica deciden jugar el siguiente juego: a cada uno de los N enanos se le asigna un numero del 1 al N (un numero diferente para cada enano) y dos listas de numeros, una negra y una blanca (las listas pueden ser diferentes entre si). Cada lista contiene una cantidad diferente de numeros, cada numero &lt;em>i&lt;/em> en cualquier lista representa al enano &lt;em>i&lt;/em>.&lt;/p>
&lt;p>Durante el juego, el collar se pasa de un enano a otro de acuerdo con las siguientes reglas: cuando un enano recibe el collar, el quita la primer perla en el collar y si la perla es blanca, entonces pasa lo que quedo del collar a cualquier enano que este en su lista blanca (al que el quiera), pero si la piedra es negra, entonces pasa lo que quedo del collar a algun enano de su lista negra. Para empezar el juego, el collar se le da a un enano aleatoriamente.&lt;/p>
&lt;p>En algun momento el collar solamente va a tener el diamante, el enano que recibe el collar en este estado gana el diamante para su clan y el juego termina.&lt;/p>
&lt;p>&lt;strong>Problema&lt;/strong>&lt;/p>
&lt;p>Escribe un programa que ayude a los enanos verdes a obtener el diamante, sabiendo de antemano las listas de todos los enanos. Puedes asumir que los enanos rojos juegan de manera optima. Se garantiza que siempre habra una forma en la que los enanos verdes puedan ganar si juegan optimamente.&lt;/p>
&lt;p>&lt;strong>Entrada&lt;/strong>&lt;/p>
&lt;p>La primer linea contiene la longitud &lt;strong>L&lt;/strong> del collar, el numero &lt;strong>N&lt;/strong> de enanos y el numero &lt;strong>F&lt;/strong> que representa el enano que empieza con el collar.&lt;/p>
&lt;p>La segunda linea contiene &lt;strong>L&lt;/strong> caracteres (seguidos, es decir, &lt;strong>NO&lt;/strong> hay espacios entre ellos) que representan el collar, estos caracteres pueden ser una letra &lt;strong>B&lt;/strong> que significa que es una perla blanca, una letra &lt;strong>N&lt;/strong> que significa que es una perla negra o una &lt;strong>D&lt;/strong> que indica que es el diamante. Solo habra un diamante y este siempre estara al final del collar.&lt;/p>
&lt;p>Las siguientes &lt;strong>N&lt;/strong> lineas describen a los enanos y sus listas. Cada linea esta formada por un numero &lt;strong>C&lt;/strong> que representa el color del enano (0 si es verde y 1 si es rojo) seguido por la longitud &lt;strong>LN&lt;/strong> de la lista negra y de &lt;strong>LN&lt;/strong> numeros, representando cada uno de los numeros en la lista negra del enano. Finalmente, en la misma linea, el numero &lt;strong>LB&lt;/strong> que indica la longitud de la lista blanca del enano y de &lt;strong>LB&lt;/strong> numeros indicando los elementos de dicha lista.&lt;/p>
&lt;p>&lt;strong>Límites&lt;/strong>&lt;/p>
&lt;p>1 &amp;lt;= L &amp;lt;= 1000&lt;/p>
&lt;p>1 &amp;lt;= N &amp;lt;= 1000&lt;/p>
&lt;p>&lt;strong>Interacción&lt;/strong>&lt;/p>
&lt;p>Este problema es interactivo y deberas escribir una funcion llamada &lt;em>juega()&lt;/em> que lea de pantalla el problema los datos de entrada y se cominique con tres funciones en una libreria.&lt;/p>
&lt;p>Las tres funciones con las que hay que interactuar son las siguientes:&lt;/p>
&lt;p>    void pasaCollar(int enano);&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos verdes posea el collar, tu programa mande el collar al enano especificado como parametro. Llamar a &lt;em>pasaCollar&lt;/em> cuando no le corresponde o pasar el collar a un enano que no este en la lista correspondiente resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>    int recibeCollar();&lt;/p>
&lt;p>Que sirve para que cuando uno de los enanos rojos posea el collar, tu programa llame a esta funcion para saber a que enano paso el collar el evaluador. Llamar a esta funcion cuando no le corresponde el turno a un enano rojo resultara en 0 puntos en ese caso.&lt;/p>
&lt;p>void termina();&lt;/p>
&lt;p>Debe ser llamada una vez cuando en el collar solo quede el diamante. Si se llama en otro momento o si se llama y el collar esta en posesion de un enano rojo obtendras cero puntos en ese caso. Solo recibiras puntos si llamas a la funcion &lt;em>termina()&lt;/em> cuando el collar este en posesion de un enano verde y el collar solo posea al diamante.&lt;/p>
&lt;p>&lt;strong>Ejemplo&lt;/strong>&lt;/p>
&lt;p>Entrada&lt;/p>
&lt;p>6 4 2&lt;br>
NBBNND&lt;br>
0 1 2 1 4&lt;br>
0 2 1 3 1 1&lt;br>
1 1 4 1 4&lt;br>
1 2 2 3 1 1&lt;/p>
&lt;p>Salida&lt;/p>
&lt;p>pasaCollar(1)&lt;br>
pasaCollar(4)&lt;br>
recibeCollar() -&amp;gt; 1&lt;br>
pasaCollar(2)&lt;br>
pasaCollar(1)&lt;br>
termina()&lt;/p>
&lt;p>&lt;strong>Compilación&lt;/strong>&lt;/p>
&lt;p>Se proporcionan plantillas para facilitar la codificación del problema, de esa forma sólo necesitas codificar el archivo perlas.c/perlas.cpp/perlas.pas. Las plantillas son solo para facilitar la codificación y las pruebas, &lt;strong>no se garantiza que se evaluará con las mismas&lt;/strong>.&lt;/p>
&lt;p>Utilizando la plantilla proporcionada, puedes compilar este programa correctamente en C++ de la siguiente forma:&lt;/p>
&lt;p>    g++ main.cpp perlas.cpp -o perlas&lt;/p>
&lt;p>En C, se hace de la siguiente forma:&lt;/p>
&lt;p>    g++ main.c perlas.c -o perlas&lt;/p>
&lt;p>Mientras que para Pascal:&lt;/p>
&lt;p>fpc main.pas&lt;/p>
&lt;p>De la misma forma, las opciones de compilación pueden ser diferentes en la evaluación, sin embargo, si tu programa compila con las plantillas, también debería de hacerlo en el evaluador.&lt;/p>
&lt;p>&lt;strong>Descarga las plantillas &lt;a href="https://www.dropbox.com/sh/nux63uknmdyzgej/sfqTP9Tng8/plantillas.rar" target="_blank" rel="noopener">aquí&lt;/a> .&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Solución&lt;/strong>&lt;/p>
&lt;p>Una manera sencilla de tratar de ganar en este juego, es hacer una búsqueda sobre las listas de los enanos verdes y siempre pasar el collar sobre los enanos verdes, lo cual resolvería un par de casos. Sin embargo, en la mayor parte de los casos, es necesario pasar el collar a un enano rojo que eventualmente lo regresará a un enano verde. Y este es precisamente el problema, saber cuándo pasar a un enano rojo y a qué enano rojo, y como se necesita de la interacción de los enanos rojos para llegar a la solución, un gran problema se presenta.&lt;/p>
&lt;p>Aunque este problema podría resolverse fácilmente con una búsqueda memorizada haciendo las llamadas a las funciones durante la búsqueda, no puede hacerse de esta forma porque cuando se hace una búsqueda se requiere poder ir hacia adelante y hacia atrás en el árbol de búsqueda, y como se necesita de la interacción de los enanos rojos, se tiene que lograr la solución en la primera pasada.&lt;/p>
&lt;p>Por lo tanto hay que calcular todas las posibles tiradas antes de jugar, considerando las mejores tiradas de los enanos rojos. De esta forma, una vez que se tiene  una jugada para ganar el juego para &lt;strong>cualquier estado posible&lt;/strong>, se puede jugar teniendo seguro el triunfo.&lt;/p>
&lt;p>Ahora, aunque sabemos que no se puede resolver con una búsqueda, sí podemos utilizar un árbol de búsqueda para resolver el problema, pero ¿cómo tomar en cuenta las elecciones de los enanos rojos?, la respuesta a esto es jugar para ambos equipos y usar el mismo cósigo para ello, eligendo siempre la mejor opción para &lt;strong>el color de enano&lt;/strong> en cada turno, es decir, cuando la búsqueda esté sobre un enano rojo, hay que elegir la opción que haga que los enanos rojos ganen, y cuando la búsqueda esté sobre un enano verde, hay que elegir la opción que haga ganar a los enanos verdes.&lt;/p>
&lt;p>Es evidente que cuando las hojas del árbol terminan en un enano verde, se gana el juego (esos estados son estados ganadores), y cuando termina en un enano rojo el juego se pierde (esos estados son estados perdedores), eso es fácil, lo difícil son los siguientes niveles.&lt;/p>
&lt;p>Tomando en cuenta esto necesitamos etiquetar todos los estados como estados ganadores o estados perdedores, debido a que ya sabemos qué son los estados hojas, podemos deducir qué son los estados anteriores a las hojas de la siguiente forma: Si el estado pertenece a un enano verde, nos basta con que UN y solo UN enano en su lista lleve a un estado ganador, ya que como enanos verdes podemos controlar a quien le pasamos el collar, por lo que basta con que el estado pueda llevar a un estado ganador para que también sea un estado ganador. Si el enano verde NO lleva a ningún estado ganador, entonces ese estado NO es un estado ganador, por que no importa a quien se lo pases, siempre perderás.&lt;/p>
&lt;p>Pensando de esta misma forma, si el estado pertenece a un enano rojo, necesitamos que TODOS los estados a los que conduzca sean estados ganadores, por que si hay solo un estado perdedor, los enanos rojos, que juegan con la mejor estrategia, siempre eligirán ese estado.&lt;/p>
&lt;p>De esta forma, es posible que haya enanos verdes a los que quieras evitar, y enanos rojos a los que quieras pasarle el collar.&lt;/p>
&lt;p>Entonces, para resolver el problema, hay que pasar por todos los estados y marcarlos como estados ganadores o estados perdedores con la técnica que más te guste, ya sea programación dinámica o búsqueda memorizada, pero hay que hacerlo antes de jugar. Una vez teniendo precalculado cuáles son los estados ganadores y perdedores, solo hay que hacer las llamadas de los enanos verdes siempre hacia estados ganadores.&lt;/p>
&lt;p>&lt;a href="http://elira.operamail.com/files/perlas.rar" target="_blank" rel="noopener">DESCARGAR ARCHIVOS Y SOLUCIÓN&lt;/a>&lt;/p></description></item><item><title>Solución a "Teclado Roto"</title><link>https://blog.omegaup.com/solution/solucion-a-teclado-roto/</link><pubDate>Sun, 28 Oct 2012 01:31:45 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-teclado-roto/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 2&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="#" >Jorge Alberto González Martínez&lt;/a>&lt;/p>
&lt;p>Los temas para el examen donde apareció este problema eran pilas, colas y búsqueda binaria. Después de haber estudiado los temas, es buena idea combinar la teoría aprendida.&lt;/p>
&lt;p>El problema del teclado roto describe una serie de operaciones en las que es necesaria una estructura en la que sea posible agregar elementos por ambos lados (izquierda y derecha). La descripción del problema muestra las restricciones, que no superan los 100, 000 elementos, por lo que es posible hacer un arreglo estático de caracteres de ese tamaño.&lt;/p>
&lt;p>En el caso de mi solución, para que sea más clara la inserción, también utilizo memoria auxiliar para guardar las palabras que se van a insertar en la estructura de datos.&lt;/p>
&lt;p>En el código que se muestra abajo se describe la forma en la que se implementa y opera la estructura mencionada anteriormente:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559109.js">&lt;/script></description></item><item><title>Solución a "El Artista Lento"</title><link>https://blog.omegaup.com/solution/solucion-a-el-artista-lento/</link><pubDate>Fri, 19 Oct 2012 17:09:21 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-el-artista-lento/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 2&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P2" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="#" >Christian Hernández&lt;/a>&lt;/p>
&lt;p>Lo primero de lo que debemos darnos cuenta es de que como los pedazos son de dimensiones enteras y se colocan en dimensiones enteras, podemos &amp;ldquo;pensar&amp;rdquo; el problema de manera que en lugar de pegar rectángulos de &lt;strong>Mi&lt;/strong> x &lt;strong>Ni&lt;/strong>, estamos pegando &lt;strong>Mi&lt;/strong> x &lt;strong>Ni&lt;/strong> de 1 x 1 (Ejemplo: Si tuvieramos que pegar un rectángulo de 4 x 3, podemos pensarlo como pegar 12 rectangulos de 1 x 1). Podemos pensar lo mismo de los rectángulos adhesivos.&lt;/p>
&lt;p>Si pensamos el problema sin rectángulos adhesivos, podríamos resolverlo teniendo en un arreglo matricial el color que se encuentra hasta arriba de cada rectángulo de 1 x 1 que tiene la cartulina.&lt;/p>
&lt;p>Si tomamos la misma idea pero ahora teniendo en cuenta que existen rectángulos adhesivos, nos encontramos con el problema de que si rasgamos un cuadro necesitamos recordar el color la capa de papel que se encontraba debajo de la capa &amp;ldquo;visible&amp;rdquo;, y además podemos rasgar tantas veces como capas de papel hemos puesto. Con esto tenemos que necesitamos guardar un número de valores igual al número de capas que hemos puesto. Además tenemos que tener en cuenta el orden en el que fuimos poniendo las capas; esto es la última capa que pusimos debe de recordarse primero que la primera que pusimos, o en otras palabras: El primero que entras es el último que sale, así como el el último que entra es el primero que sale. Ese comportamiento lo encontramos en la estructura de datos Pila (Si no conoces la estructura de datos, puedes consultarla &lt;a href="http://es.wikipedia.org/wiki/Pila_%28inform%c3%a1tica%29" target="_blank" rel="noopener">acá&lt;/a>).&lt;/p>
&lt;p>A continuación se encuentra la implementación de una estrúctura Pila que nos serviría para este problema:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">Pila&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2002&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">short&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">posActual&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//Devuelve si la pila esta vacia
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="nf">estaVacia&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">posActual&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//inserta un elemento en cima de la pila
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">char&lt;/span> &lt;span class="n">valor&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">posActual&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">posActual&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">valor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//quita el elemento de la cima de la pila y lo devuelve
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="nf">pop&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">valor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">estaVacia&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">valor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">posActual&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">posActual&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">valor&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">//devuelve el valor del elemento de la cima de la pila
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="nf">top&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">arreglo&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">posActual&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Es importante notar que esta es una implementación estática de una Pila (Siempre ocupa el mismo espacio en memoria sin importar el número de elementos, además de que el número de elementos máximo ya está definido). Como se ve, se han utilizado char para guardar los valores, ya que el valor de los colores llega hasta 100, por lo que un char es más que suficiente.&lt;/p>
&lt;p>Entonces teniendo pilas para recordar todas nuestras capas de papel en orden, lo que podemos hacer es hacer un arreglo matricial de pilas para resolver nuestro problema.&lt;/p>
&lt;p>Básicamente, cada que agreguemos un rectágulo de papel a nuestra cartulina lo que tenemos que hacer es, para cada rectángulo de 1 x 1 que abarca, agregar el color a la pila en su posición en la matriz. Si se trata de un rectángulo adhesivo, hacemos justo lo contrario, sacamos un valor de la pilas correspondientes.&lt;/p>
&lt;p>Sólo nos queda resolver el problema del grosor de la cartulina. Debido a que necesitamos desgarrala G veces con un rectángulo adhesivo, podemos pensar que se tratan de G capas de papel del color de la cartulina. Entonces, se reduce a inicializar nuestro arreglo pilas agregando G capas del color de la cartulina.&lt;/p>
&lt;p>La complejidad de agregar una capa de papel a la cartulina es de &lt;strong>O(M x N)&lt;/strong> (ya que una sola capa puede abarcar toda la cartulina), la misma aplica para usar un rectángulo adhesivo. Entonces la complejidad de agregar todas las capas quedaría &lt;strong>O(M x N x K)&lt;/strong> donde &lt;strong>K&lt;/strong> es el número de rectángulos por pegar. Inicializar la cartulina tendría una complejidad &lt;strong>O(M x N x G)&lt;/strong> donde &lt;strong>G&lt;/strong> es el grosor. Dejándonos con una complejidad final de &lt;strong>O(M x N x (K + G))&lt;/strong> que es suficientemente buena como para funcionar con los límites de tiempo establecidos.&lt;/p>
&lt;p>La complejidad en memoria es igual de &lt;strong>O(M x N x (K + G))&lt;/strong>, ya que se tienen que guardar las &lt;strong>(K + G)&lt;/strong> capas de papel en la matriz de &lt;strong>M&lt;/strong> x &lt;strong>N&lt;/strong>.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559074.js">&lt;/script></description></item><item><title>Solución a "Engranes"</title><link>https://blog.omegaup.com/solution/engranes-khayyam-solucion-enrique-lira/</link><pubDate>Sat, 13 Oct 2012 04:06:46 +0000</pubDate><guid>https://blog.omegaup.com/solution/engranes-khayyam-solucion-enrique-lira/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>**&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a> Autor: **&lt;a href="http://www.linkedin.com/pub/jesus-omar-ocegueda-gonzalez/18/b45/5b9" target="_blank" rel="noopener">Omar Ocegueda (Khayyam)&lt;/a> **Solución por: **&lt;a href="http://elira.me/" target="_blank" rel="noopener">Enrique Lira&lt;/a>&lt;/p>
&lt;p>Para poder resolver este problema hay que ver ciertas propiedades a las cuales podemos llegar fácilmente a partir de ejemplos. Una primera duda que nos surge es: ¿Vuelve al estado inicial?, si hacemos un par de ejemplos podemos ver que si, otra duda que nos surge es: ¿Cuándo vuelve al estado inicial?, y aquí comienza lo complicado. Para saber cuando vuelve a su estado inicial hay que notar ciertas cosas, una de ellas es que en cuanto el diente 1 vuelve a tocar al valle 1 hemos vuelto al estado inicial, no hay forma de que el diente 0 toque al valle 0 sin haber vuelto al estado inicial, entonces hay que buscar ese instante.&lt;/p>
&lt;p>Consideremos ra y rb como el número de vueltas que ha dado el engrane a y el engrane b respectivamente en un momento dado después de x pasos, hay que notar que si ra y rb son enteros significa que hemos vuelto al estado inicial o estamos en el estado inicial (ra igual a cero y rb igual a cero).&lt;/p>
&lt;p>Para que tanto ra y rb sean enteros, es necesario que x sea divisible tanto por N como por M y hay que encontrar el numero más pequeño distinto de cero (cero es el momento inicial) en el que esto pasa. Para nuestra fortuna esto es fácilmente calculable y es algo que nos enseñan en la escuela, se llama mínimo común múltiplo.&lt;/p>
&lt;p>$latex mcm(N,M) = \frac{N * M}{MCD(N, M)}&amp;amp;s=2$&lt;/p>
&lt;p>Ya que sabemos después de cuantos pasos se repite (llamémoslos K), debemos notar que en esos K pasos ningún par (diente, valle) se va a repetir, dado que si se repite significaría que K no es el primer momento en el que se vuelve al estado inicial.&lt;/p>
&lt;p>Sabiendo esto podemos saber cuantos dientes distintos pasan por cada valle, siendo K la cantidad de parejas (diente, valle) distintas que existen (no sé pueden generar más), se puede deducir que K / M es la cantidad de dientes distintos que pasan por cada valle, simplificando nos queda:&lt;/p>
&lt;p>$latex \frac{N}{MCD(N, M)}&amp;amp;s=2$&lt;/p>
&lt;p>Ahora hay que buscar una forma de saber el primer diente que pasa por un valle x, con un poco de observación podemos saber que el numero del primer diente en tocar al valle x esta dado por el residuo de la división x sobre N ( x mod N ).&lt;/p>
&lt;p>Ya que sabemos cual es el primer diente en tocar al valle x, debemos buscar la forma de calcular los otros dientes, con algunos ejemplos podemos notar que el numero del siguiente diente es M mod N veces mayor que el actual.&lt;/p>
&lt;p>En el peor de los casos, los N dientes pasan por todos los valles, resultando nuestra solución actual con una complejidad de $latex O(LN)$ y funciona bastante bien para los 80 puntos del problema.&lt;/p>
&lt;p>Para llegar a la solución de 100 puntos hay que notar que después de que un diente y se junta en un valle x, el siguiente diente en juntarse con el valle x no depende del valle sino solo del diente, es por esto que si el diente y pasa por un conjunto de valles y uno de ellos no es estable, ninguno de los otros lo será y viceversa si el diente y pasa por un valle x que es estable, todos los demás valles por los que pase serán estables. Sabiendo esto podemos guardarlo en un arreglo que nos diga por cada diente si pasa por valles estables o no, reduciendo la complejidad a $latex O(N)$.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559014.js">&lt;/script></description></item><item><title>Solución a "Juego Lento"</title><link>https://blog.omegaup.com/solution/juego-lento-ethan-jimenez/</link><pubDate>Fri, 12 Oct 2012 21:43:58 +0000</pubDate><guid>https://blog.omegaup.com/solution/juego-lento-ethan-jimenez/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener"> &lt;/a>&lt;/strong>&lt;a href="https://omegaup.com/arena/IOI2013E1P1" target="_blank" rel="noopener">Preselectivo para la IOI 2013, Etapa 1, Examen 1&lt;/a>&lt;br>
&lt;strong>Autor:&lt;/strong> &lt;a href="http://www.codechef.com/users/ethanjimenez" target="_blank" rel="noopener">Ethan Jimenez&lt;/a>&lt;/p>
&lt;p>Empecemos analizando el caso en que solo jugamos con un montón de fichas, dada la restricción de tomar únicamente una sola ficha el juego se vuelve predecible ya que no hay más opción que tomar una ficha de ese montón. Si el montón tiene una sola ficha el jugador con el primer turno pierde, si hay dos fichas el jugador con el primer turno gana, si hay tres fichas el jugador con el primer turno pierde, y así alternadamente, podemos entonces deducir que si hay un número impar de fichas en el montón, el jugador con el primer turno perderá, por el otro lado, si el montón tiene un número par de fichas ganará la partida.&lt;/p>
&lt;p>La pregunta clave para este problema es, ¿realmente hay diferencia entre tomar una ficha de un montón y tomar una ficha de otro montón? Aumentemos la cantidad de montones en el juego, digamos que ahora tenemos dos montones de fichas, ambos montones tienen una sola ficha, el jugador con el primer turno ganará, detente por un momento a experimentar qué sucede si aumentamos la cantidad de fichas en un montón, en el otro y en ambos montones, teniendo en mente la pregunta anterior.&lt;/p>
&lt;p>Después de probar con diferentes configuraciones de juego podemos decir que la respuesta a la pregunta es no, tomar primero una ficha de un montón no es diferente a haberla tomado de cualquier otro montón, con lo que podemos concluir que, si tenemos dos montones, el primero con &lt;em>&lt;strong>a1&lt;/strong>&lt;/em> fichas y el segundo con_&lt;strong>a2&lt;/strong>_fichas, este juego es equivalente a tener un solo montón con _&lt;strong>a1+a2&lt;/strong>_fichas, una vez establecido podemos volver a nuestro análisis inicial y calcular quién ganará.&lt;/p>
&lt;p>De manera análoga deducimos que si tenemos _&lt;strong>N&lt;/strong>_montones de fichas y elegimos _&lt;strong>K&lt;/strong>_de ellos, podemos reducir la configuración &lt;a href="http://maileswaste.com/category/causes/" target="_blank" rel="noopener">herpes transmission&lt;/a> de esta partida a un juego con solo un montón de _&lt;strong>k1+k2+&amp;hellip;+kN&lt;/strong>_fichas, donde kies el número de fichas en el montón elegido &lt;em>&lt;strong>i&lt;/strong>&lt;/em>. Una vez que sabemos lo anterior debemos darnos cuenta que para ganar tenemos que elegir &lt;em>&lt;strong>K&lt;/strong>&lt;/em> de los N montones cuya suma total sea un número impar.&lt;/p>
&lt;p>Para asegurarnos que un conjunto de montones tiene un número impar de fichas debemos considerar lo siguiente, un número impar más un par da un número impar, un número impar sumado a un impar da un número par y un número par más un par da otro número par. Dado lo anterior podemos definir una regla para tener una suma total impar, debe existir una cantidad impar de montones con un número de fichas impar, si le agregamos cualquier cantidad montones con número de fichas par no se modifica la condición de tener un total impar.&lt;/p>
&lt;p>En conclusión, es posible ganar el juego cuando existe más de un montón con número impar de fichas, si hay una cantidad impar de montones impares ya se cumple la condición deseada, pero si hay una cantidad par de montones impares debemos quitar uno para cumplirla, para obtener el juego con la mayor cantidad de fichas el montón que quitemos debe ser el que tenga menos fichas, nota que, como mencioné antes, agregar montones pares no afecta la condición de victoria, por lo que para aumentar la cantidad de fichas en el juego se deben agregar todos ellos.&lt;/p></description></item></channel></rss>