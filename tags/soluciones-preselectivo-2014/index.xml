<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Soluciones Preselectivo 2014</title><link>https://blog.omegaup.com/tags/soluciones-preselectivo-2014/</link><description>Recent content in Soluciones Preselectivo 2014 on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Thu, 14 Aug 2014 16:06:31 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/soluciones-preselectivo-2014/index.xml" rel="self" type="application/rss+xml"/><item><title>Solución a "Contraseña Binaria"</title><link>https://blog.omegaup.com/posts/solucion-a-contrasena-binaria/</link><pubDate>Thu, 14 Aug 2014 16:06:31 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-contrasena-binaria/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P7/#problems/contrasena-binaria" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 7&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="mailto:orlandoisay@gmail.com" >Orlando Isay Mendoza Garcia&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="mailto:chadancito@gmail.com" >Christian Adan Hernández Sánchez&lt;/a>&lt;/p>
&lt;p>Podemos ayudarnos de la imagen para comprender mejor esta explicación:&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img1.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img1.png" title="img1" alt="" loading="lazy" />
&lt;figcaption>img1&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>En ella aparecen de forma descendente a la izquierda los números pares comenzando desde el dos, y su representación binaria a la derecha. En la parte superior aparece el valor de cada cifra en decimal.&lt;/p>
&lt;p>Tomando en cuenta el límite del problema, sabemos que si sumamos $latex B(i)$ para cada par menor o igual a $latex N$, en el peor de los casos tendríamos que realizar 500,000,000,000,000 veces la función. Aún si lograramos calcularla en una operación nuestro programa excedería el tiempo límite.&lt;/p>
&lt;p>En cambio, haciendo cálculos notamos que: $latex 2^{50} \approx 1,000,000,000,000,000$. Lo cual significa que a lo más habrán 50 columnas en la tabla (ya que en la forma binaria cada cifra representa una potencia de 2).&lt;/p>
&lt;p>Dado que sabemos que en una suma el orden de las cantidades a sumar no importa, podemos determinar que es lo mismo sumar los valores de forma horizontal, tanto como de forma vertical. Sumando los valores de las columnas solo tomaría 50 operaciones. La columna 1 podemos ignorarla ya que al ser pares los números de la lista ninguno contendrá un 1 en la última cifra.&lt;/p>
&lt;p>Observando la siguiente imagen, vemos que la columna $latex C$ se forman grupos de tamaño $latex C$ (por ejemplo, en la columna 4 se forman grupos de cuatro elementos),que contienen una la mitad de $latex 1$s y la otra de $latex 0$s. También podemos ver que en la columna 2 no hay $latex 0$s antes del primer grupo, en columna 4 hay un 0, en la que sigue hay 2, luego 4,etc (área en color gris). Podemos notar que ese espacio aumenta en base a potencias del dos.&lt;/p>
&lt;p>&lt;a href="https://blog.omegaup.com/images/img2.png" >&lt;figure>
&lt;img src="https://blog.omegaup.com/images/img2.png" title="img2" alt="" loading="lazy" />
&lt;figcaption>img2&lt;/figcaption>
&lt;/figure>&lt;/a>&lt;/p>
&lt;p>Teniendo el número $latex N$ habrán $latex N / 2$ números en la lista. Para calcular la cantidad de grupos completos que se forman en cada columna dividimos $latex N$ menos el espacio lleno de ceros en esa columna, entre el número de la columna en el que estemos; a su vez, esta cantidad la multiplicamos por, el número de la columna entre dos. Sin embargo, puede que nos falten de contabilizar los $latex 1$s que pudieran estar en un grupo que no se completo. Esto se arregla sumando a lo anterior, el mínimo entre el resto de la división anterior y, el número de la columna entre dos. &lt;/p>
&lt;p>Código:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/e13fe6f396e2b48755b7.js">&lt;/script></description></item><item><title>Solución a "Poema Equino"</title><link>https://blog.omegaup.com/posts/solucion-a-poema-equino/</link><pubDate>Sun, 27 Jul 2014 07:08:35 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-poema-equino/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P5/#problems/Poema-Equino" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Los límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $latex (\text{poema},\text{fila caballo}_1,\text{columna caballo}_1,\text{fila caballo}_2,\text{columna caballo}_2)$, solamente hay $latex 100 \times (4 \times 10)^2 = 160,000$ estados distintos.&lt;/p>
&lt;p>Además, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.&lt;/p>
&lt;p>Varios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!&lt;/p>
&lt;p>La siguiente solución implementa las simplificaciones descritas anteriormente.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/3f4d3496fe0e3aadd12b.js">&lt;/script></description></item><item><title>Solución a "Carretera"</title><link>https://blog.omegaup.com/posts/solucion-a-carretera/</link><pubDate>Fri, 25 Jul 2014 04:28:19 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-carretera/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1E1/#problems/carretera" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Examen 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Para obtener los puntos de la primer subtarea bastaba notar que las condiciones especificadas significan que hay dos bloques de coches yendo en diferentes sentidos que inicialmente no se intersectan y eventualmente lo harán, por lo que la respuesta simplemente es el máximo de los anchos de estos bloques.&lt;/p>
&lt;p>Este código obtiene los primeros 30 puntos:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/94cddcf809bc5a583540.js">&lt;/script>
&lt;p>Para el resto de los puntos: Sea $latex f(t)$ el ancho necesario para la fotografía en el segundo $latex t$. La observación crucial es que $latex f$ es una función unimodal: es decir, existe un punto $latex t_0$ tal que $latex f$ es decreciente a la izquierda de $latex t_0$ y es creciente a la derecha.&lt;/p>
&lt;p>Computar $latex f(t)$ para $latex t$ fijo es trivial: basta con obtener el coche más a la izquierda y más a la derecha en el segundo $latex t$, lo cual toma tiempo $latex O(N)$. Como $latex f$ es unimodal, podemos utilizar búsqueda ternaria o búsqueda binaria para encontrar el mínimo de la función en tiempo $latex O(\lg T)$, donde $latex T$ es el tamaño del rango a evaluar. Con eso obtenemos un algoritmo con complejidad $latex O(N \lg T)$, suficiente para obtener todos los puntos del problema.&lt;/p>
&lt;p>El siguiente código implementa la solución anterior con búsqueda binaria.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/eee062837acde7bcd8ea.js">&lt;/script></description></item><item><title>Solución a "Suma Manhattan"</title><link>https://blog.omegaup.com/posts/solucion-a-suma-manhattan/</link><pubDate>Sat, 21 Jun 2014 14:34:14 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-suma-manhattan/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P1#problems/Suma-Manhattan" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Este problema requería manipular con cuidado la expresión que había que computar. Recordemos que nos piden computar&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} manhattan(S_i,S_j).$&lt;/p>
&lt;p>Para resolver la primer subtarea bastaba con iterar sobre todas las parejas de puntos y calcular su distancia. Esto corre en tiempo cuadrático y no es suficiente para obtener todos los puntos.&lt;/p>
&lt;p>La siguiente subtarea era una pista: se puede computar la distancia Manhattan de dos puntos considerando por separado sus coordenadas en $latex x$ y $latex y$. Ahora nos preocuparemos por calcular la siguiente expresión:&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j|.$&lt;/p>
&lt;p>Donde $latex a$ son las coordenadas en $latex x$ o $latex y$. El problema está en el valor absoluto. La manera más sencilla de deshacernos de él es ordenar la secuencia $latex a$, de tal manera que $latex a_i \leq a_j$. Entonces tenemos:&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_j - a_i| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - a_i.$&lt;/p>
&lt;p>La primer igualdad es verdadera porque $latex |x| = |-x|$ para cualquier $latex x$. La segunda es porque como ahora $latex a$ está ordenado, como $latex a_j \geq a_i \implies a_j - a_i \geq 0$, el valor absoluto no hace nada.&lt;/p>
&lt;p>Podemos entonces separar la suma en dos términos:&lt;/p>
&lt;p>$latex \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_i.$&lt;/p>
&lt;p>Analicemos el primer término. Estamos sumando sobre todas las $latex j$ tantas veces haya una $latex i$ menor que ella. Eso quiere decir que cada $latex a_j$ la vamos a sumar $latex j$ veces (nota que $latex a_0$ la sumamos $latex 0$ veces).&lt;/p>
&lt;p>El segundo término nos dice que sumaremos todas las $latex a_i$ tantas veces haya una $latex j$ mayor a ella. Eso quiere decir que cada $latex a_i$ la vamos a sumar $latex N-i-1$ veces (nota que $latex a_{N-1}$ la sumamos $latex 0$ veces).&lt;/p>
&lt;p>Juntando esas ideas, entonces tenemos:&lt;/p>
&lt;p>$latex \sum_{j = 0}^{N-1} j \cdot a_j - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i$&lt;/p>
&lt;p>$latex = \sum_{i = 0}^{N-1} i \cdot a_i - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i.$&lt;/p>
&lt;p>$latex = \sum_{i = 0}^{N-1} (i - (N - i - 1)) \cdot a_i.$&lt;/p>
&lt;p>$latex = \sum_{i = 0}^{N-1} (2i - N + 1) \cdot a_i.$&lt;/p>
&lt;p>Y con eso terminamos: ahora tenemos una expresión que podemos computar fácilmente en tiempo lineal. Hay que tener cuidado al computar esto: La primera observación es que hay que estar tomando módulo después de cada operación porque en cualquier momento puede haber un &lt;em>overflow&lt;/em>. Algunos competidores obtuvieron 60 puntos en este problema por no tomar esto en cuenta. La segunda observación es que el término $latex (2i - N + 1) \cdot a_i$ no necesariamente cabe en un entero signado de 32 bits &amp;ndash; hacía falta utilizar enteros de 64 bits para realizar este cálculo.&lt;/p>
&lt;p>Aquí está mi código que implementa la solución anterior.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/0614f2d1added587c2fc.js">&lt;/script></description></item><item><title>Solución a "DP Genérica"</title><link>https://blog.omegaup.com/posts/solucion-a-dp-generica/</link><pubDate>Wed, 25 Sep 2013 06:00:06 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-dp-generica/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P13#problems/DP-Generica" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 13&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Project Euler&lt;/p>
&lt;p>Podemos tratar este problema de varias maneras distintas, 3 de las cuales discutiré en esta solución.&lt;/p>
&lt;h2>Análisis 1&lt;span class="hx-absolute -hx-mt-20" id="análisis-1">&lt;/span>
&lt;a href="#an%c3%a1lisis-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero, una idea que hubiera obtenido 50 puntos.&lt;/p>
&lt;p>Podemos observar que el problema es equivalente a encontrar de cuántas maneras se le puede asignar un número $latex n_i$ del conjunto $latex \{0,1,2\}$ a cada potencia de 2 tal que $latex \sum_{i=0}^{\infty} n_i 2^i = x$. Esto también es equivalente a encontrar cuántos números $latex a$ y $latex b$ hay tales que $latex a + b = x$ y no haya ningún bit encendido en $latex b$ que no esté encendido en $latex a$.&lt;/p>
&lt;p>Consideremos la expansión binaria de $latex a = \sum_{i=0}^{\infty} a_i 2^i$ y $latex b = \sum_{i=0}^{\infty} b_i 2^i$ , donde cada $latex a_i$ y $latex b_i$ es 1 o 0. Al sumar $latex a + b = \sum_{i=0}^{\infty} (a_i + b_i) 2^i$ tenemos que $latex 0 \le n_i = a_i + b_i \le 2$, como se necesita. Para contar solamente una vez cada configuración distinta de la secuencia $latex n$, añadimos la restricción de que cualquier $latex b_i$ puede ser 1 sólo si $latex a_i$ también lo es.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Para esta subtarea es suficiente probar todas las $latex a$ y $latex b$ posibles, revisando con un loop para cada bit si la condición sobre $latex b$ se cumple. Este algoritmo corre en tiempo $latex O(N^2 \log N)$.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Para esta subtarea podemos hacer una observación sencilla: a cada $latex a$ sólo le puede corresponder una $latex b$, igual a $latex x - a$, lo que reduce la complejidad en tiempo del algoritmo a $latex O(N \log N)$.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos comprobar si $latex b$ cumple la condición en tiempo constante utilizando operaciones de bits. Si &lt;code>~a &amp;amp; b&lt;/code> es igual a 0, $latex b$ no tiene ningún bit encendido que $latex a$ no tenga encendido. Ahora tenemos un algoritmo lineal. Desafortunadamente, ya no podemos mejorar nuestra solución fácilmente continuando con esta idea.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702819.js">&lt;/script>
&lt;h2>Análisis 2&lt;span class="hx-absolute -hx-mt-20" id="análisis-2">&lt;/span>
&lt;a href="#an%c3%a1lisis-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos hacer programación dinámica de forma &lt;em>top-down&lt;/em>. En ésta, contamos la cantidad de maneras de escribir $latex x$ como pide el problema incluyendo o no cada una de las potencias distintas.&lt;/p>
&lt;p>Consideremos la función $latex f(n,p)$, que cuenta de cuántas maneras podemos escribir $latex n$ utilizando potencias de 2 menores o iguales a $latex p$ no más de 2 veces cada una. Es evidente que la respuesta se encontraría evaluando $latex f(x,63)$.&lt;/p>
&lt;p>Sabemos que $latex f(n,p) = 0$ si $latex n$ es negativo o si $latex p$ es negativo. Del mismo modo, $latex f(n,p) = 1$ si $latex n = 0$. De lo contrario, es igual a la suma de $latex f(n,p-1)$, $latex f(n-2^p,p-1)$ y $latex f(n-2^{p+1},p-1)$, que corresponden a poner 0, 1, o 2 veces la potencia $latex 2^p$.&lt;/p>
&lt;h1>Subtarea 1&lt;/h1>&lt;p>Aplicando directamente el análisis anterior, la subtarea 1 queda resuelta.&lt;/p>
&lt;h1>Subtarea 2&lt;/h1>&lt;p>Varios de estos estados se repiten, así que convendría memorizarlos. Utilizando un contenedor como &lt;code>std::map&lt;/code>, la solución se vuelve lo suficientemente rápida para resolver esta subtarea.&lt;/p>
&lt;h1>Subtarea 3&lt;/h1>&lt;p>Podemos determinar en algunos casos rápidamente si la función se evaluará a 0. Sabemos que $latex \sum_{i=0}^{k} 2^i = 2^{k+1} - 1$. Entonces, el número más grande que podemos escribir sólo usando potencias de 2 menores o iguales a $latex p$ a lo más dos veces es $latex 2\sum_{i=0}^{p} 2^p = 2 (2^{p+1} - 1) = 2^{p+2} - 2$. Por lo tanto, $latex f(n,p) = 0$ si $latex n &amp;gt; 2^{p+2} - 2$.&lt;/p>
&lt;p>Esa optimización por sí misma (sin memorización), resuelve la subtarea 3.&lt;/p>
&lt;h1>Subtarea 4&lt;/h1>&lt;p>Combinando las ideas de las dos subtareas anteriores, el algoritmo es lo suficientemente rápido para resolver todos los casos. Específicamente, la cantidad de estados que no podemos determinar como no viables instantáneamente es proporcional a $latex \log x$, y cada estado lo podemos evaluar en tiempo $latex O(\log \log x)$ por nuestro &lt;code>std::map&lt;/code>, dándonos una complejidad total de $latex O(\log x \log \log x)$. Esta cota puede quedar más clara después de describir la tercera solución.&lt;/p>
&lt;p>El siguiente código implementa esta solución:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702849.js">&lt;/script>
&lt;h2>Análisis 3&lt;span class="hx-absolute -hx-mt-20" id="análisis-3">&lt;/span>
&lt;a href="#an%c3%a1lisis-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Esta solución es equivalente a la anterior, pero no precisa de un &lt;code>std::map&lt;/code>.&lt;/p>
&lt;p>Consideremos la función $latex n(k)$, que definimos como el número que obtenemos tomando los bits $latex 0..k$ de $latex x$. En otras palabras, si $latex x = \sum_{i=0}^{\infty} x_i 2^i$ donde $latex x_i$ es el $latex i$-ésimo bit de $latex x$, $latex n(k) = \sum_{i=0}^k x_i 2^i$. Ahora, definimos la función $latex g(i,r)$, que cuenta de cuántas maneras se puede escribir el número $latex n(i) + r2^i$, utilizando potencias de 2 menores o iguales a $latex i$ a lo más 2 veces. La respuesta, por lo tanto, se obtendría evaluando $latex g(63,0)$.&lt;/p>
&lt;p>Ahora, sabemos que $latex g(i,r) = 1$ si $latex i &amp;lt; 0$ y $latex r = 0$, porque podemos escribir sólo de una manera 0. Recordando que $latex x_i$ es el $latex i$-ésimo bit de $latex x$, podemos decir que $latex g(i,r)$ cuenta la cantidad de formas que se puede escribir el número $latex (r+x_i)2^i + n(i-1)$. De ahora en adelante, por conveniencia, $latex t = r + x_i$.&lt;/p>
&lt;p>Usando esto, podemos definir $latex g(i,r)$ recursivamente:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \text{ y } r = 0 \\ \sum_{k=0}^{min(t,2)}g(i-1,2(t-k)) &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>En otras palabras, si tenemos que poner $latex t$ veces la potencia $latex i$, podemos elegir ponerla hasta $latex min(t,2)$ veces, y contar las maneras de escribir el resto usando potencias de 2 menores a $latex p$. Pero como dejamos $latex t-k$ veces la potencia $latex i$ sin poner, es igual a poner $latex 2(t-k)$ veces la potencia $latex i-1$.&lt;/p>
&lt;p>La siguiente observación es que si $latex t$ es mayor a 3, $latex g(i,r) = 0$ porque $latex 2\sum_{k=0}^{i} 2^k &amp;lt; 4 \times 2^{i}$. Entonces, sólo nos interesan los casos en los que $latex 0 \le t \le 3$. En total, sólo hay 4 valores posibles para $latex t$ en los que $latex g(i,r)$ no es 0: 0, 1, 2, y 3. Enumerémoslos:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,4) + g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,6) + g(i-1,4) + g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Pero $latex g(i,r) = 0$ si $latex t &amp;gt; 3$, y como $latex t \ge r$, nos quedamos con:&lt;/p>
&lt;p>$latex g(i,r) = \begin{cases} g(i-1,0) &amp;amp; \text{si } t = 0 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 1 \\ g(i-1,2) + g(i-1,0) &amp;amp; \text{si } t = 2 \\ g(i-1,2) &amp;amp; \text{si } t = 3 \end{cases}$&lt;/p>
&lt;p>Tomando en cuenta que $latex r$ sólo puede ser 0 o 2, y $latex x_i$ sólo 0 o 1:&lt;/p>
&lt;p>$latex (g(i,0),g(i,2)) = \begin{cases} (g(i-1,0),g(i-1,2)+g(i-1,0)) &amp;amp; \text{si } x_i = 0 \\ (g(i-1,2)+g(i-1,0),g(i-1,2)) &amp;amp; \text{si } x_i = 1 \end{cases}$&lt;/p>
&lt;p>El siguiente código implementa esta solución, que corre en tiempo $latex O(\log n)$ y espacio constante:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702863.js">&lt;/script>
&lt;p>Como podemos observar, esta solución considera los mismos estados que la anterior, sólo que aquí evitamos computarlos, mientras que la otra los descarta inmediatamente.&lt;/p>
&lt;h2>Consideraciones&lt;span class="hx-absolute -hx-mt-20" id="consideraciones">&lt;/span>
&lt;a href="#consideraciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Varios competidores no consideraron que $latex x$ no cabe en un entero signado de 64 bits. Si bien la &lt;em>respuesta&lt;/em> cabe en uno, en los límites del problema se especifica que $latex x &amp;lt; 2^{64}$.&lt;/p>
&lt;h2>Análisis adicional:&lt;span class="hx-absolute -hx-mt-20" id="análisis-adicional">&lt;/span>
&lt;a href="#an%c3%a1lisis-adicional" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>&lt;a href="https://omegaup.com/profile/DiegoRoque" target="_blank" rel="noopener">Diego Roque&lt;/a> escribió una solución distinta, la cual detallaré a continuación.&lt;/p>
&lt;p>Consideremos la función $latex f(x)$ como la define el problema: la cantidad de maneras de escribir $latex x$ como una suma de potencias no negativas de 2 sin usar cada una más de 2 veces.&lt;/p>
&lt;p>Enfoquémonos en la paridad de $latex x$ (es decir, el último bit de $latex x$). Si $latex x$ es impar, necesariamente tenemos que poner una vez la potencia $latex 2^0$, porque las otras dos opciones: ponerla 0 veces o ponerla 2 veces cambiarían la paridad de $latex x$. Por lo tanto, $latex f(x) = f(\frac{x-1}{2})$ si $latex x$ es impar. En cambio, si es par, podemos elegir poner la potencia $latex 2^0$ 0 o 2 veces, lo que nos deja con $latex f(x) = f(\frac{x}{2}) + f(\frac{x}{2}-1)$. Sólo falta definir los casos base: $latex f(0) = f(1) = 1$.&lt;/p>
&lt;p>Aquí está su código que implementa esta solución, que corre en tiempo $latex O(\log^2 x \log \log^2 x):$&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6702891.js">&lt;/script></description></item><item><title>Solución a "Comesolo"</title><link>https://blog.omegaup.com/posts/solucion-a-comesolo/</link><pubDate>Sat, 14 Sep 2013 05:21:32 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-comesolo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/comesolo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://lhchavez.com" target="_blank" rel="noopener">lhchavez&lt;/a> &lt;strong>Fuente&lt;/strong>: Félix&lt;/p>
&lt;p>Este problema es especial porque es el primero en omegaUp de solo salida! Usualmente lo que debes esperar cuando te enfrentes con uno de esos problemas es que sea un problema NP que no tiene una solución rápida, y usualmente te pedirán que te aproximes lo más posible a la solución óptima. Esto significa que te vas a tener que valer de técnicas ad-hoc y heurísticas para sacar puntos.&lt;/p>
&lt;p>La solución del problema es bastante sencilla de explicar: haz una búsqueda en profundidad intentando todos los posibles movimientos por fuerza bruta hasta que te salga una solución aceptable e imprímela. El problema es que esta estrategia es $latex O(n!)$, y como $latex n$ puede valer hasta 30x30, puedes esperar que el programa corra varios milenios antes de encontrar la solución óptima. Hay tres trucos (en orden de importancia) para obtener una solución decente en un tiempo razonable:&lt;/p>
&lt;ul>
&lt;li>No repetir estados.&lt;/li>
&lt;li>No &amp;ldquo;clavarse&amp;rdquo; con soluciones que parece que son muy buenas, pero en realidad llevan a callejones sin salida.&lt;/li>
&lt;li>Encontrar una manera de darle prioridad a los estados que tengan más probabilidad de llegar a una solución buena.&lt;/li>
&lt;/ul>
&lt;p>La estrategia que yo personalmente seguí fue que cada que encontraba un nuevo estado, obtenía su &lt;a href="http://es.wikipedia.org/wiki/Funci%C3%B3n_hash" target="_blank" rel="noopener">hash&lt;/a> (que resultaba en un entero de 64 bits) y verificaba si no lo había visitado usando una tabla de hash&lt;a href="#note" >*&lt;/a>. Si no la había visitado, encontraba todos los estados vecinos (todos los tableros que resultaban de hacer un movimiento válido) y los guardaba en una fila de acuerdo a la cantidad de puntos (entre más puntos, más adelante en la fila). Luego, elegía aleatoriamente un estado de la fila dándole prioridad a los que estaban más adelante (pues son los que tienen mayor probabilidad de llegar a una buena solución), lo cual también me evitaba seguir un único camino donde me podría atorar. Repetí eso hasta que se me terminó la memoria de la computadora e imprimí la mejor solución.&lt;/p>
&lt;p>A continuación, el pseudocódigo de la solución:&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Estado&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_init&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Estado&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">puntos&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tablero&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">padre&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">p&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Puedes usar cualquier algoritmo que genere un entero de 64 bits
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># a partir de tablero y puntos. Este es el más sencillo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">puntos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">7&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">|&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hash&lt;/span> &lt;span class="o">&amp;gt;&amp;gt;&lt;/span> &lt;span class="mi">53&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">hash&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">def&lt;/span> &lt;span class="n">siguientes&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todas las celdas (i, j) del tablero...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si la celda tiene una pieza...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Para todos los vecinos contiguos (i+k, j+l)...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Asegúrate que se haya movido \_algo\_.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que pueda brincar dentro del tablero.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="n">or&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="nl">N&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que haya brincado una pieza.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Y que el lugar a donde brinca esté desocupado.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">hijo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Estado&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Aumenta la puntuación del hijo
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Borra la ficha original y la &amp;#34;comida&amp;#34;.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">\&lt;/span>\
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega la ficha en su posición final.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tablero&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">True&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrégala a la cola correspondiente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hijo&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">def&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Número aleatorio entre 0 y 1.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">float&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">RAND&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_MAX&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># El índice de la última cola que estuvo llena.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La cola que se está considerando.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Elige la cola con mayores puntos que no esté vacía como
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># primera opción.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">N&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># La primer cola tiene probabilidad de 31% de ser elegida.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># La segunda cola tiene probabilidad de 21%, la tercera 14%,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># la cuarta 10% y así sucesivamente.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">not&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">vacio&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">r&lt;/span> &lt;span class="err">\&lt;/span>&lt;span class="o">*=&lt;/span> &lt;span class="mf">1.45&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">r&lt;/span> &lt;span class="o">&amp;gt;=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="n">and&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">ultimolleno&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">Null&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">lastfull&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">queue&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="n">colas&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">hashtable&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">lee&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">estado&lt;/span> &lt;span class="n">original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">colas&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Estado&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">estado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_original&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="n">no&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_se&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_haya&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_terminado&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_la&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_memoria&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Estado&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">elige&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_estado&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Si ya no hay más estados por visitar,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="cp"># encontramos la respuesta óptima en algún punto.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nl">Null&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">break&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Actualiza |mejor| si hay una respuesta mejor.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">mejor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">puntos&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nl">puntos&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Repetir estados es malo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="nl">_visitados&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="k">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">estados&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="n">_visitados&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">hash&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cp"># Agrega todos los vecinos.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">siguiente&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">colas&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">\#&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="n">partir&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">este&lt;/span> &lt;span class="n">punto&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">|&lt;/span>&lt;span class="n">mejor&lt;/span>&lt;span class="o">|&lt;/span> &lt;span class="n">contiene&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">mejor&lt;/span> &lt;span class="n">solución&lt;/span>&lt;span class="p">.&lt;/span> &lt;span class="n">Podemos&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># saber qué movimiento se hizo para llegar a él comparando las
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># diferencias entre el tablero de |mejor.padre| y |mejor|. Ya solo es
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp"># cuestión de imprimir el resultado y listo.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">Aquí&lt;/span> &lt;span class="n">mucha&lt;/span> &lt;span class="n">gente&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">va&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">quejar&lt;/span> &lt;span class="n">porque&lt;/span> &lt;span class="n">solo&lt;/span> &lt;span class="n">guardar&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">abre&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">puerta&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">haya&lt;/span> &lt;span class="n">dos&lt;/span> &lt;span class="n">estados&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">puede&lt;/span> &lt;span class="n">tener&lt;/span> &lt;span class="n">hasta&lt;/span> &lt;span class="mi">900&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="n">que&lt;/span> &lt;span class="n">tengan&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="n">mismo&lt;/span> &lt;span class="n">hash&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="mi">64&lt;/span> &lt;span class="n">bits&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">por&lt;/span> &lt;span class="n">el&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">principio&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">palomar&lt;/span>&lt;span class="p">](&lt;/span>&lt;span class="nl">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="c1">//es.wikipedia.org/wiki/Principio_del_palomar)) y esté considerando que ya se visitó un estado que en realidad es nuevo. Si haces las cuentas, la probabilidad de colisión es negligible: la cantidad de estados que podía visitar en mi computadora (27 millones) es significativamente más pequeña que el número de estados necesarios para que la probabilidad de colisión sea de 1% ($latex \\approx 10^{135}$, por la [paradoja del cumpleaños](http://es.wikipedia.org/wiki/Paradoja_del_cumplea%C3%B1os)).
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div></description></item><item><title>Solución a "Colección"</title><link>https://blog.omegaup.com/posts/solucion-a-coleccion/</link><pubDate>Sat, 14 Sep 2013 05:16:07 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-coleccion/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/coleccion" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> Alexis Cervantes / César Cepeda &lt;strong>Fuente:&lt;/strong> Alexis Cervantes / César Cepeda&lt;/p>
&lt;p>&lt;strong>_Estructura de la solución: _&lt;/strong>¿Qué nos están pidiendo? El problema nos esta pidiendo que encontremos un subconjunto de las tarjetas tal que la suma de todos los puntajes de las tarjetas de ese subconjunto sea la maxima posible, y la suma de sus precios sea menor o igual al dinero con el que cuentas.  En otras palabras lo que se esta buscando es que:&lt;/p>
&lt;p>la suma &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_51.webm" type="video/mp4">
&lt;/video>
sea maxima siempre y cuando &lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_52.webm" type="video/mp4">
&lt;/video>
&lt;/p>
&lt;p>donde &lt;em>Xi&lt;/em>** = &lt;strong>{1 si se compró la tarjeta _i&lt;/strong>, **_y 0 si no se compró}&lt;/p>
&lt;p>**_Modelo del espacio de búsqueda como árbol: _**Al final de cuentas, incluso el nombre lo indica, este problema se puede reducir a asignarle a cada tarjeta un 0 ó un 1 dependiendo de si la vamos a comprar o no, por lo que una forma de modelar el espacio de búsqueda sería formar un número binario de &lt;strong>&lt;em>N&lt;/em>&lt;/strong> dígitosy crear todos los valores posibles para dicho número.&lt;/p>
&lt;p>Para formar todos los números, podemos pensar que en el nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> del árbol vamos a decidir si compramos la tarjeta &lt;strong>&lt;em>j&lt;/em>&lt;/strong>, por lo tanto todos los nodos del nivel &lt;strong>&lt;em>j&lt;/em>&lt;/strong> tendrán dos hijos, uno de ellos indicando que si compramos la tarjeta y el otro indicando que no la compramos.  El árbol de búsqueda queda como se muestra a continuación.&lt;/p>
&lt;video autoplay muted loop>
&lt;source src="http://www.olimpiadadeinformatica.org.mx/archivos/apuntes/imagenes/Eje_Bu_53.webm" type="video/mp4">
&lt;/video>
&lt;p>_**Técnica de búsquda a utilizar: **_Dado que tenemos que entregar como resultado el camino con el mayor puntaje de todos , es preciso que revisemos el 100% de los caminos.  &lt;/p>
&lt;p>Una forma de resolver el problema es utilizar búsqued en profundidad, sin embargo el espacio de búsqueda es un árbol binario con &lt;strong>&lt;em>N&lt;/em>&lt;/strong> niveles por tanto de _**2N **_estados.  Para nuestro problema &lt;strong>&lt;em>N=500&lt;/em>&lt;/strong> por lo que el espacio de búsqueda es indescriptiblemente grande, aunque claro que se pueden podar las ramas en las que el precio ya superó a la cantidad de dinero que tenemos, el aplicar la técnica de búsqueda en profundidad en este problema dificilmente alcanzaría para una **_N _**mayor que 24 ó 25.&lt;/p>
&lt;p>Necesitamos por tanto encontrar una poda mucho más agresiva.&lt;/p>
&lt;p>Anteriormente, en el ejemplo de los Tanques, utilizamos la búsqueda en profundidad para encontrar un camino mínimo, por lo tanto, debido a que cada nivel que descendemos el coste aumenta, se podía aplicar la poda de que si obteniamos algún mínimo se podían cortar todas las ramas cuyo coste fuera mayor o igual que el mínimo actual.  Sin embargo al querer encontrar un máximo, esto no es posible, ya que el coste por rama siempre aumenta y lo que queremos es es encontrar el máximo, así que no sabemos si el camino nos va a llevar a algo mejor a menos que lo recorramos todo!&lt;/p>
&lt;p>Pero que pasaría si tuvieramos una función tal que nos permitiera saber cual es el máximo posible que podemos obtener por una cierta rama?  En ese caso, podríamos cortar cualquier rama si supieramos que por ese camino es imposible lograr algo mejor que lo que ya tenemos.&lt;/p>
&lt;p>Esta técnica se conoce como de &amp;ldquo;acotamiento y poda&amp;rdquo;.  La idea es buscar una función que para cada estado del espacio de búsqueda nos de cotas del máximo posible al que se puede llegar por dicho camino y de mínimo seguro que podemos obtener también por ese camino.&lt;/p>
&lt;p>Esta técnica es increíblemente poderosa y conviene que mediten un momento sobre la misma.  Vale la pena hacer notar que no siempre es sencillo encontrar la función de acotamiento correcta.  Ya que una función que de una cota muy alta no nos sirve de mucho, ya que las podas serian pocas, pero una cota incorrecta nos puede hacer que entreguemos resultados incorrectos.  Por lo tanto al utilizar esta técnica, siempre debemos buscar la función que acote lo más posible pero estando siempre 100% seguros de que el resultado que obtuvimos es efectivamente mayor o igual al máximo posible.&lt;/p>
&lt;p>Para este problema voy a definir las dos funciones de acotamiento, llamemos &lt;strong>&lt;em>a(c)&lt;/em>&lt;/strong> a la función que nos da el máximo posible que se puede obtener estando en el nodo **&lt;em>c&lt;/em>**y &lt;em>&lt;strong>b(c)&lt;/strong>&lt;/em> a la función que nos da el mínimo asegurado que tenemos también al estar en el nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  El demostrar que ambas funciones son válidas queda como tarea para el alumno.&lt;/p>
&lt;p>Lo primero que tenemos que hacer es ordenar las tarjetas de acuerdo a la relación &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong>, es decir, cuantos puntos nos dan por cada peso gastado.  Como queremos obtener el máximo puntaje por nuestro dinero obviamente son mejores las tarjetas que nos dan muchos puntos por peso comparadas con las tarjetas que nos dan pocos puntos por cada peso gastado. &lt;em>&lt;strong>OJO: esto no implica que la solución correcta deba tomar siempre las mejores tarjetas, únicamente quiere decir que comparadas individualmente, para nuestro objetivo son mejores las tarjetas que dan más puntos por peso.&lt;/strong>&lt;/em>&lt;/p>
&lt;p>Una vez que tengamos todas las tarjetas ordenadas en base a este criterio, iremos decidiendo si las tomamos o no, en ese respectivo orden.  Para cada nodo, nuestras funciones de acotamiento estarán definidas de la siguiente manera:&lt;/p>
&lt;p>&lt;em>&lt;strong>b(c):&lt;/strong>&lt;/em>  Para calcular la cota mínima asegurada del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong> vamos tomando las tarjetas que aún no hemos utilizado según el ordenamiento mientras aún tengamos dinero, en el momento en el que no tengamos más dinero para comprar ahi nos detenemos.  Ese es el mínimo que seguro podemos obtener.&lt;/p>
&lt;p>_**a(c):  **_Para calcular la cota alta, hacemos el mismo procedimiento que en &lt;strong>&lt;em>b&lt;/em>&lt;/strong> (o mejor tomamos el resultado de &lt;strong>&lt;em>b&lt;/em>&lt;/strong> para no recalcular) y con la primera tarjeta que no pudimos tomamos su relacion &lt;strong>&lt;em>U/P&lt;/em>&lt;/strong> y la multiplicamos por el dinero que aún tenemos disponible y lo sumamos a &lt;strong>&lt;em>b&lt;/em>&lt;/strong>.  Así obtenemos el máximo posible que se puede lograr en el subárbol del nodo &lt;strong>&lt;em>c&lt;/em>&lt;/strong>.  La operación que efectuamos al final fue la de utilizar el dinero que aún tenemos disponible para comprar un &amp;ldquo;pedazo&amp;rdquo; de la mejor tarjeta aún queda, obviamente esto no es posible ya que no podemos comprar pedazos de tarjeta, sin embargo nos sirve para calcular el máximo posible.  &lt;/p>
&lt;p>Demostrar que &lt;strong>&lt;em>b&lt;/em>&lt;/strong> es válida es trivial, sin embargo queda para el lector demostrar que &lt;strong>&lt;em>a&lt;/em>&lt;/strong> es una cota que siempre dará un número mayor o igual al máximo posible que se puede obtener por ese camino.&lt;/p>
&lt;p>Obviamente una vez que tengamos las funciones de acotamiento, podemos hacer nuestra búsqueda almacenando cual es el mejor mínimo asegurado que hemos obtenido hasta el momento y eliminando todas las ramas cuyo máximo asegurado es menor o igual que éste.&lt;/p>
&lt;p>**_Detalles de implementación: _**Para la implementación queda un último detalle que resolver, y este es como vamos a buscar?  Como casi siempre tenemos dos opciones, la primera es la de la búsqueda en profundidad, para la cual se implementa una rutina recursiva y no se requiere de mantener arreglos de memoria externos.  Y la segunda es una búsqueda por amplitud, para la cual requieres de una cola que te permita almacenar los estados proximos a ser evaluados.&lt;/p>
&lt;p>Si optamos por la búsqueda en profundidad, hay un detalle de implementación muy sútil que puede ser de gran ayuda.  Supongan que modelamos el árbol de búsqueda como el que se muestra en la figura de arriba.  Y supongan que nuestro algoritmo de búsqueda revisa primero la rama izquierda, de ser asi, la cota mínima asegurada y la cota máxima del hijo de la izquierda es exactamente igual a la de su padre, por lo que bajariamos un nivel en la búsqueda sin obtener ninguna información nueva, si, en cambio, revisamos primero el hijo de la derecha, entonces estaríamos obteniendo nuevas cotas con información probablemente últil.&lt;/p>
&lt;p>Si se opta por la búsqueda en amplitud, se tiene una ventaja, y esta es que la cola se puede sustituir por un monticulo de modo que se priorice la búsqueda según el nodo que tiene el mejor mínimo asegurado.  Sin embargo aunque esto podría efectivamente reducir la búsqueda bastante no estamos seguros del tamaño que puede llegar a tener la cola y requeririamos que al llenarse la cola el programa pudiera cambiar a una técnica de búsqueda en profundidad, lo cual haría el código más enredado.  Sin embargo si se desea llegar a límites aún mas grandes, esta sería la opción a seguir.  &lt;/p>
&lt;p>&lt;strong>&lt;em>Implementación:&lt;/em>&lt;/strong>  &lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558998.js">&lt;/script></description></item><item><title>Solución a "Ubongo 3D"</title><link>https://blog.omegaup.com/posts/solucion-a-ubongo-3d/</link><pubDate>Sat, 14 Sep 2013 05:04:59 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-ubongo-3d/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/ubongo-3d" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> Miguel Covarrubias &lt;strong>Fuente:&lt;/strong> Miguel Covarrubias&lt;/p>
&lt;p>La solución pone piezas de manera recursiva mientras quepan en el tablero y no se empalmen.&lt;/p>
&lt;div class="hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code">
&lt;div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">P&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">regresa&lt;/span> &lt;span class="err">“&lt;/span>&lt;span class="n">Si&lt;/span>&lt;span class="err">”&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">rotación&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">casilla&lt;/span> &lt;span class="n">g&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">para&lt;/span> &lt;span class="n">cada&lt;/span> &lt;span class="n">cubo&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">si&lt;/span> &lt;span class="n">al&lt;/span> &lt;span class="n">poner&lt;/span> &lt;span class="n">c&lt;/span> &lt;span class="n">sobre&lt;/span> &lt;span class="n">g&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">queda&lt;/span> &lt;span class="n">dentro&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">primeros&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="n">niveles&lt;/span> &lt;span class="n">del&lt;/span> &lt;span class="n">tablero&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="n">se&lt;/span> &lt;span class="n">empalma&lt;/span> &lt;span class="n">con&lt;/span> &lt;span class="n">otra&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">ya&lt;/span> &lt;span class="n">puesta&lt;/span> &lt;span class="n">entonces&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">marca&lt;/span> &lt;span class="n">las&lt;/span> &lt;span class="n">posiciones&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span> &lt;span class="n">como&lt;/span> &lt;span class="n">ocupados&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">resuelve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pieza&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">desmarca&lt;/span> &lt;span class="n">los&lt;/span> &lt;span class="n">cubos&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="n">la&lt;/span> &lt;span class="n">pieza&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>&lt;div class="hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0">
&lt;button
class="hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50"
title="Copiar código"
>
&lt;div class="copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;div class="success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4">&lt;/div>
&lt;/button>
&lt;/div>
&lt;/div>
&lt;p>Para rotar una pieza se puede rotar por $latex 0^o$, $latex 90^o$, $latex 180^o$ o $latex 270^o$ alrededor de cada eje. El número de operaciones es aproximadamente (número de rotaciones * número de casillas del tablero * número de cubos de una pieza)$latex ^3 \le (24 * 7 * 5)^3 &amp;lt; 600,000,000$. En los casos de prueba y en el juego todas las soluciones tocan la base del tablero, si no fuera así, solo hay que duplicar el 7 a 14. Para checar si una pieza se puede poner en cierta posición se pueden usar mascaras de bits para los niveles del tablero y para las posiciones ocupadas. Para poner la última pieza se puede comparar todas las rotaciones de los cubos no ocupados contra la última pieza y la complejidad cubica de la solución se reduce a cuadrática.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6558928.js">&lt;/script></description></item><item><title>Solución a "Bloqueo"</title><link>https://blog.omegaup.com/posts/solucion-a-bloqueo/</link><pubDate>Tue, 10 Sep 2013 19:35:59 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-bloqueo/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/problem/bloqueo" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 8&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.cimat.mx/~omar" target="_blank" rel="noopener">Khayyam&lt;/a> &lt;strong>Fuente&lt;/strong>: Khayyam&lt;/p>
&lt;p>La primera observación que hay que hacer es que si todas las carreteras son bidireccionales y entre cada par de ciudades existe exactamente un camino que las conecta (usando una o mas carreteras) entonces la representación gráfica del problema es un árbol: los nodos representan las ciudades y las aristas representan las carreteras. La siguiente figura, muestra el árbol que representa el caso de prueba dado como ejemplo. Los nodos rojos representan las ciudades ocupadas, el esfuerzo necesario para destruir cada carretera se muestra junto a la arista correspondiente. Entonces queremos eliminar un subconjunto de aristas de peso total mínimo de tal forma que los nodos rojos queden separados.&lt;/p>
&lt;p>Caso de ejemplo&lt;/p>
&lt;p>Solución&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example_solution.png" alt="" loading="lazy" />&lt;/p>
&lt;p>En problemas relacionados con árboles, es muy natural tratar de dividir el problema en problemas más pequeños que están dados por los sub-árboles del árbol original. Esto además sugiere usar recursión: &amp;ldquo;para resolver un árbol, primero resolvemos recursivamente sus sub-árboles y luego combinamos las sub-soluciones&amp;rdquo;.&lt;/p>
&lt;p>Comencemos con los casos sencillos. Si hay solamente un nodo (el árbol tiene altura 0), entonces no habrá aristas y el esfuerzo total necesario es cero.&lt;/p>
&lt;p>Consideremos ahora un árbol de altura 1 como el de la siguiente figura. Como la raiz no es roja, basta con eliminar una de las dos aristas: elegimos la que requiera menos esfuerzo.&lt;/p>
&lt;p>Caso sencillo: altura 1&lt;/p>
&lt;p>Solución (suponemos que la arista izquierda requiere menos esfuerzo)&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple0.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/simple1.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Si la raiz fuera roja, entonces tendríamos que eliminar ambas aristas. Con lo anterior nos damos cuenta de que hay dos casos que debemos considerar:&lt;/p>
&lt;ol>
&lt;li>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/li>
&lt;li>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos: la solución óptima es dejar conectado el nodo rojo asociado a la arista mas costosa.&lt;/li>
&lt;/ol>
&lt;p>Lo anterior se ilustra en la siguiente figura (aquí suponemos que la arista de la derecha es la mas costosa de todas):&lt;/p>
&lt;p>Si la raiz es roja, entonces &lt;strong>debemos&lt;/strong> eliminar &lt;strong>todas&lt;/strong> las aristas que la conectan con nodos rojos&lt;/p>
&lt;p>Si la raiz no es roja, entonces no es necesario desconectar la raíz de todos los nodos rojos&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Ahora que tenemos la solución para los casos pequeños, veamos si podemos usar estas soluciones para construir la solución del problema general, como en la siguiente figura.&lt;/p>
&lt;p>Si la raiz es roja y el nodo blanco está conectado&lt;br>
a algun descendiente rojo, la solución ya no es correcta&lt;/p>
&lt;p>Aún si la raiz es blanca, no podemos dejar conectado el nodo blanco&lt;br>
ya que si está conectado con un descendiente rojo, la solución sería incorrecta&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/whiteRootAllRed_cloud.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Supongamos que ya tenemos la solución para todos los hijos directos de la raíz, es decir, que ya cortamos de manera óptima las aristas de todos los subárboles, de modo que ningún par de nodos rojos se conectan en el sub-árbol. Usando sólo esta información, ¿podemos construir la solución del problema general?. Desafortunadamente, esto no es suficiente: nos gustaría dejar conectados a los hijos blancos, pero si existe un nodo rojo debajo de ellos, entonces tendríamos que desconectarlo también. Lo que necesitamos saber es precisamente si un hijo blanco está conectado con uno de sus descendientes rojos, de ser así diremos que el nodo blanco es &amp;ldquo;peligroso&amp;rdquo;. Si el nodo blanco está desconectado de todos sus descendientes rojos, entonces diremos que es &amp;ldquo;seguro&amp;rdquo;. Entonces tenemos tres tipos de nodos: ocupados, peligrosos y seguros, que representamos como nodos rojos, amarillos y verdes, respectivamente.Con este nuevo concepto, vemos que tenemos dos tipos de soluciones distintas para una raíz blanca: tenemos soluciones peligrosas y soluciones seguras. Es fácil ver que no existen &amp;ldquo;hojas peligrosas&amp;rdquo;, ya que las hojas están ocupadas (rojas) o son seguras (verdes).&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/redRootOneGreen.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/yellowRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/greenRootAllRed.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Reformulemos nuestra solución con este concepto. Si la raíz es roja, entonces debemos desconectarla de todos sus hijos rojos y de todos sus hijos peligrosos. Esto significa que para cada hijo blanco tenemos dos opciones:&lt;/p>
&lt;ul>
&lt;li>Hacer que el hijo sea seguro (verde) y no cortar la arista que lo une con la raíz (puede ser costoso hacerlo seguro, pero con eso nos ahorramos el costo de separarlo de la raíz)&lt;/li>
&lt;li>Hacer que el hijo sea peligroso (amarillo) y cortar la arista que lo une con la raíz (puede ser barato dejarlo inseguro, pero pagamos al separarlo de la raíz)&lt;/li>
&lt;/ul>
&lt;p>Lo anterior resuelve el caso en que la raíz es roja.&lt;/p>
&lt;p>Ahora, si la raíz no es roja, debemos calcular dos soluciones: la solución segura (dejar la raíz verde) y la solución peligrosa (dejar la raíz amarilla). Notemos que la solución segura es exactamente igual al caso anterior. Por otro lado, para la solución peligrosa, debemos dejar la raíz conectada a exactamente un hijo que sea rojo o peligroso. Para elegir cuál de todos los hijos rojos o peligrosos dejaremos conectado, basta iterar sobre todos los hijos y elegir la mejor opción. El código queda como sigue:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559253.js">&lt;/script></description></item><item><title>Solución a "La Venganza de Silvio"</title><link>https://blog.omegaup.com/posts/solucion-a-la-venganza-de-silvio/</link><pubDate>Thu, 08 Aug 2013 02:02:51 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-la-venganza-de-silvio/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/VenganzaDeSilvio" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Freddy&lt;/p>
&lt;p>Este problema es bastante sencillo de entender, la dificultad radica en que exponenciar un número de la manera obvia no es lo suficientemente rápido para obtener todos los puntos disponibles.&lt;/p>
&lt;h2>Subtarea 1&lt;span class="hx-absolute -hx-mt-20" id="subtarea-1">&lt;/span>
&lt;a href="#subtarea-1" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para obtener el primer grupo de puntos, sólo basta calcular $latex N^M$ multiplicando a $latex N$ por sí mismo $latex M$ veces, teniendo cuidado de que no haya overflow.&lt;/p>
&lt;h2>Subtarea 2&lt;span class="hx-absolute -hx-mt-20" id="subtarea-2">&lt;/span>
&lt;a href="#subtarea-2" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para la segunda subtarea, se necesita algo más rápido, para lo que se puede usar &lt;a href="http://es.wikipedia.org/wiki/Exponenciaci%c3%b3n_binaria" target="_blank" rel="noopener">exponenciación binaria&lt;/a>.&lt;/p>
&lt;p>Sabemos que $latex x^0 = 1$, que $latex (x^n)^2 = x^{2n}$, y que $latex x * x^{n-1} = x^n$ para toda $latex x$ y $latex n$, por lo que podemos escribir la siguiente relación:&lt;/p>
&lt;p>$latex \text{potencia}(N,M) = \begin{cases} 1 &amp;amp; \text{si } M = 0 \\ (potencia(N,M/2))^2 &amp;amp; \text{si } M \text{ es par} \\ N * (potencia(N,(M-1)/2))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;p>Aplicando esta definición directamente, la segunda subtarea queda resuelta. Esto es porque el algoritmo descrito anteriormente tiene complejidad $latex O(log M)$, ya que en cada paso $latex M$ se reduce a la mitad.&lt;/p>
&lt;h2>Subtarea 3&lt;span class="hx-absolute -hx-mt-20" id="subtarea-3">&lt;/span>
&lt;a href="#subtarea-3" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El algoritmo anterior es lo suficientemente rápido para resolver esta subtarea, pero el rango de los enteros de la máquina no es lo suficientemente grande para guardar a $latex M$. Para ello requerimos una observación adicional. Dividir entre $latex 2$ en base $latex 2$ ignorando el residuo es lo mismo que recorrer todos los dígitos una vez a la derecha descartando el bit menos significativo, y, además, se puede saber si un número es par o no con sólo ver el bit menos significativo del mismo.&lt;/p>
&lt;p>Podemos aprovechar esta observación guardando $latex M$ como una cadena de bits y modficando un poco la función descrita anteriormente. Si $latex A$ es el arreglo donde guardamos los bits de $latex M$, está $latex 0$-indexado, tiene $latex k$ bits, y los bits están ordenados del más significativo al menos (como viene en la entrada del problema), la respuesta se encuentra evaluando $latex potencia2(N,k-1)$, donde $latex potencia2$ es:&lt;/p>
&lt;p>$latex \text{potencia2}(N,i) = \begin{cases} 1 &amp;amp; \text{si } i &amp;lt; 0 \\ (potencia2(N,i-1))^2 &amp;amp; \text{si } A[i] = 0 \\ N * (potencia2(N,i-1))^2 &amp;amp; \text{de lo contrario} \end{cases}$&lt;/p>
&lt;h2>Subtarea 4&lt;span class="hx-absolute -hx-mt-20" id="subtarea-4">&lt;/span>
&lt;a href="#subtarea-4" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>El problema con el algoritmo anterior es que ocupa demasiada memoria para los casos que contiene esta subtarea. Para corregirlo, podemos analizar la función anterior.&lt;/p>
&lt;p>Por conveniencia, definamos $latex f(i)$ como el número que se obtiene tomando los elementos $latex [0..i]$ del arreglo $latex A$, y $latex f(-1) = 0$. Recordando que multiplicar por $latex 2$ en base $latex 2$ es lo mismo que recorrer todos los dígitos a la izquierda, $latex f(i) = 2f(i-1) + A[i]$.&lt;/p>
&lt;p>Ahora, es simple notar que $latex potencia2(N,i) = N^{f(i)}$, que podemos reescribir como $latex potencia2(N,i) = N^{2f(i-1) + A[i]} = (N^{f(i-1)})^2 N^{A[i]}$.&lt;/p>
&lt;p>Por lo tanto, podemos escribir un ciclo en vez de utilizar recursión.&lt;/p>
&lt;p>Este algoritmo ocupa espacio constante, por lo que resuelve la subtarea 4.&lt;/p>
&lt;p>Aquí está la implementación del algoritmo anterior:&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559240.js">&lt;/script>
&lt;h2>Consideraciones&lt;span class="hx-absolute -hx-mt-20" id="consideraciones">&lt;/span>
&lt;a href="#consideraciones" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Hay que tener cuidado de que no haya overflow. Cuando un entero de $latex k$ bits se eleva al cuadrado, puede ahora tener a lo más $latex 2k$ bits. Como $latex m$ puede tener hasta $latex 31$ bits, es necesario usar enteros de 64 bits durante todos los cálculos.&lt;/p>
&lt;p>También, varios competidores no consideraron el caso en el que se pide calcular $latex N^0 \pmod 1$.&lt;/p></description></item><item><title>Solución a Las Cartas del Dr. Lira</title><link>https://blog.omegaup.com/posts/solucion-a-las-cartas-del-dr-lira/</link><pubDate>Mon, 29 Jul 2013 15:26:08 +0000</pubDate><guid>https://blog.omegaup.com/posts/solucion-a-las-cartas-del-dr-lira/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2014E1P1#problems/CartasDrLira" target="_blank" rel="noopener">Preselectivo para la IOI 2014, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://www.linkedin.com/in/joemmanuel/" target="_blank" rel="noopener">Joemmanuel Ponce Galindo&lt;/a> &lt;strong>Fuente&lt;/strong>: Topcoder&lt;/p>
&lt;p>Básicamente lo que nos pide el problema es encontrar el número de cartas que son distintas entre la configuración que es dada como entrada y una configuración donde las cartas estén alternadas.&lt;/p>
&lt;p>Cómo se explica en el problema, sólo hay 2 estados posibles en los que una carta puede estar: negro (B) y blanco (W). En otras palabras, la observación clave para resolver el problema es darse cuenta que sólo existen 2 configuraciones que cumplen con las reglas que necesita Dr. Lira: Una configuración donde la primer carta es W, la siguiente B, la siguiente W y así sucesivamente. La otra configuración posible es donde las cartas empiezan con B, forzando la siguiente carta a ser W y esta a su vez forzando la siguiente carta a ser B.&lt;/p>
&lt;p>Contar el número de caracteres diferentes entre una cadena y otra sólo requiere de un ciclo, por lo que la complejidad es lineal con respecto al tamaño de la cadena. Lo único que tenemos que hacer es entonces comparar la cadena dada como entrada con las configuraciones BWBW.. y WBWB&amp;hellip;, contar el número de diferencias y dar como salida el mínimo de estos números.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/6559228.js">&lt;/script></description></item></channel></rss>