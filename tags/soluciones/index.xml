<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>omegaUp blog – Soluciones</title><link>https://blog.omegaup.com/tags/soluciones/</link><description>Recent content in Soluciones on omegaUp blog</description><generator>Hugo -- gohugo.io</generator><language>es</language><lastBuildDate>Wed, 01 Apr 2020 18:08:10 +0000</lastBuildDate><atom:link href="https://blog.omegaup.com/tags/soluciones/index.xml" rel="self" type="application/rss+xml"/><item><title>Soluciones de la Fase 1 de la Liga de Programación omegaUp</title><link>https://blog.omegaup.com/solution/soluciones-a-liga-omegaup-fase-1/</link><pubDate>Wed, 01 Apr 2020 18:08:10 +0000</pubDate><guid>https://blog.omegaup.com/solution/soluciones-a-liga-omegaup-fase-1/</guid><description>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Rango-simple" target="_blank" rel="noopener">Problema A&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-ahttpsomegaupcomarenaproblemrango-simple">&lt;/span>
&lt;a href="#problema-ahttpsomegaupcomarenaproblemrango-simple" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Para este problema, consideramos un arreglo de ocurrencias $O$ sobre los elementos del arreglo. De modo que la respuesta está dada por&lt;/p>
&lt;p>$\sum\limits_{i=A}^B O_{i}$&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/df979afcf721ba5aee429f948350e051.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/A-contar-lapices" target="_blank" rel="noopener">Problema B&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-bhttpsomegaupcomarenaproblema-contar-lapices">&lt;/span>
&lt;a href="#problema-bhttpsomegaupcomarenaproblema-contar-lapices" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Si consideramos el mismo arreglo de ocurrencias $O$ sobre los elementos del arreglo, la respuesta está dada por $O_k$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/2380189d0e29c2e29ab52771f353ebbe.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/nofib" target="_blank" rel="noopener">Problema C&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-chttpsomegaupcomarenaproblemnofib">&lt;/span>
&lt;a href="#problema-chttpsomegaupcomarenaproblemnofib" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Podemos generar todos los elementos de la secuencia de Fibonacci hasta $30000$, y guardarlos en un mapa $M$, de modo que $M_k = 1$ si $k$ es un elemento de Fibonnaci, y $M_k = 0$ en caso contrario. Generamos la respuesta simplemente iterando desde $i = 4$ hasta $i = N - 1$, e imprimimos $i$ si $M_i = 0$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/7d2a6b7afb388ceb9b22cf2f077670f5.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Posicion-Fibonacci" target="_blank" rel="noopener">Problema D&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-dhttpsomegaupcomarenaproblemposicion-fibonacci">&lt;/span>
&lt;a href="#problema-dhttpsomegaupcomarenaproblemposicion-fibonacci" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>La clave para este problema, es usar variables que no provoquen un desbordamiento, por ejemplo, unsigned long long. Luego, es conocido que la serie de Fibonacci crece rápidamente, lo suficiente, como para generar la secuencia con todos sus elementos menores o iguales a $N$, guardando por cada uno su respectiva posición en ella. Por lo tanto, basta con checar si $N$ es un elemento, e imprimir su posición. En caso de no serlo, imprimimos $-1$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/00ea7419ff9454b86d63b052d44d0337.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/estacion" target="_blank" rel="noopener">Problema E&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-ehttpsomegaupcomarenaproblemestacion">&lt;/span>
&lt;a href="#problema-ehttpsomegaupcomarenaproblemestacion" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Este tipo de problema es conocido como straight-forward. Podemos guardar las estaciones de radio, y checar cuál estación es la mas cercana a la frecuencia dada, con una simple resta. En caso de haber dos estaciones con la misma distancia, la respuesta es la mayor. Solo debemos cuidar que la frecuencia esté dentro del rango permitido.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/f1fb91811095dee376d6961c65b8e017.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Tu-y-tu-Futuro" target="_blank" rel="noopener">Problema F&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-fhttpsomegaupcomarenaproblemtu-y-tu-futuro">&lt;/span>
&lt;a href="#problema-fhttpsomegaupcomarenaproblemtu-y-tu-futuro" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>En este problema lo que tenemos es un grafo dirigido acíclico con aristas pesadas (intuitivamente, es un árbol, sin la propiedad de que cualquier par de nodos estan conectados por un único camino). Los vértices son los eventos temporales, las aristas son dirigidas de $p_i$ a $i$, y su peso es $d_i$. Además, cada vértice contiene un valor extra $r_i$. Un grafo que podemos asociar al primer caso de ejemplo es el siguiente.&lt;/p>
&lt;p>&lt;img src="https://blog.omegaup.com/images/example_graph_correct.jpg" alt="" loading="lazy" />&lt;/p>
&lt;p>Sean $v_1$ y $v_k$ dos vértices distintos, tales que $v_1$ es ancestro de $v_k$. Es decir, existe un camino $v_1 \rightarrow v_2 \rightarrow \ldots \rightarrow v_k$ en el grafo. Definimos $S(v_1, v_k)$ como&lt;/p>
&lt;p>$\sum\limits_{i=1}^{k - 1} d_{v_i}$&lt;/p>
&lt;p>Es decir, la suma de los pesos en las aristas del camino. De modo que el problema se convierte en: Para cada vertice $v$, contar cuántos vértices $u$ en su &amp;ldquo;subárbol&amp;rdquo; $\;$ existen tales que&lt;/p>
&lt;p>$r_u - S(v, u) \geq 0 $&lt;/p>
&lt;p>Porque esto siginifica que tenemos suficientes segundos para viajar por el tiempo desde $u$ hasta $v$.&lt;/p>
&lt;p>Consideremos un arreglo $E$, donde la entrada $E_v$ guarda cuántos descendientes $u$ de $v$ satisfacen&lt;/p>
&lt;p>$r_u - S(v, u) \geq 0 $&lt;/p>
&lt;p>Pero&lt;/p>
&lt;p>$r_u - S(p_v, u) &amp;lt; 0 $&lt;/p>
&lt;p>Donde $p_v$ es el padre de $v$. Si $v = 0$, entonces no hace falta considerar a su padre, puesto que no podemos viajar por el tiempo a algún ancestro de $0$ (ya que ni siquiera existe alguno).&lt;/p>
&lt;p>En otras palabras, $E_v$ guarda cuántos descendientes de $v$ llegan a lo mas al vértice $v$.&lt;/p>
&lt;p>También consideremos un arreglo $D$, donde la entrada $D_v$ guarda cuántos descendientes $u$ de $v$ satisfacen&lt;/p>
&lt;p>$ r_u - S(v, u) &amp;lt; 0 $&lt;/p>
&lt;p>Es decir, $D_v$ guarda cuántos descendientes de $v$ no pueden llegar al vertice $v$.&lt;/p>
&lt;p>Y además mantengamos un arreglo $T$, donde la entrada $T_v$ guarda el tamaño del &amp;ldquo;subárbol&amp;rdquo; de $v$ (incluyendo a $v$). En otras palabras, cuántos descendientes tiene $v$ en total mas el mismo.&lt;/p>
&lt;p>Por lo tanto, la respuesta final para el vértice $v$ está dada por&lt;/p>
&lt;p>$(T_v - 1) - \sum\limits_{v \rightarrow u} (E_u + D_u)$&lt;/p>
&lt;p>donde $u$ es un hijo directo de $v$. Ya que esto calcula cuántos descendientes de $v$ si pueden llegar a $v$.&lt;/p>
&lt;p>Para el cálculo de nuestros arreglos, hacemos una dfs sobre el &amp;ldquo;árbol&amp;rdquo;  (partiendo del vertice 0). Para cada vértice $u$, hacemos una búsqueda binaria sobre un arreglo que mantenga la suma acumulada de los costos sobre las aristas que forman parte del camino de $0$ a $u$, que nos devuelva el máximo ancestro $v$ al que podemos llegar desde $u$.  Lo que nos dice que  $E_v$ actualiza su valor a $E_v + 1$ (inicialmente, $E_1 = E_2  = \ldots = E_n = 0$). Esto se puede hacer usando un arreglo global. La idea es añadir la suma acumulada, luego explorar recursivamente el subárbol de $u$, y luego quitar la suma acumulada que añadimos. Esto es particularmente sencillo si usamos un vector de la STL para el arreglo global.&lt;/p>
&lt;p>El arreglo $T$ se calcula facilmente en la misma dfs, ya que&lt;/p>
&lt;p>$T_v = 1 + \sum\limits_{v \rightarrow u} (T_u)$&lt;/p>
&lt;p>Ahora podemos generar $D$, al estilo de programacion dinámica usando $E$. Notemos que&lt;/p>
&lt;p>$D_v = \sum\limits_{v \rightarrow u} (E_ u + D_u)$&lt;/p>
&lt;p>Lo que se puede hacer en la misma DFS.&lt;/p>
&lt;p>Por lo tanto, nuestro algoritmo tiene complejidad $O(Nlog(N))$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/230bf4f852d80fba75be9f2c322124b4.js">&lt;/script>
&lt;h2>&lt;a href="https://omegaup.com/arena/problem/Karel-y-los-quebrados" target="_blank" rel="noopener">Problema G&lt;/a>&lt;span class="hx-absolute -hx-mt-20" id="problema-ghttpsomegaupcomarenaproblemkarel-y-los-quebrados">&lt;/span>
&lt;a href="#problema-ghttpsomegaupcomarenaproblemkarel-y-los-quebrados" class="subheading-anchor" aria-label="Permalink for this section">&lt;/a>&lt;/h2>&lt;p>Primero reescribamos la expresión dada como&lt;/p>
&lt;p>$k = \dfrac{xy}{x + y}$&lt;/p>
&lt;p>De donde podemos despejar $y$ como&lt;/p>
&lt;p>$y = \dfrac{xk}{x - k}$&lt;/p>
&lt;p>Sin perdida de generalidad, supongamos $x \leq y$, entonces se tiene&lt;/p>
&lt;p>$x \leq \dfrac{xk}{x - k}$&lt;/p>
&lt;p>$x^2 \leq 2xk$&lt;/p>
&lt;p>$x \leq 2k$&lt;/p>
&lt;p>Por lo tanto, podemos iterar $x$ desde $1$ hasta $2k$, obtenemos $y$, y verificamos que $k = \dfrac{xy}{x + y}, y &amp;gt; 0$.&lt;/p>
&lt;p>Guardamos las parejas que satisfazcan dichas condiciones y las imprimimos en el orden requerido, cuidando no repetir alguna respuesta.&lt;/p>
&lt;p>Lo que nos deja con un algoritmo de complejidad $O(k)$.&lt;/p>
&lt;p>Una solución alternativa es la siguiente:&lt;/p>
&lt;p>Te puedes dar cuenta que $x, y &amp;gt; k$, entonces el problema se convierte a  buscar $a$ y $b$ que cumplan&lt;/p>
&lt;p>$\dfrac{1}{k} = \dfrac{1}{k + a} + \dfrac{1}{k + b}$&lt;/p>
&lt;p>con $a,b &amp;gt; 0$. Si simplificas la igualdad llegas a que $k^2 = ab$, así que todo se reduce a encontrar las parejas de divisores $a, b$ de $k^2$.  Lo que deja también un algoritmo de complejidad $O(k)$.&lt;/p>
&lt;p>Nota: Agradezco a José Tapia y a Carlos Galeana por su colaboración en el problema $G$.&lt;/p>
&lt;script src="https://gist.github.com/DBriaares/1bf8bac6ba8c1040befc7b4b64900ac2.js">&lt;/script></description></item><item><title>Solución a "Temblor"</title><link>https://blog.omegaup.com/solution/solucion-a-temblor/</link><pubDate>Fri, 24 Jul 2015 07:07:00 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-temblor/</guid><description>
&lt;p>Problema: &lt;a href="https://omegaup.com/arena/problem/temblor" target="_blank" rel="noopener">Temblor&lt;/a>&lt;/p>
&lt;p>Primero que nada, tratemos de entender qué es lo que se nos pide, pues es un problema poco tradicional: Dado un mapa de a lo más 4x4, hay que dar una serie de instrucciones que, sin importar en donde te encuentres en el mapa, logre llevarte a una salida; esta secuencia además, debe de ser la más pequeña posible.&lt;/p>
&lt;p>Este es el caso de ejemplo:&lt;/p>
&lt;p>&lt;img src="http://2.bp.blogspot.com/-_cxWM1TGYS4/T32p22oRTxI/AAAAAAAACVg/xtv0PTznyo8/s1600/mapa.png" alt="mapa" loading="lazy" />&lt;/p>
&lt;p>La solución correcta es ONNEE, pues con esas instrucciones, podemos salir no importando en que lugar estemos (el lugar inicial está marcado con un punto rojo):&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/QD8Rlaz.png" alt="" loading="lazy" />&lt;/p>
&lt;ul>
&lt;li>En el caso 1, las instrucciones ONN no hacen nada pues hay paredes, y las instrucciones EE nos sacan del mapa.&lt;/li>
&lt;li>En el caso 2, ONN no hacen nada de nuevo y la primera E nos saca del mapa (la última E ya no importa).&lt;/li>
&lt;li>En el caso 3, O no hace nada, pues hay pared, N nos sube un lugar, la segunda N no hace nada, y EE nos saca del mapa.&lt;/li>
&lt;li>El caso 4, O nos lleva a la izquierda, donde se vuelve el mismo caso que el caso 3.&lt;/li>
&lt;li>En el caso 5, O no hace nada, y NN nos lleva al caso 1.&lt;/li>
&lt;li>Y finalmente, en el caso 6, O nos lleva al caso 5 y de ahí podemos salir.&lt;/li>
&lt;/ul>
&lt;p>Es mucho más fácil ver la solución si vemos a todos los olímpicos moverse al mismo tiempo:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/UWonMkj.png" alt="" loading="lazy" /> Esto ejemplifica dos cosas: en primer lugar, el camino no debe de ser óptimo para cada uno, sino para todos en general, por ejemplo, el punto que inicia en la esquina superior derecha (cerca de la salida), podría salir yendo hacia la derecha, y saliendo en un único movimiento, pero si lo primero que hacemos es un &amp;ldquo;este&amp;rdquo;, estaremos complicando más las cosas para el resto de los olímpicos atrapados. En segundo lugar, puede haber más de un olímpico en un mismo lugar, y una vez que hay dos olímpicos en un mismo lugar, no importa realmente cuántos hay, sino que hay al menos 1 olímpico en ese lugar:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/fNMNkXW.png" alt="" loading="lazy" />&lt;/p>
&lt;p>O bien, si lo vemos como unos y ceros:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/mE1ISfk.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Donde 1 significa hay al menos un olímpico ahí y 0 significa no hay ningún olímpico ahí.&lt;/p>
&lt;p>Por lo tanto podemos concluir que nuestra tarea es convertir un tablero lleno de 1&amp;rsquo;s en un tablero lleno de 0&amp;rsquo;s.&lt;/p>
&lt;p>A estas alturas, ya tenemos lo suficiente como para hacer una búsqueda en amplitud sobre el problema. Los estados de nuestro espacio de búsqueda están representados por un mapa de NxM lleno de 1&amp;rsquo;s y 0&amp;rsquo;s y las transiciones entre un estado y otro son las operaciones Norte, Sur, Este y Oeste.&lt;/p>
&lt;p>Nuestro árbol de búsqueda empezaría más o menos así:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/PE9EBdZ.png" alt="" loading="lazy" />&lt;/p>
&lt;p>Solo tendríamos que hacer una búsqueda en amplitud hasta llegar al mapa con puros ceros y reconstruir la solución para resolver el problema.&lt;/p>
&lt;p>Sin embargo, representar un mapa entero como un estado puede ser algo problemático, pues podemos tener hasta 16 casillas. Como puede haber un total de 2^16 estados, eso quiere decir que tendremos un arreglo de 17 dimensiones y estaremos usando 2^32 casillas de enteros, lo cual es completamente absurdo, pues aunque nos cupiera en memoria, dudo mucho que un compilador soporte tantas dimensiones y mucho menos que vaya a ser fácil manipularlas.&lt;/p>
&lt;p>Lo que nos tenemos que dar cuenta es que como nuestro estado son únicamente 1&amp;rsquo;s y 0&amp;rsquo;s podemos olvidarnos de la representación del arreglo, pues podemos convertir cada estado en un número binario. Por ejemplo, a continuación presentamos diferentes mapas y su representación binaria: &lt;img src="http://i.imgur.com/MY4v6m4.png" alt="" loading="lazy" /> Esto simplifica muchísimo nuestro espacio de búsqueda, ya que en vez de necesitar dieciséis enteros para representar un estado, ahora solo necesitamos 1, donde cada bit del estado representa una casilla del mapa.&lt;/p>
&lt;p>La pregunta que nos tenemos que hacer ahora es si es posible representar todos los estados con nuestra representación numérica, y la respuesta es que sí, pues solo son hasta 16 casillas en el mapa, o lo que es igual a 16 bits, y sabemos que un entero en la mayoría de los lenguajes modernos soporta hasta 32 bits, por lo tanto nos alcanza y nos sobra para representar todos los enteros.&lt;/p>
&lt;p>La siguiente pregunta que nos tenemos que hacer es si nos va a alcanzar la memoria. Y la respuesta también es sí, pues tenemos hasta 2^16 estados, lo cual es alrededor de 65,000 casillas, cada una de ellas puede guardar ya sea la operación que se hizo para llegar a ella, o el estado del que se llegó, ¡o incluso se pueden guardar ambas cosas! Pues solo necesitamos 16 bits para representar el estado de donde vienes y otros 2 para representar la operación que hiciste. Pero la implementación del problema ya se la dejamos a los competidores. En todo caso, necesitamos únicamente 65,000 enteros lo cual cabe en menos de 300 KB.&lt;/p>
&lt;p>De esta forma, nuestro árbol de búsqueda se transforma, y se vuelve más fácil de manipular:&lt;/p>
&lt;p>&lt;img src="http://i.imgur.com/UzvlkDg.png" alt="" loading="lazy" /> Una vez hecha la conversión con bits, esto se vuelve una búsqueda en amplitud común y corriente desde un número con NxM bits prendidos, hasta 0. Una búsqueda así debe de ser fácil de hacer para cualquier competidor.&lt;/p></description></item><item><title>Solución a "Poema Equino"</title><link>https://blog.omegaup.com/solution/solucion-a-poema-equino/</link><pubDate>Sun, 27 Jul 2014 07:08:35 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-poema-equino/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P5/#problems/Poema-Equino" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 5&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: Edgar Augusto Santiago Nieves, &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Los límites de este problema permitían hacer una búsqueda sobre todos los estados posibles de los caballos sobre el teclado, ya que si el estado es $ (\text{poema},\text{fila caballo}_1,\text{columna caballo}_1,\text{fila caballo}_2,\text{columna caballo}_2)$, solamente hay $ 100 \times (4 \times 10)^2 = 160,000$ estados distintos.&lt;/p>
&lt;p>Además, como el problema no pide la cantidad mínima de movimientos no hace falta hacer una BFS (búsqueda en amplitud), sino que una DFS (búsqueda en profundidad) utilizando el mismo stack del lenguaje es suficiente. Para simplificar la implementación, se podían utilizar varias observaciones. Particularmente, no importa qué caballo es el 1 o el 2, por lo que en vez de escribir código para mover a ambos basta con añadir una transición que cambie los roles de los caballos en cada estado. Esto además de simplificar la implementación sirve como una poda ya que ¡reduce la cantidad de estados a la mitad! (¿por qué?). También, se puede aprovechar que los operadores booleanos en C/C++ evalúan a 1 cuando son verdaderos y a 0 cuando son falsos, lo cual es bastante útil para indexar arreglos.&lt;/p>
&lt;p>Varios competidores fallaron en su primer intento por no revisar que los caballos no podían ocupar la misma tecla al mismo tiempo. ¡Cuidado!&lt;/p>
&lt;p>La siguiente solución implementa las simplificaciones descritas anteriormente.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/3f4d3496fe0e3aadd12b.js">&lt;/script></description></item><item><title>Solución a "Suma Manhattan"</title><link>https://blog.omegaup.com/solution/solucion-a-suma-manhattan/</link><pubDate>Sat, 21 Jun 2014 14:34:14 +0000</pubDate><guid>https://blog.omegaup.com/solution/solucion-a-suma-manhattan/</guid><description>
&lt;p>&lt;strong>Concurso:&lt;/strong> &lt;a href="https://omegaup.com/arena/IOI2015E1P1#problems/Suma-Manhattan" target="_blank" rel="noopener">Preselectivo para la IOI 2015, Etapa 1, Problemset 1&lt;/a> &lt;strong>Autor:&lt;/strong> &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a> &lt;strong>Fuente&lt;/strong>: &lt;a href="http://freddy.mx/" target="_blank" rel="noopener">Freddy Román Cepeda&lt;/a>&lt;/p>
&lt;p>Este problema requería manipular con cuidado la expresión que había que computar. Recordemos que nos piden computar&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} manhattan(S_i,S_j).$&lt;/p>
&lt;p>Para resolver la primer subtarea bastaba con iterar sobre todas las parejas de puntos y calcular su distancia. Esto corre en tiempo cuadrático y no es suficiente para obtener todos los puntos.&lt;/p>
&lt;p>La siguiente subtarea era una pista: se puede computar la distancia Manhattan de dos puntos considerando por separado sus coordenadas en $ x$ y $ y$. Ahora nos preocuparemos por calcular la siguiente expresión:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j|.$&lt;/p>
&lt;p>Donde $ a$ son las coordenadas en $ x$ o $ y$. El problema está en el valor absoluto. La manera más sencilla de deshacernos de él es ordenar la secuencia $ a$, de tal manera que $ a_i \leq a_j$. Entonces tenemos:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_i - a_j| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} |a_j - a_i| = \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - a_i.$&lt;/p>
&lt;p>La primer igualdad es verdadera porque $ |x| = |-x|$ para cualquier $ x$. La segunda es porque como ahora $ a$ está ordenado, como $ a_j \geq a_i \implies a_j - a_i \geq 0$, el valor absoluto no hace nada.&lt;/p>
&lt;p>Podemos entonces separar la suma en dos términos:&lt;/p>
&lt;p>$ \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_j - \sum_{0 \leq i &amp;lt; j &amp;lt; N} a_i.$&lt;/p>
&lt;p>Analicemos el primer término. Estamos sumando sobre todas las $ j$ tantas veces haya una $ i$ menor que ella. Eso quiere decir que cada $ a_j$ la vamos a sumar $ j$ veces (nota que $ a_0$ la sumamos $ 0$ veces).&lt;/p>
&lt;p>El segundo término nos dice que sumaremos todas las $ a_i$ tantas veces haya una $ j$ mayor a ella. Eso quiere decir que cada $ a_i$ la vamos a sumar $ N-i-1$ veces (nota que $ a_{N-1}$ la sumamos $ 0$ veces).&lt;/p>
&lt;p>Juntando esas ideas, entonces tenemos:&lt;/p>
&lt;p>$ \sum_{j = 0}^{N-1} j \cdot a_j - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} i \cdot a_i - \sum_{i = 0}^{N-1} (N - i - 1) \cdot a_i.$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} (i - (N - i - 1)) \cdot a_i.$&lt;/p>
&lt;p>$ = \sum_{i = 0}^{N-1} (2i - N + 1) \cdot a_i.$&lt;/p>
&lt;p>Y con eso terminamos: ahora tenemos una expresión que podemos computar fácilmente en tiempo lineal. Hay que tener cuidado al computar esto: La primera observación es que hay que estar tomando módulo después de cada operación porque en cualquier momento puede haber un &lt;em>overflow&lt;/em>. Algunos competidores obtuvieron 60 puntos en este problema por no tomar esto en cuenta. La segunda observación es que el término $ (2i - N + 1) \cdot a_i$ no necesariamente cabe en un entero signado de 32 bits &amp;ndash; hacía falta utilizar enteros de 64 bits para realizar este cálculo.&lt;/p>
&lt;p>Aquí está mi código que implementa la solución anterior.&lt;/p>
&lt;script src="https://gist.github.com/OlimpiadaMexicanadeInformatica/0614f2d1added587c2fc.js">&lt;/script></description></item></channel></rss>